/* soapC.cpp
   Generated by gSOAP 2.8.124 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2022, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.124 2023-02-04 11:42:21 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	if (!soap->fault)
		return NULL;
	if (soap->version == 2)
		return soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode ? soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value : NULL;
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_tt__IANA_IfTypes:
		return soap_in_tt__IANA_IfTypes(soap, tag, NULL, "tt:IANA-IfTypes");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_tt__RelayMode:
		return soap_in_tt__RelayMode(soap, tag, NULL, "tt:RelayMode");
	case SOAP_TYPE_tt__RelayIdleState:
		return soap_in_tt__RelayIdleState(soap, tag, NULL, "tt:RelayIdleState");
	case SOAP_TYPE_tt__RelayLogicalState:
		return soap_in_tt__RelayLogicalState(soap, tag, NULL, "tt:RelayLogicalState");
	case SOAP_TYPE_tt__UserLevel:
		return soap_in_tt__UserLevel(soap, tag, NULL, "tt:UserLevel");
	case SOAP_TYPE_tt__SetDateTimeType:
		return soap_in_tt__SetDateTimeType(soap, tag, NULL, "tt:SetDateTimeType");
	case SOAP_TYPE_tt__FactoryDefaultType:
		return soap_in_tt__FactoryDefaultType(soap, tag, NULL, "tt:FactoryDefaultType");
	case SOAP_TYPE_tt__SystemLogType:
		return soap_in_tt__SystemLogType(soap, tag, NULL, "tt:SystemLogType");
	case SOAP_TYPE_tt__CapabilityCategory:
		return soap_in_tt__CapabilityCategory(soap, tag, NULL, "tt:CapabilityCategory");
	case SOAP_TYPE_tt__Dot11AuthAndMangementSuite:
		return soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, NULL, "tt:Dot11AuthAndMangementSuite");
	case SOAP_TYPE_tt__Dot11SignalStrength:
		return soap_in_tt__Dot11SignalStrength(soap, tag, NULL, "tt:Dot11SignalStrength");
	case SOAP_TYPE_tt__Dot11Cipher:
		return soap_in_tt__Dot11Cipher(soap, tag, NULL, "tt:Dot11Cipher");
	case SOAP_TYPE_tt__Dot11SecurityMode:
		return soap_in_tt__Dot11SecurityMode(soap, tag, NULL, "tt:Dot11SecurityMode");
	case SOAP_TYPE_tt__Dot11StationMode:
		return soap_in_tt__Dot11StationMode(soap, tag, NULL, "tt:Dot11StationMode");
	case SOAP_TYPE_tt__DynamicDNSType:
		return soap_in_tt__DynamicDNSType(soap, tag, NULL, "tt:DynamicDNSType");
	case SOAP_TYPE_tt__IPAddressFilterType:
		return soap_in_tt__IPAddressFilterType(soap, tag, NULL, "tt:IPAddressFilterType");
	case SOAP_TYPE_tt__IPType:
		return soap_in_tt__IPType(soap, tag, NULL, "tt:IPType");
	case SOAP_TYPE_tt__NetworkHostType:
		return soap_in_tt__NetworkHostType(soap, tag, NULL, "tt:NetworkHostType");
	case SOAP_TYPE_tt__NetworkProtocolType:
		return soap_in_tt__NetworkProtocolType(soap, tag, NULL, "tt:NetworkProtocolType");
	case SOAP_TYPE_tt__IPv6DHCPConfiguration:
		return soap_in_tt__IPv6DHCPConfiguration(soap, tag, NULL, "tt:IPv6DHCPConfiguration");
	case SOAP_TYPE_tt__Duplex:
		return soap_in_tt__Duplex(soap, tag, NULL, "tt:Duplex");
	case SOAP_TYPE_tt__DiscoveryMode:
		return soap_in_tt__DiscoveryMode(soap, tag, NULL, "tt:DiscoveryMode");
	case SOAP_TYPE_tt__ScopeDefinition:
		return soap_in_tt__ScopeDefinition(soap, tag, NULL, "tt:ScopeDefinition");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, tag, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, tag, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_tt__ReferenceToken:
		return soap_in_tt__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken");
	case SOAP_TYPE_tt__AuxiliaryData:
		return soap_in_tt__AuxiliaryData(soap, tag, NULL, "tt:AuxiliaryData");
	case SOAP_TYPE_tt__Dot11PSKPassphrase:
		return soap_in_tt__Dot11PSKPassphrase(soap, tag, NULL, "tt:Dot11PSKPassphrase");
	case SOAP_TYPE_tt__Dot11PSK:
		return soap_in_tt__Dot11PSK(soap, tag, NULL, "tt:Dot11PSK");
	case SOAP_TYPE_tt__Dot11SSIDType:
		return soap_in_tt__Dot11SSIDType(soap, tag, NULL, "tt:Dot11SSIDType");
	case SOAP_TYPE_tt__DNSName:
		return soap_in_tt__DNSName(soap, tag, NULL, "tt:DNSName");
	case SOAP_TYPE_tt__HwAddress:
		return soap_in_tt__HwAddress(soap, tag, NULL, "tt:HwAddress");
	case SOAP_TYPE_tt__IPv6Address:
		return soap_in_tt__IPv6Address(soap, tag, NULL, "tt:IPv6Address");
	case SOAP_TYPE_tt__IPv4Address:
		return soap_in_tt__IPv4Address(soap, tag, NULL, "tt:IPv4Address");
	case SOAP_TYPE_tt__NetworkInterfaceConfigPriority:
		return soap_in_tt__NetworkInterfaceConfigPriority(soap, tag, NULL, "tt:NetworkInterfaceConfigPriority");
	case SOAP_TYPE_tt__Name:
		return soap_in_tt__Name(soap, tag, NULL, "tt:Name");
	case SOAP_TYPE_tt__StringList:
		return soap_in_tt__StringList(soap, tag, NULL, "tt:StringList");
	case SOAP_TYPE_tt__StringAttrList:
		return soap_in_tt__StringAttrList(soap, tag, NULL, "tt:StringAttrList");
	case SOAP_TYPE_tt__IntList:
		return soap_in_tt__IntList(soap, tag, NULL, "tt:IntList");
	case SOAP_TYPE_tt__LocationEntity:
		return soap_in_tt__LocationEntity(soap, tag, NULL, "tt:LocationEntity");
	case SOAP_TYPE_tt__LocalOrientation:
		return soap_in_tt__LocalOrientation(soap, tag, NULL, "tt:LocalOrientation");
	case SOAP_TYPE_tt__LocalLocation:
		return soap_in_tt__LocalLocation(soap, tag, NULL, "tt:LocalLocation");
	case SOAP_TYPE_tt__GeoOrientation:
		return soap_in_tt__GeoOrientation(soap, tag, NULL, "tt:GeoOrientation");
	case SOAP_TYPE_tt__GeoLocation:
		return soap_in_tt__GeoLocation(soap, tag, NULL, "tt:GeoLocation");
	case SOAP_TYPE_tt__IntRange:
		return soap_in_tt__IntRange(soap, tag, NULL, "tt:IntRange");
	case SOAP_TYPE_tt__DateTimeRange:
		return soap_in_tt__DateTimeRange(soap, tag, NULL, "tt:DateTimeRange");
	case SOAP_TYPE_tt__RelayOutput:
		return soap_in_tt__RelayOutput(soap, tag, NULL, "tt:RelayOutput");
	case SOAP_TYPE_tt__RelayOutputSettings:
		return soap_in_tt__RelayOutputSettings(soap, tag, NULL, "tt:RelayOutputSettings");
	case SOAP_TYPE_tt__TLSConfiguration:
		return soap_in_tt__TLSConfiguration(soap, tag, NULL, "tt:TLSConfiguration");
	case SOAP_TYPE_tt__EapMethodExtension:
		return soap_in_tt__EapMethodExtension(soap, tag, NULL, "tt:EapMethodExtension");
	case SOAP_TYPE_tt__EAPMethodConfiguration:
		return soap_in_tt__EAPMethodConfiguration(soap, tag, NULL, "tt:EAPMethodConfiguration");
	case SOAP_TYPE_tt__Dot1XConfigurationExtension:
		return soap_in_tt__Dot1XConfigurationExtension(soap, tag, NULL, "tt:Dot1XConfigurationExtension");
	case SOAP_TYPE_tt__Dot1XConfiguration:
		return soap_in_tt__Dot1XConfiguration(soap, tag, NULL, "tt:Dot1XConfiguration");
	case SOAP_TYPE_tt__CertificateInformationExtension:
		return soap_in_tt__CertificateInformationExtension(soap, tag, NULL, "tt:CertificateInformationExtension");
	case SOAP_TYPE_tt__CertificateUsage:
		return soap_in_tt__CertificateUsage(soap, tag, NULL, "tt:CertificateUsage");
	case SOAP_TYPE_tt__CertificateInformation:
		return soap_in_tt__CertificateInformation(soap, tag, NULL, "tt:CertificateInformation");
	case SOAP_TYPE_tt__CertificateWithPrivateKey:
		return soap_in_tt__CertificateWithPrivateKey(soap, tag, NULL, "tt:CertificateWithPrivateKey");
	case SOAP_TYPE_tt__CertificateStatus:
		return soap_in_tt__CertificateStatus(soap, tag, NULL, "tt:CertificateStatus");
	case SOAP_TYPE_tt__Certificate:
		return soap_in_tt__Certificate(soap, tag, NULL, "tt:Certificate");
	case SOAP_TYPE_tt__UserExtension:
		return soap_in_tt__UserExtension(soap, tag, NULL, "tt:UserExtension");
	case SOAP_TYPE_tt__User:
		return soap_in_tt__User(soap, tag, NULL, "tt:User");
	case SOAP_TYPE_tt__RemoteUser:
		return soap_in_tt__RemoteUser(soap, tag, NULL, "tt:RemoteUser");
	case SOAP_TYPE_tt__TimeZone:
		return soap_in_tt__TimeZone(soap, tag, NULL, "tt:TimeZone");
	case SOAP_TYPE_tt__Time:
		return soap_in_tt__Time(soap, tag, NULL, "tt:Time");
	case SOAP_TYPE_tt__Date:
		return soap_in_tt__Date(soap, tag, NULL, "tt:Date");
	case SOAP_TYPE_tt__DateTime:
		return soap_in_tt__DateTime(soap, tag, NULL, "tt:DateTime");
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		return soap_in_tt__SystemDateTimeExtension(soap, tag, NULL, "tt:SystemDateTimeExtension");
	case SOAP_TYPE_tt__SystemDateTime:
		return soap_in_tt__SystemDateTime(soap, tag, NULL, "tt:SystemDateTime");
	case SOAP_TYPE_tt__SystemLogUri:
		return soap_in_tt__SystemLogUri(soap, tag, NULL, "tt:SystemLogUri");
	case SOAP_TYPE_tt__SystemLogUriList:
		return soap_in_tt__SystemLogUriList(soap, tag, NULL, "tt:SystemLogUriList");
	case SOAP_TYPE_tt__BackupFile:
		return soap_in_tt__BackupFile(soap, tag, NULL, "tt:BackupFile");
	case SOAP_TYPE_tt__AttachmentData:
		return soap_in_tt__AttachmentData(soap, tag, NULL, "tt:AttachmentData");
	case SOAP_TYPE_tt__BinaryData:
		return soap_in_tt__BinaryData(soap, tag, NULL, "tt:BinaryData");
	case SOAP_TYPE_tt__SupportInformation:
		return soap_in_tt__SupportInformation(soap, tag, NULL, "tt:SupportInformation");
	case SOAP_TYPE_tt__SystemLog:
		return soap_in_tt__SystemLog(soap, tag, NULL, "tt:SystemLog");
	case SOAP_TYPE_tt__AnalyticsDeviceExtension:
		return soap_in_tt__AnalyticsDeviceExtension(soap, tag, NULL, "tt:AnalyticsDeviceExtension");
	case SOAP_TYPE_tt__AnalyticsDeviceCapabilities:
		return soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, NULL, "tt:AnalyticsDeviceCapabilities");
	case SOAP_TYPE_tt__ReceiverCapabilities:
		return soap_in_tt__ReceiverCapabilities(soap, tag, NULL, "tt:ReceiverCapabilities");
	case SOAP_TYPE_tt__ReplayCapabilities:
		return soap_in_tt__ReplayCapabilities(soap, tag, NULL, "tt:ReplayCapabilities");
	case SOAP_TYPE_tt__SearchCapabilities:
		return soap_in_tt__SearchCapabilities(soap, tag, NULL, "tt:SearchCapabilities");
	case SOAP_TYPE_tt__RecordingCapabilities:
		return soap_in_tt__RecordingCapabilities(soap, tag, NULL, "tt:RecordingCapabilities");
	case SOAP_TYPE_tt__DisplayCapabilities:
		return soap_in_tt__DisplayCapabilities(soap, tag, NULL, "tt:DisplayCapabilities");
	case SOAP_TYPE_tt__DeviceIOCapabilities:
		return soap_in_tt__DeviceIOCapabilities(soap, tag, NULL, "tt:DeviceIOCapabilities");
	case SOAP_TYPE_tt__PTZCapabilities:
		return soap_in_tt__PTZCapabilities(soap, tag, NULL, "tt:PTZCapabilities");
	case SOAP_TYPE_tt__ImagingCapabilities:
		return soap_in_tt__ImagingCapabilities(soap, tag, NULL, "tt:ImagingCapabilities");
	case SOAP_TYPE_tt__OnvifVersion:
		return soap_in_tt__OnvifVersion(soap, tag, NULL, "tt:OnvifVersion");
	case SOAP_TYPE_tt__SystemCapabilitiesExtension2:
		return soap_in_tt__SystemCapabilitiesExtension2(soap, tag, NULL, "tt:SystemCapabilitiesExtension2");
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		return soap_in_tt__SystemCapabilitiesExtension(soap, tag, NULL, "tt:SystemCapabilitiesExtension");
	case SOAP_TYPE_tt__SystemCapabilities:
		return soap_in_tt__SystemCapabilities(soap, tag, NULL, "tt:SystemCapabilities");
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension2:
		return soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, NULL, "tt:SecurityCapabilitiesExtension2");
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		return soap_in_tt__SecurityCapabilitiesExtension(soap, tag, NULL, "tt:SecurityCapabilitiesExtension");
	case SOAP_TYPE_tt__SecurityCapabilities:
		return soap_in_tt__SecurityCapabilities(soap, tag, NULL, "tt:SecurityCapabilities");
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension2:
		return soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, NULL, "tt:NetworkCapabilitiesExtension2");
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		return soap_in_tt__NetworkCapabilitiesExtension(soap, tag, NULL, "tt:NetworkCapabilitiesExtension");
	case SOAP_TYPE_tt__NetworkCapabilities:
		return soap_in_tt__NetworkCapabilities(soap, tag, NULL, "tt:NetworkCapabilities");
	case SOAP_TYPE_tt__ProfileCapabilities:
		return soap_in_tt__ProfileCapabilities(soap, tag, NULL, "tt:ProfileCapabilities");
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		return soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, NULL, "tt:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		return soap_in_tt__RealTimeStreamingCapabilities(soap, tag, NULL, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		return soap_in_tt__MediaCapabilitiesExtension(soap, tag, NULL, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_tt__MediaCapabilities:
		return soap_in_tt__MediaCapabilities(soap, tag, NULL, "tt:MediaCapabilities");
	case SOAP_TYPE_tt__IOCapabilitiesExtension2:
		return soap_in_tt__IOCapabilitiesExtension2(soap, tag, NULL, "tt:IOCapabilitiesExtension2");
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		return soap_in_tt__IOCapabilitiesExtension(soap, tag, NULL, "tt:IOCapabilitiesExtension");
	case SOAP_TYPE_tt__IOCapabilities:
		return soap_in_tt__IOCapabilities(soap, tag, NULL, "tt:IOCapabilities");
	case SOAP_TYPE_tt__EventCapabilities:
		return soap_in_tt__EventCapabilities(soap, tag, NULL, "tt:EventCapabilities");
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		return soap_in_tt__DeviceCapabilitiesExtension(soap, tag, NULL, "tt:DeviceCapabilitiesExtension");
	case SOAP_TYPE_tt__DeviceCapabilities:
		return soap_in_tt__DeviceCapabilities(soap, tag, NULL, "tt:DeviceCapabilities");
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		return soap_in_tt__AnalyticsCapabilities(soap, tag, NULL, "tt:AnalyticsCapabilities");
	case SOAP_TYPE_tt__CapabilitiesExtension2:
		return soap_in_tt__CapabilitiesExtension2(soap, tag, NULL, "tt:CapabilitiesExtension2");
	case SOAP_TYPE_tt__CapabilitiesExtension:
		return soap_in_tt__CapabilitiesExtension(soap, tag, NULL, "tt:CapabilitiesExtension");
	case SOAP_TYPE_tt__Capabilities:
		return soap_in_tt__Capabilities(soap, tag, NULL, "tt:Capabilities");
	case SOAP_TYPE_tt__Dot11AvailableNetworksExtension:
		return soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, NULL, "tt:Dot11AvailableNetworksExtension");
	case SOAP_TYPE_tt__Dot11AvailableNetworks:
		return soap_in_tt__Dot11AvailableNetworks(soap, tag, NULL, "tt:Dot11AvailableNetworks");
	case SOAP_TYPE_tt__Dot11Status:
		return soap_in_tt__Dot11Status(soap, tag, NULL, "tt:Dot11Status");
	case SOAP_TYPE_tt__Dot11Capabilities:
		return soap_in_tt__Dot11Capabilities(soap, tag, NULL, "tt:Dot11Capabilities");
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2:
		return soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, NULL, "tt:NetworkInterfaceSetConfigurationExtension2");
	case SOAP_TYPE_tt__Dot11PSKSetExtension:
		return soap_in_tt__Dot11PSKSetExtension(soap, tag, NULL, "tt:Dot11PSKSetExtension");
	case SOAP_TYPE_tt__Dot11PSKSet:
		return soap_in_tt__Dot11PSKSet(soap, tag, NULL, "tt:Dot11PSKSet");
	case SOAP_TYPE_tt__Dot11SecurityConfigurationExtension:
		return soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, NULL, "tt:Dot11SecurityConfigurationExtension");
	case SOAP_TYPE_tt__Dot11SecurityConfiguration:
		return soap_in_tt__Dot11SecurityConfiguration(soap, tag, NULL, "tt:Dot11SecurityConfiguration");
	case SOAP_TYPE_tt__Dot11Configuration:
		return soap_in_tt__Dot11Configuration(soap, tag, NULL, "tt:Dot11Configuration");
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		return soap_in_tt__IPAddressFilterExtension(soap, tag, NULL, "tt:IPAddressFilterExtension");
	case SOAP_TYPE_tt__IPAddressFilter:
		return soap_in_tt__IPAddressFilter(soap, tag, NULL, "tt:IPAddressFilter");
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension2:
		return soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, NULL, "tt:NetworkZeroConfigurationExtension2");
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		return soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, NULL, "tt:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		return soap_in_tt__NetworkZeroConfiguration(soap, tag, NULL, "tt:NetworkZeroConfiguration");
	case SOAP_TYPE_tt__NetworkGateway:
		return soap_in_tt__NetworkGateway(soap, tag, NULL, "tt:NetworkGateway");
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		return soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, NULL, "tt:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		return soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, NULL, "tt:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		return soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, NULL, "tt:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		return soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, NULL, "tt:NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		return soap_in_tt__DynamicDNSInformationExtension(soap, tag, NULL, "tt:DynamicDNSInformationExtension");
	case SOAP_TYPE_tt__DynamicDNSInformation:
		return soap_in_tt__DynamicDNSInformation(soap, tag, NULL, "tt:DynamicDNSInformation");
	case SOAP_TYPE_tt__NTPInformationExtension:
		return soap_in_tt__NTPInformationExtension(soap, tag, NULL, "tt:NTPInformationExtension");
	case SOAP_TYPE_tt__NTPInformation:
		return soap_in_tt__NTPInformation(soap, tag, NULL, "tt:NTPInformation");
	case SOAP_TYPE_tt__DNSInformationExtension:
		return soap_in_tt__DNSInformationExtension(soap, tag, NULL, "tt:DNSInformationExtension");
	case SOAP_TYPE_tt__DNSInformation:
		return soap_in_tt__DNSInformation(soap, tag, NULL, "tt:DNSInformation");
	case SOAP_TYPE_tt__HostnameInformationExtension:
		return soap_in_tt__HostnameInformationExtension(soap, tag, NULL, "tt:HostnameInformationExtension");
	case SOAP_TYPE_tt__HostnameInformation:
		return soap_in_tt__HostnameInformation(soap, tag, NULL, "tt:HostnameInformation");
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		return soap_in_tt__PrefixedIPv6Address(soap, tag, NULL, "tt:PrefixedIPv6Address");
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		return soap_in_tt__PrefixedIPv4Address(soap, tag, NULL, "tt:PrefixedIPv4Address");
	case SOAP_TYPE_tt__IPAddress:
		return soap_in_tt__IPAddress(soap, tag, NULL, "tt:IPAddress");
	case SOAP_TYPE_tt__NetworkHostExtension:
		return soap_in_tt__NetworkHostExtension(soap, tag, NULL, "tt:NetworkHostExtension");
	case SOAP_TYPE_tt__NetworkHost:
		return soap_in_tt__NetworkHost(soap, tag, NULL, "tt:NetworkHost");
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		return soap_in_tt__NetworkProtocolExtension(soap, tag, NULL, "tt:NetworkProtocolExtension");
	case SOAP_TYPE_tt__NetworkProtocol:
		return soap_in_tt__NetworkProtocol(soap, tag, NULL, "tt:NetworkProtocol");
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		return soap_in_tt__IPv6ConfigurationExtension(soap, tag, NULL, "tt:IPv6ConfigurationExtension");
	case SOAP_TYPE_tt__IPv6Configuration:
		return soap_in_tt__IPv6Configuration(soap, tag, NULL, "tt:IPv6Configuration");
	case SOAP_TYPE_tt__IPv4Configuration:
		return soap_in_tt__IPv4Configuration(soap, tag, NULL, "tt:IPv4Configuration");
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		return soap_in_tt__IPv4NetworkInterface(soap, tag, NULL, "tt:IPv4NetworkInterface");
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		return soap_in_tt__IPv6NetworkInterface(soap, tag, NULL, "tt:IPv6NetworkInterface");
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		return soap_in_tt__NetworkInterfaceInfo(soap, tag, NULL, "tt:NetworkInterfaceInfo");
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		return soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, NULL, "tt:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		return soap_in_tt__NetworkInterfaceLink(soap, tag, NULL, "tt:NetworkInterfaceLink");
	case SOAP_TYPE_tt__NetworkInterfaceExtension2:
		return soap_in_tt__NetworkInterfaceExtension2(soap, tag, NULL, "tt:NetworkInterfaceExtension2");
	case SOAP_TYPE_tt__Dot3Configuration:
		return soap_in_tt__Dot3Configuration(soap, tag, NULL, "tt:Dot3Configuration");
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		return soap_in_tt__NetworkInterfaceExtension(soap, tag, NULL, "tt:NetworkInterfaceExtension");
	case SOAP_TYPE_tt__NetworkInterface:
		return soap_in_tt__NetworkInterface(soap, tag, NULL, "tt:NetworkInterface");
	case SOAP_TYPE_tt__Scope:
		return soap_in_tt__Scope(soap, tag, NULL, "tt:Scope");
	case SOAP_TYPE_tt__DeviceEntity:
		return soap_in_tt__DeviceEntity(soap, tag, NULL, "tt:DeviceEntity");
	case SOAP_TYPE_tds__StorageConfiguration:
		return soap_in_tds__StorageConfiguration(soap, tag, NULL, "tds:StorageConfiguration");
	case SOAP_TYPE_tds__StorageConfigurationData:
		return soap_in_tds__StorageConfigurationData(soap, tag, NULL, "tds:StorageConfigurationData");
	case SOAP_TYPE_tds__UserCredential:
		return soap_in_tds__UserCredential(soap, tag, NULL, "tds:UserCredential");
	case SOAP_TYPE_tds__MiscCapabilities:
		return soap_in_tds__MiscCapabilities(soap, tag, NULL, "tds:MiscCapabilities");
	case SOAP_TYPE_tds__SystemCapabilities:
		return soap_in_tds__SystemCapabilities(soap, tag, NULL, "tds:SystemCapabilities");
	case SOAP_TYPE_tds__SecurityCapabilities:
		return soap_in_tds__SecurityCapabilities(soap, tag, NULL, "tds:SecurityCapabilities");
	case SOAP_TYPE_tds__NetworkCapabilities:
		return soap_in_tds__NetworkCapabilities(soap, tag, NULL, "tds:NetworkCapabilities");
	case SOAP_TYPE_tds__DeviceServiceCapabilities:
		return soap_in_tds__DeviceServiceCapabilities(soap, tag, NULL, "tds:DeviceServiceCapabilities");
	case SOAP_TYPE_tds__Service:
		return soap_in_tds__Service(soap, tag, NULL, "tds:Service");
	case SOAP_TYPE_xsd__token:
		return soap_in_xsd__token(soap, tag, NULL, "xsd:token");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, tag, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, tag, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_in_xsd__anySimpleType(soap, tag, NULL, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__NCName:
		return soap_in_xsd__NCName(soap, tag, NULL, "xsd:NCName");
	case SOAP_TYPE_xsd__hexBinary:
		return soap_in_xsd__hexBinary(soap, tag, NULL, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, tag, NULL, "xsd:anyType");
	case SOAP_TYPE_SOAP_ENV__Envelope:
		return soap_in_SOAP_ENV__Envelope(soap, tag, NULL, "SOAP-ENV:Envelope");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_in_chan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, tag, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, tag, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_tds__SetHashingAlgorithm:
		return soap_in_PointerTo_tds__SetHashingAlgorithm(soap, tag, NULL, "tds:SetHashingAlgorithm");
	case SOAP_TYPE_PointerTo_tds__DeleteGeoLocation:
		return soap_in_PointerTo_tds__DeleteGeoLocation(soap, tag, NULL, "tds:DeleteGeoLocation");
	case SOAP_TYPE_PointerTo_tds__SetGeoLocation:
		return soap_in_PointerTo_tds__SetGeoLocation(soap, tag, NULL, "tds:SetGeoLocation");
	case SOAP_TYPE_PointerTo_tds__GetGeoLocation:
		return soap_in_PointerTo_tds__GetGeoLocation(soap, tag, NULL, "tds:GetGeoLocation");
	case SOAP_TYPE_PointerTo_tds__DeleteStorageConfiguration:
		return soap_in_PointerTo_tds__DeleteStorageConfiguration(soap, tag, NULL, "tds:DeleteStorageConfiguration");
	case SOAP_TYPE_PointerTo_tds__SetStorageConfiguration:
		return soap_in_PointerTo_tds__SetStorageConfiguration(soap, tag, NULL, "tds:SetStorageConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetStorageConfiguration:
		return soap_in_PointerTo_tds__GetStorageConfiguration(soap, tag, NULL, "tds:GetStorageConfiguration");
	case SOAP_TYPE_PointerTo_tds__CreateStorageConfiguration:
		return soap_in_PointerTo_tds__CreateStorageConfiguration(soap, tag, NULL, "tds:CreateStorageConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetStorageConfigurations:
		return soap_in_PointerTo_tds__GetStorageConfigurations(soap, tag, NULL, "tds:GetStorageConfigurations");
	case SOAP_TYPE_PointerTo_tds__StartSystemRestore:
		return soap_in_PointerTo_tds__StartSystemRestore(soap, tag, NULL, "tds:StartSystemRestore");
	case SOAP_TYPE_PointerTo_tds__StartFirmwareUpgrade:
		return soap_in_PointerTo_tds__StartFirmwareUpgrade(soap, tag, NULL, "tds:StartFirmwareUpgrade");
	case SOAP_TYPE_PointerTo_tds__GetSystemUris:
		return soap_in_PointerTo_tds__GetSystemUris(soap, tag, NULL, "tds:GetSystemUris");
	case SOAP_TYPE_PointerTo_tds__ScanAvailableDot11Networks:
		return soap_in_PointerTo_tds__ScanAvailableDot11Networks(soap, tag, NULL, "tds:ScanAvailableDot11Networks");
	case SOAP_TYPE_PointerTo_tds__GetDot11Status:
		return soap_in_PointerTo_tds__GetDot11Status(soap, tag, NULL, "tds:GetDot11Status");
	case SOAP_TYPE_PointerTo_tds__GetDot11Capabilities:
		return soap_in_PointerTo_tds__GetDot11Capabilities(soap, tag, NULL, "tds:GetDot11Capabilities");
	case SOAP_TYPE_PointerTo_tds__DeleteDot1XConfiguration:
		return soap_in_PointerTo_tds__DeleteDot1XConfiguration(soap, tag, NULL, "tds:DeleteDot1XConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetDot1XConfigurations:
		return soap_in_PointerTo_tds__GetDot1XConfigurations(soap, tag, NULL, "tds:GetDot1XConfigurations");
	case SOAP_TYPE_PointerTo_tds__GetDot1XConfiguration:
		return soap_in_PointerTo_tds__GetDot1XConfiguration(soap, tag, NULL, "tds:GetDot1XConfiguration");
	case SOAP_TYPE_PointerTo_tds__SetDot1XConfiguration:
		return soap_in_PointerTo_tds__SetDot1XConfiguration(soap, tag, NULL, "tds:SetDot1XConfiguration");
	case SOAP_TYPE_PointerTo_tds__CreateDot1XConfiguration:
		return soap_in_PointerTo_tds__CreateDot1XConfiguration(soap, tag, NULL, "tds:CreateDot1XConfiguration");
	case SOAP_TYPE_PointerTo_tds__LoadCACertificates:
		return soap_in_PointerTo_tds__LoadCACertificates(soap, tag, NULL, "tds:LoadCACertificates");
	case SOAP_TYPE_PointerTo_tds__GetCertificateInformation:
		return soap_in_PointerTo_tds__GetCertificateInformation(soap, tag, NULL, "tds:GetCertificateInformation");
	case SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKey:
		return soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag, NULL, "tds:LoadCertificateWithPrivateKey");
	case SOAP_TYPE_PointerTo_tds__GetCACertificates:
		return soap_in_PointerTo_tds__GetCACertificates(soap, tag, NULL, "tds:GetCACertificates");
	case SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand:
		return soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, tag, NULL, "tds:SendAuxiliaryCommand");
	case SOAP_TYPE_PointerTo_tds__SetRelayOutputState:
		return soap_in_PointerTo_tds__SetRelayOutputState(soap, tag, NULL, "tds:SetRelayOutputState");
	case SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings:
		return soap_in_PointerTo_tds__SetRelayOutputSettings(soap, tag, NULL, "tds:SetRelayOutputSettings");
	case SOAP_TYPE_PointerTo_tds__GetRelayOutputs:
		return soap_in_PointerTo_tds__GetRelayOutputs(soap, tag, NULL, "tds:GetRelayOutputs");
	case SOAP_TYPE_PointerTo_tds__SetClientCertificateMode:
		return soap_in_PointerTo_tds__SetClientCertificateMode(soap, tag, NULL, "tds:SetClientCertificateMode");
	case SOAP_TYPE_PointerTo_tds__GetClientCertificateMode:
		return soap_in_PointerTo_tds__GetClientCertificateMode(soap, tag, NULL, "tds:GetClientCertificateMode");
	case SOAP_TYPE_PointerTo_tds__LoadCertificates:
		return soap_in_PointerTo_tds__LoadCertificates(soap, tag, NULL, "tds:LoadCertificates");
	case SOAP_TYPE_PointerTo_tds__GetPkcs10Request:
		return soap_in_PointerTo_tds__GetPkcs10Request(soap, tag, NULL, "tds:GetPkcs10Request");
	case SOAP_TYPE_PointerTo_tds__DeleteCertificates:
		return soap_in_PointerTo_tds__DeleteCertificates(soap, tag, NULL, "tds:DeleteCertificates");
	case SOAP_TYPE_PointerTo_tds__SetCertificatesStatus:
		return soap_in_PointerTo_tds__SetCertificatesStatus(soap, tag, NULL, "tds:SetCertificatesStatus");
	case SOAP_TYPE_PointerTo_tds__GetCertificatesStatus:
		return soap_in_PointerTo_tds__GetCertificatesStatus(soap, tag, NULL, "tds:GetCertificatesStatus");
	case SOAP_TYPE_PointerTo_tds__GetCertificates:
		return soap_in_PointerTo_tds__GetCertificates(soap, tag, NULL, "tds:GetCertificates");
	case SOAP_TYPE_PointerTo_tds__CreateCertificate:
		return soap_in_PointerTo_tds__CreateCertificate(soap, tag, NULL, "tds:CreateCertificate");
	case SOAP_TYPE_PointerTo_tds__SetAccessPolicy:
		return soap_in_PointerTo_tds__SetAccessPolicy(soap, tag, NULL, "tds:SetAccessPolicy");
	case SOAP_TYPE_PointerTo_tds__GetAccessPolicy:
		return soap_in_PointerTo_tds__GetAccessPolicy(soap, tag, NULL, "tds:GetAccessPolicy");
	case SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter:
		return soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, tag, NULL, "tds:RemoveIPAddressFilter");
	case SOAP_TYPE_PointerTo_tds__AddIPAddressFilter:
		return soap_in_PointerTo_tds__AddIPAddressFilter(soap, tag, NULL, "tds:AddIPAddressFilter");
	case SOAP_TYPE_PointerTo_tds__SetIPAddressFilter:
		return soap_in_PointerTo_tds__SetIPAddressFilter(soap, tag, NULL, "tds:SetIPAddressFilter");
	case SOAP_TYPE_PointerTo_tds__GetIPAddressFilter:
		return soap_in_PointerTo_tds__GetIPAddressFilter(soap, tag, NULL, "tds:GetIPAddressFilter");
	case SOAP_TYPE_PointerTo_tds__SetZeroConfiguration:
		return soap_in_PointerTo_tds__SetZeroConfiguration(soap, tag, NULL, "tds:SetZeroConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetZeroConfiguration:
		return soap_in_PointerTo_tds__GetZeroConfiguration(soap, tag, NULL, "tds:GetZeroConfiguration");
	case SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway:
		return soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, tag, NULL, "tds:SetNetworkDefaultGateway");
	case SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway:
		return soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, tag, NULL, "tds:GetNetworkDefaultGateway");
	case SOAP_TYPE_PointerTo_tds__SetNetworkProtocols:
		return soap_in_PointerTo_tds__SetNetworkProtocols(soap, tag, NULL, "tds:SetNetworkProtocols");
	case SOAP_TYPE_PointerTo_tds__GetNetworkProtocols:
		return soap_in_PointerTo_tds__GetNetworkProtocols(soap, tag, NULL, "tds:GetNetworkProtocols");
	case SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces:
		return soap_in_PointerTo_tds__SetNetworkInterfaces(soap, tag, NULL, "tds:SetNetworkInterfaces");
	case SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces:
		return soap_in_PointerTo_tds__GetNetworkInterfaces(soap, tag, NULL, "tds:GetNetworkInterfaces");
	case SOAP_TYPE_PointerTo_tds__SetDynamicDNS:
		return soap_in_PointerTo_tds__SetDynamicDNS(soap, tag, NULL, "tds:SetDynamicDNS");
	case SOAP_TYPE_PointerTo_tds__GetDynamicDNS:
		return soap_in_PointerTo_tds__GetDynamicDNS(soap, tag, NULL, "tds:GetDynamicDNS");
	case SOAP_TYPE_PointerTo_tds__SetNTP:
		return soap_in_PointerTo_tds__SetNTP(soap, tag, NULL, "tds:SetNTP");
	case SOAP_TYPE_PointerTo_tds__GetNTP:
		return soap_in_PointerTo_tds__GetNTP(soap, tag, NULL, "tds:GetNTP");
	case SOAP_TYPE_PointerTo_tds__SetDNS:
		return soap_in_PointerTo_tds__SetDNS(soap, tag, NULL, "tds:SetDNS");
	case SOAP_TYPE_PointerTo_tds__GetDNS:
		return soap_in_PointerTo_tds__GetDNS(soap, tag, NULL, "tds:GetDNS");
	case SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP:
		return soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, tag, NULL, "tds:SetHostnameFromDHCP");
	case SOAP_TYPE_PointerTo_tds__SetHostname:
		return soap_in_PointerTo_tds__SetHostname(soap, tag, NULL, "tds:SetHostname");
	case SOAP_TYPE_PointerTo_tds__GetHostname:
		return soap_in_PointerTo_tds__GetHostname(soap, tag, NULL, "tds:GetHostname");
	case SOAP_TYPE_PointerTo_tds__SetDPAddresses:
		return soap_in_PointerTo_tds__SetDPAddresses(soap, tag, NULL, "tds:SetDPAddresses");
	case SOAP_TYPE_PointerTo_tds__GetCapabilities:
		return soap_in_PointerTo_tds__GetCapabilities(soap, tag, NULL, "tds:GetCapabilities");
	case SOAP_TYPE_PointerTo_tds__SetAuthFailureWarningConfiguration:
		return soap_in_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, tag, NULL, "tds:SetAuthFailureWarningConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetAuthFailureWarningConfiguration:
		return soap_in_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, tag, NULL, "tds:GetAuthFailureWarningConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetAuthFailureWarningOptions:
		return soap_in_PointerTo_tds__GetAuthFailureWarningOptions(soap, tag, NULL, "tds:GetAuthFailureWarningOptions");
	case SOAP_TYPE_PointerTo_tds__SetPasswordHistoryConfiguration:
		return soap_in_PointerTo_tds__SetPasswordHistoryConfiguration(soap, tag, NULL, "tds:SetPasswordHistoryConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetPasswordHistoryConfiguration:
		return soap_in_PointerTo_tds__GetPasswordHistoryConfiguration(soap, tag, NULL, "tds:GetPasswordHistoryConfiguration");
	case SOAP_TYPE_PointerTo_tds__SetPasswordComplexityConfiguration:
		return soap_in_PointerTo_tds__SetPasswordComplexityConfiguration(soap, tag, NULL, "tds:SetPasswordComplexityConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetPasswordComplexityConfiguration:
		return soap_in_PointerTo_tds__GetPasswordComplexityConfiguration(soap, tag, NULL, "tds:GetPasswordComplexityConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetPasswordComplexityOptions:
		return soap_in_PointerTo_tds__GetPasswordComplexityOptions(soap, tag, NULL, "tds:GetPasswordComplexityOptions");
	case SOAP_TYPE_PointerTo_tds__GetWsdlUrl:
		return soap_in_PointerTo_tds__GetWsdlUrl(soap, tag, NULL, "tds:GetWsdlUrl");
	case SOAP_TYPE_PointerTo_tds__SetUser:
		return soap_in_PointerTo_tds__SetUser(soap, tag, NULL, "tds:SetUser");
	case SOAP_TYPE_PointerTo_tds__DeleteUsers:
		return soap_in_PointerTo_tds__DeleteUsers(soap, tag, NULL, "tds:DeleteUsers");
	case SOAP_TYPE_PointerTo_tds__CreateUsers:
		return soap_in_PointerTo_tds__CreateUsers(soap, tag, NULL, "tds:CreateUsers");
	case SOAP_TYPE_PointerTo_tds__GetUsers:
		return soap_in_PointerTo_tds__GetUsers(soap, tag, NULL, "tds:GetUsers");
	case SOAP_TYPE_PointerTo_tds__SetRemoteUser:
		return soap_in_PointerTo_tds__SetRemoteUser(soap, tag, NULL, "tds:SetRemoteUser");
	case SOAP_TYPE_PointerTo_tds__GetRemoteUser:
		return soap_in_PointerTo_tds__GetRemoteUser(soap, tag, NULL, "tds:GetRemoteUser");
	case SOAP_TYPE_PointerTo_tds__GetEndpointReference:
		return soap_in_PointerTo_tds__GetEndpointReference(soap, tag, NULL, "tds:GetEndpointReference");
	case SOAP_TYPE_PointerTo_tds__GetDPAddresses:
		return soap_in_PointerTo_tds__GetDPAddresses(soap, tag, NULL, "tds:GetDPAddresses");
	case SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryMode:
		return soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag, NULL, "tds:SetRemoteDiscoveryMode");
	case SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryMode:
		return soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag, NULL, "tds:GetRemoteDiscoveryMode");
	case SOAP_TYPE_PointerTo_tds__SetDiscoveryMode:
		return soap_in_PointerTo_tds__SetDiscoveryMode(soap, tag, NULL, "tds:SetDiscoveryMode");
	case SOAP_TYPE_PointerTo_tds__GetDiscoveryMode:
		return soap_in_PointerTo_tds__GetDiscoveryMode(soap, tag, NULL, "tds:GetDiscoveryMode");
	case SOAP_TYPE_PointerTo_tds__RemoveScopes:
		return soap_in_PointerTo_tds__RemoveScopes(soap, tag, NULL, "tds:RemoveScopes");
	case SOAP_TYPE_PointerTo_tds__AddScopes:
		return soap_in_PointerTo_tds__AddScopes(soap, tag, NULL, "tds:AddScopes");
	case SOAP_TYPE_PointerTo_tds__SetScopes:
		return soap_in_PointerTo_tds__SetScopes(soap, tag, NULL, "tds:SetScopes");
	case SOAP_TYPE_PointerTo_tds__GetScopes:
		return soap_in_PointerTo_tds__GetScopes(soap, tag, NULL, "tds:GetScopes");
	case SOAP_TYPE_PointerTo_tds__GetSystemSupportInformation:
		return soap_in_PointerTo_tds__GetSystemSupportInformation(soap, tag, NULL, "tds:GetSystemSupportInformation");
	case SOAP_TYPE_PointerTo_tds__GetSystemLog:
		return soap_in_PointerTo_tds__GetSystemLog(soap, tag, NULL, "tds:GetSystemLog");
	case SOAP_TYPE_PointerTo_tds__GetSystemBackup:
		return soap_in_PointerTo_tds__GetSystemBackup(soap, tag, NULL, "tds:GetSystemBackup");
	case SOAP_TYPE_PointerTo_tds__RestoreSystem:
		return soap_in_PointerTo_tds__RestoreSystem(soap, tag, NULL, "tds:RestoreSystem");
	case SOAP_TYPE_PointerTo_tds__SystemReboot:
		return soap_in_PointerTo_tds__SystemReboot(soap, tag, NULL, "tds:SystemReboot");
	case SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmware:
		return soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, tag, NULL, "tds:UpgradeSystemFirmware");
	case SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault:
		return soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, tag, NULL, "tds:SetSystemFactoryDefault");
	case SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime:
		return soap_in_PointerTo_tds__GetSystemDateAndTime(soap, tag, NULL, "tds:GetSystemDateAndTime");
	case SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime:
		return soap_in_PointerTo_tds__SetSystemDateAndTime(soap, tag, NULL, "tds:SetSystemDateAndTime");
	case SOAP_TYPE_PointerTo_tds__GetDeviceInformation:
		return soap_in_PointerTo_tds__GetDeviceInformation(soap, tag, NULL, "tds:GetDeviceInformation");
	case SOAP_TYPE_PointerTo_tds__GetServiceCapabilities:
		return soap_in_PointerTo_tds__GetServiceCapabilities(soap, tag, NULL, "tds:GetServiceCapabilities");
	case SOAP_TYPE_PointerTo_tds__GetServices:
		return soap_in_PointerTo_tds__GetServices(soap, tag, NULL, "tds:GetServices");
	case SOAP_TYPE_PointerTott__NetworkInterfaceExtension:
		return soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, NULL, "tt:NetworkInterfaceExtension");
	case SOAP_TYPE_PointerTott__IPv6NetworkInterface:
		return soap_in_PointerTott__IPv6NetworkInterface(soap, tag, NULL, "tt:IPv6NetworkInterface");
	case SOAP_TYPE_PointerTott__IPv4NetworkInterface:
		return soap_in_PointerTott__IPv4NetworkInterface(soap, tag, NULL, "tt:IPv4NetworkInterface");
	case SOAP_TYPE_PointerTott__NetworkInterfaceLink:
		return soap_in_PointerTott__NetworkInterfaceLink(soap, tag, NULL, "tt:NetworkInterfaceLink");
	case SOAP_TYPE_PointerTott__NetworkInterfaceInfo:
		return soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, NULL, "tt:NetworkInterfaceInfo");
	case SOAP_TYPE_PointerTott__LocalOrientation:
		return soap_in_PointerTott__LocalOrientation(soap, tag, NULL, "tt:LocalOrientation");
	case SOAP_TYPE_PointerTott__LocalLocation:
		return soap_in_PointerTott__LocalLocation(soap, tag, NULL, "tt:LocalLocation");
	case SOAP_TYPE_PointerTott__GeoOrientation:
		return soap_in_PointerTott__GeoOrientation(soap, tag, NULL, "tt:GeoOrientation");
	case SOAP_TYPE_PointerTott__GeoLocation:
		return soap_in_PointerTott__GeoLocation(soap, tag, NULL, "tt:GeoLocation");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_PointerTott__EapMethodExtension:
		return soap_in_PointerTott__EapMethodExtension(soap, tag, NULL, "tt:EapMethodExtension");
	case SOAP_TYPE_PointerTott__TLSConfiguration:
		return soap_in_PointerTott__TLSConfiguration(soap, tag, NULL, "tt:TLSConfiguration");
	case SOAP_TYPE_PointerTott__Dot1XConfigurationExtension:
		return soap_in_PointerTott__Dot1XConfigurationExtension(soap, tag, NULL, "tt:Dot1XConfigurationExtension");
	case SOAP_TYPE_PointerTott__EAPMethodConfiguration:
		return soap_in_PointerTott__EAPMethodConfiguration(soap, tag, NULL, "tt:EAPMethodConfiguration");
	case SOAP_TYPE_PointerTott__CertificateInformationExtension:
		return soap_in_PointerTott__CertificateInformationExtension(soap, tag, NULL, "tt:CertificateInformationExtension");
	case SOAP_TYPE_PointerTott__DateTimeRange:
		return soap_in_PointerTott__DateTimeRange(soap, tag, NULL, "tt:DateTimeRange");
	case SOAP_TYPE_PointerTott__CertificateUsage:
		return soap_in_PointerTott__CertificateUsage(soap, tag, NULL, "tt:CertificateUsage");
	case SOAP_TYPE_PointerTott__UserExtension:
		return soap_in_PointerTott__UserExtension(soap, tag, NULL, "tt:UserExtension");
	case SOAP_TYPE_PointerTott__Date:
		return soap_in_PointerTott__Date(soap, tag, NULL, "tt:Date");
	case SOAP_TYPE_PointerTott__Time:
		return soap_in_PointerTott__Time(soap, tag, NULL, "tt:Time");
	case SOAP_TYPE_PointerTott__SystemDateTimeExtension:
		return soap_in_PointerTott__SystemDateTimeExtension(soap, tag, NULL, "tt:SystemDateTimeExtension");
	case SOAP_TYPE_PointerTott__SystemLogUri:
		return soap_in_PointerTott__SystemLogUri(soap, tag, NULL, "tt:SystemLogUri");
	case SOAP_TYPE_PointerTott__AnalyticsDeviceExtension:
		return soap_in_PointerTott__AnalyticsDeviceExtension(soap, tag, NULL, "tt:AnalyticsDeviceExtension");
	case SOAP_TYPE_PointerTott__SystemCapabilitiesExtension2:
		return soap_in_PointerTott__SystemCapabilitiesExtension2(soap, tag, NULL, "tt:SystemCapabilitiesExtension2");
	case SOAP_TYPE_PointerTott__SystemCapabilitiesExtension:
		return soap_in_PointerTott__SystemCapabilitiesExtension(soap, tag, NULL, "tt:SystemCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension2:
		return soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, tag, NULL, "tt:SecurityCapabilitiesExtension2");
	case SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension:
		return soap_in_PointerTott__SecurityCapabilitiesExtension(soap, tag, NULL, "tt:SecurityCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension2:
		return soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, tag, NULL, "tt:NetworkCapabilitiesExtension2");
	case SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension:
		return soap_in_PointerTott__NetworkCapabilitiesExtension(soap, tag, NULL, "tt:NetworkCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension:
		return soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag, NULL, "tt:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__ProfileCapabilities:
		return soap_in_PointerTott__ProfileCapabilities(soap, tag, NULL, "tt:ProfileCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilitiesExtension:
		return soap_in_PointerTott__MediaCapabilitiesExtension(soap, tag, NULL, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities:
		return soap_in_PointerTott__RealTimeStreamingCapabilities(soap, tag, NULL, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_PointerTott__IOCapabilitiesExtension2:
		return soap_in_PointerTott__IOCapabilitiesExtension2(soap, tag, NULL, "tt:IOCapabilitiesExtension2");
	case SOAP_TYPE_PointerTott__IOCapabilitiesExtension:
		return soap_in_PointerTott__IOCapabilitiesExtension(soap, tag, NULL, "tt:IOCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension:
		return soap_in_PointerTott__DeviceCapabilitiesExtension(soap, tag, NULL, "tt:DeviceCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__SecurityCapabilities:
		return soap_in_PointerTott__SecurityCapabilities(soap, tag, NULL, "tt:SecurityCapabilities");
	case SOAP_TYPE_PointerTott__IOCapabilities:
		return soap_in_PointerTott__IOCapabilities(soap, tag, NULL, "tt:IOCapabilities");
	case SOAP_TYPE_PointerTott__SystemCapabilities:
		return soap_in_PointerTott__SystemCapabilities(soap, tag, NULL, "tt:SystemCapabilities");
	case SOAP_TYPE_PointerTott__NetworkCapabilities:
		return soap_in_PointerTott__NetworkCapabilities(soap, tag, NULL, "tt:NetworkCapabilities");
	case SOAP_TYPE_PointerTott__CapabilitiesExtension2:
		return soap_in_PointerTott__CapabilitiesExtension2(soap, tag, NULL, "tt:CapabilitiesExtension2");
	case SOAP_TYPE_PointerTott__AnalyticsDeviceCapabilities:
		return soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, tag, NULL, "tt:AnalyticsDeviceCapabilities");
	case SOAP_TYPE_PointerTott__ReceiverCapabilities:
		return soap_in_PointerTott__ReceiverCapabilities(soap, tag, NULL, "tt:ReceiverCapabilities");
	case SOAP_TYPE_PointerTott__ReplayCapabilities:
		return soap_in_PointerTott__ReplayCapabilities(soap, tag, NULL, "tt:ReplayCapabilities");
	case SOAP_TYPE_PointerTott__SearchCapabilities:
		return soap_in_PointerTott__SearchCapabilities(soap, tag, NULL, "tt:SearchCapabilities");
	case SOAP_TYPE_PointerTott__RecordingCapabilities:
		return soap_in_PointerTott__RecordingCapabilities(soap, tag, NULL, "tt:RecordingCapabilities");
	case SOAP_TYPE_PointerTott__DisplayCapabilities:
		return soap_in_PointerTott__DisplayCapabilities(soap, tag, NULL, "tt:DisplayCapabilities");
	case SOAP_TYPE_PointerTott__DeviceIOCapabilities:
		return soap_in_PointerTott__DeviceIOCapabilities(soap, tag, NULL, "tt:DeviceIOCapabilities");
	case SOAP_TYPE_PointerTott__CapabilitiesExtension:
		return soap_in_PointerTott__CapabilitiesExtension(soap, tag, NULL, "tt:CapabilitiesExtension");
	case SOAP_TYPE_PointerTott__PTZCapabilities:
		return soap_in_PointerTott__PTZCapabilities(soap, tag, NULL, "tt:PTZCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilities:
		return soap_in_PointerTott__MediaCapabilities(soap, tag, NULL, "tt:MediaCapabilities");
	case SOAP_TYPE_PointerTott__ImagingCapabilities:
		return soap_in_PointerTott__ImagingCapabilities(soap, tag, NULL, "tt:ImagingCapabilities");
	case SOAP_TYPE_PointerTott__EventCapabilities:
		return soap_in_PointerTott__EventCapabilities(soap, tag, NULL, "tt:EventCapabilities");
	case SOAP_TYPE_PointerTott__DeviceCapabilities:
		return soap_in_PointerTott__DeviceCapabilities(soap, tag, NULL, "tt:DeviceCapabilities");
	case SOAP_TYPE_PointerTott__AnalyticsCapabilities:
		return soap_in_PointerTott__AnalyticsCapabilities(soap, tag, NULL, "tt:AnalyticsCapabilities");
	case SOAP_TYPE_PointerTott__Dot11AvailableNetworksExtension:
		return soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, tag, NULL, "tt:Dot11AvailableNetworksExtension");
	case SOAP_TYPE_PointerTott__Dot11SignalStrength:
		return soap_in_PointerTott__Dot11SignalStrength(soap, tag, NULL, "tt:Dot11SignalStrength");
	case SOAP_TYPE_PointerTott__Dot11PSKSetExtension:
		return soap_in_PointerTott__Dot11PSKSetExtension(soap, tag, NULL, "tt:Dot11PSKSetExtension");
	case SOAP_TYPE_PointerTott__Dot11PSKPassphrase:
		return soap_in_PointerTott__Dot11PSKPassphrase(soap, tag, NULL, "tt:Dot11PSKPassphrase");
	case SOAP_TYPE_PointerTott__Dot11PSK:
		return soap_in_PointerTott__Dot11PSK(soap, tag, NULL, "tt:Dot11PSK");
	case SOAP_TYPE_PointerTott__Dot11SecurityConfigurationExtension:
		return soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, tag, NULL, "tt:Dot11SecurityConfigurationExtension");
	case SOAP_TYPE_PointerTott__ReferenceToken:
		return soap_in_PointerTott__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken");
	case SOAP_TYPE_PointerTott__Dot11PSKSet:
		return soap_in_PointerTott__Dot11PSKSet(soap, tag, NULL, "tt:Dot11PSKSet");
	case SOAP_TYPE_PointerTott__Dot11Cipher:
		return soap_in_PointerTott__Dot11Cipher(soap, tag, NULL, "tt:Dot11Cipher");
	case SOAP_TYPE_PointerTott__Dot11SecurityConfiguration:
		return soap_in_PointerTott__Dot11SecurityConfiguration(soap, tag, NULL, "tt:Dot11SecurityConfiguration");
	case SOAP_TYPE_PointerTott__IPAddressFilterExtension:
		return soap_in_PointerTott__IPAddressFilterExtension(soap, tag, NULL, "tt:IPAddressFilterExtension");
	case SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension2:
		return soap_in_PointerTott__NetworkZeroConfigurationExtension2(soap, tag, NULL, "tt:NetworkZeroConfigurationExtension2");
	case SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension:
		return soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, tag, NULL, "tt:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_PointerTott__IPv6DHCPConfiguration:
		return soap_in_PointerTott__IPv6DHCPConfiguration(soap, tag, NULL, "tt:IPv6DHCPConfiguration");
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension2:
		return soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag, NULL, "tt:NetworkInterfaceSetConfigurationExtension2");
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension:
		return soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag, NULL, "tt:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration:
		return soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag, NULL, "tt:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration:
		return soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag, NULL, "tt:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTott__DynamicDNSInformationExtension:
		return soap_in_PointerTott__DynamicDNSInformationExtension(soap, tag, NULL, "tt:DynamicDNSInformationExtension");
	case SOAP_TYPE_PointerTott__NTPInformationExtension:
		return soap_in_PointerTott__NTPInformationExtension(soap, tag, NULL, "tt:NTPInformationExtension");
	case SOAP_TYPE_PointerTott__DNSInformationExtension:
		return soap_in_PointerTott__DNSInformationExtension(soap, tag, NULL, "tt:DNSInformationExtension");
	case SOAP_TYPE_PointerTott__HostnameInformationExtension:
		return soap_in_PointerTott__HostnameInformationExtension(soap, tag, NULL, "tt:HostnameInformationExtension");
	case SOAP_TYPE_PointerTott__NetworkHostExtension:
		return soap_in_PointerTott__NetworkHostExtension(soap, tag, NULL, "tt:NetworkHostExtension");
	case SOAP_TYPE_PointerTott__IPv6Address:
		return soap_in_PointerTott__IPv6Address(soap, tag, NULL, "tt:IPv6Address");
	case SOAP_TYPE_PointerTott__IPv4Address:
		return soap_in_PointerTott__IPv4Address(soap, tag, NULL, "tt:IPv4Address");
	case SOAP_TYPE_PointerTott__NetworkProtocolExtension:
		return soap_in_PointerTott__NetworkProtocolExtension(soap, tag, NULL, "tt:NetworkProtocolExtension");
	case SOAP_TYPE_PointerTott__IPv6ConfigurationExtension:
		return soap_in_PointerTott__IPv6ConfigurationExtension(soap, tag, NULL, "tt:IPv6ConfigurationExtension");
	case SOAP_TYPE_PointerTott__PrefixedIPv6Address:
		return soap_in_PointerTott__PrefixedIPv6Address(soap, tag, NULL, "tt:PrefixedIPv6Address");
	case SOAP_TYPE_PointerTott__PrefixedIPv4Address:
		return soap_in_PointerTott__PrefixedIPv4Address(soap, tag, NULL, "tt:PrefixedIPv4Address");
	case SOAP_TYPE_PointerTott__IPv4Configuration:
		return soap_in_PointerTott__IPv4Configuration(soap, tag, NULL, "tt:IPv4Configuration");
	case SOAP_TYPE_PointerTott__IPv6Configuration:
		return soap_in_PointerTott__IPv6Configuration(soap, tag, NULL, "tt:IPv6Configuration");
	case SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting:
		return soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, tag, NULL, "tt:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_PointerTott__NetworkInterfaceExtension2:
		return soap_in_PointerTott__NetworkInterfaceExtension2(soap, tag, NULL, "tt:NetworkInterfaceExtension2");
	case SOAP_TYPE_PointerTott__Dot11Configuration:
		return soap_in_PointerTott__Dot11Configuration(soap, tag, NULL, "tt:Dot11Configuration");
	case SOAP_TYPE_PointerTott__Dot3Configuration:
		return soap_in_PointerTott__Dot3Configuration(soap, tag, NULL, "tt:Dot3Configuration");
	case SOAP_TYPE_PointerTott__LocationEntity:
		return soap_in_PointerTott__LocationEntity(soap, tag, NULL, "tt:LocationEntity");
	case SOAP_TYPE_PointerTotds__StorageConfigurationData:
		return soap_in_PointerTotds__StorageConfigurationData(soap, tag, NULL, "tds:StorageConfigurationData");
	case SOAP_TYPE_PointerTotds__StorageConfiguration:
		return soap_in_PointerTotds__StorageConfiguration(soap, tag, NULL, "tds:StorageConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse_Extension:
		return soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag, NULL, "tds:GetSystemUrisResponse-Extension");
	case SOAP_TYPE_PointerTott__SystemLogUriList:
		return soap_in_PointerTott__SystemLogUriList(soap, tag, NULL, "tt:SystemLogUriList");
	case SOAP_TYPE_PointerTott__Dot11AvailableNetworks:
		return soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, NULL, "tt:Dot11AvailableNetworks");
	case SOAP_TYPE_PointerTott__Dot11Status:
		return soap_in_PointerTott__Dot11Status(soap, tag, NULL, "tt:Dot11Status");
	case SOAP_TYPE_PointerTott__Dot11Capabilities:
		return soap_in_PointerTott__Dot11Capabilities(soap, tag, NULL, "tt:Dot11Capabilities");
	case SOAP_TYPE_PointerTott__AuxiliaryData:
		return soap_in_PointerTott__AuxiliaryData(soap, tag, NULL, "tt:AuxiliaryData");
	case SOAP_TYPE_PointerTott__RelayOutputSettings:
		return soap_in_PointerTott__RelayOutputSettings(soap, tag, NULL, "tt:RelayOutputSettings");
	case SOAP_TYPE_PointerTott__RelayOutput:
		return soap_in_PointerTott__RelayOutput(soap, tag, NULL, "tt:RelayOutput");
	case SOAP_TYPE_PointerTott__Dot1XConfiguration:
		return soap_in_PointerTott__Dot1XConfiguration(soap, tag, NULL, "tt:Dot1XConfiguration");
	case SOAP_TYPE_PointerTott__CertificateInformation:
		return soap_in_PointerTott__CertificateInformation(soap, tag, NULL, "tt:CertificateInformation");
	case SOAP_TYPE_PointerTott__CertificateWithPrivateKey:
		return soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, NULL, "tt:CertificateWithPrivateKey");
	case SOAP_TYPE_PointerTott__CertificateStatus:
		return soap_in_PointerTott__CertificateStatus(soap, tag, NULL, "tt:CertificateStatus");
	case SOAP_TYPE_PointerTott__Certificate:
		return soap_in_PointerTott__Certificate(soap, tag, NULL, "tt:Certificate");
	case SOAP_TYPE_PointerTodateTime:
		return soap_in_PointerTodateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToxsd__token:
		return soap_in_PointerToxsd__token(soap, tag, NULL, "xsd:token");
	case SOAP_TYPE_PointerTott__BinaryData:
		return soap_in_PointerTott__BinaryData(soap, tag, NULL, "tt:BinaryData");
	case SOAP_TYPE_PointerTott__IPAddressFilter:
		return soap_in_PointerTott__IPAddressFilter(soap, tag, NULL, "tt:IPAddressFilter");
	case SOAP_TYPE_PointerTott__NetworkZeroConfiguration:
		return soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, NULL, "tt:NetworkZeroConfiguration");
	case SOAP_TYPE_PointerTott__NetworkGateway:
		return soap_in_PointerTott__NetworkGateway(soap, tag, NULL, "tt:NetworkGateway");
	case SOAP_TYPE_PointerTott__NetworkProtocol:
		return soap_in_PointerTott__NetworkProtocol(soap, tag, NULL, "tt:NetworkProtocol");
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfiguration:
		return soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, tag, NULL, "tt:NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTott__NetworkInterface:
		return soap_in_PointerTott__NetworkInterface(soap, tag, NULL, "tt:NetworkInterface");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTott__DNSName:
		return soap_in_PointerTott__DNSName(soap, tag, NULL, "tt:DNSName");
	case SOAP_TYPE_PointerTott__DynamicDNSInformation:
		return soap_in_PointerTott__DynamicDNSInformation(soap, tag, NULL, "tt:DynamicDNSInformation");
	case SOAP_TYPE_PointerTott__NTPInformation:
		return soap_in_PointerTott__NTPInformation(soap, tag, NULL, "tt:NTPInformation");
	case SOAP_TYPE_PointerTott__IPAddress:
		return soap_in_PointerTott__IPAddress(soap, tag, NULL, "tt:IPAddress");
	case SOAP_TYPE_PointerTott__DNSInformation:
		return soap_in_PointerTott__DNSInformation(soap, tag, NULL, "tt:DNSInformation");
	case SOAP_TYPE_PointerTott__HostnameInformation:
		return soap_in_PointerTott__HostnameInformation(soap, tag, NULL, "tt:HostnameInformation");
	case SOAP_TYPE_PointerTott__Capabilities:
		return soap_in_PointerTott__Capabilities(soap, tag, NULL, "tt:Capabilities");
	case SOAP_TYPE_PointerTott__IntRange:
		return soap_in_PointerTott__IntRange(soap, tag, NULL, "tt:IntRange");
	case SOAP_TYPE_PointerTott__User:
		return soap_in_PointerTott__User(soap, tag, NULL, "tt:User");
	case SOAP_TYPE_PointerTott__RemoteUser:
		return soap_in_PointerTott__RemoteUser(soap, tag, NULL, "tt:RemoteUser");
	case SOAP_TYPE_PointerTott__NetworkHost:
		return soap_in_PointerTott__NetworkHost(soap, tag, NULL, "tt:NetworkHost");
	case SOAP_TYPE_PointerTott__Scope:
		return soap_in_PointerTott__Scope(soap, tag, NULL, "tt:Scope");
	case SOAP_TYPE_PointerTott__SystemLog:
		return soap_in_PointerTott__SystemLog(soap, tag, NULL, "tt:SystemLog");
	case SOAP_TYPE_PointerTott__SupportInformation:
		return soap_in_PointerTott__SupportInformation(soap, tag, NULL, "tt:SupportInformation");
	case SOAP_TYPE_PointerTott__BackupFile:
		return soap_in_PointerTott__BackupFile(soap, tag, NULL, "tt:BackupFile");
	case SOAP_TYPE_PointerTott__AttachmentData:
		return soap_in_PointerTott__AttachmentData(soap, tag, NULL, "tt:AttachmentData");
	case SOAP_TYPE_PointerTott__SystemDateTime:
		return soap_in_PointerTott__SystemDateTime(soap, tag, NULL, "tt:SystemDateTime");
	case SOAP_TYPE_PointerTott__DateTime:
		return soap_in_PointerTott__DateTime(soap, tag, NULL, "tt:DateTime");
	case SOAP_TYPE_PointerTott__TimeZone:
		return soap_in_PointerTott__TimeZone(soap, tag, NULL, "tt:TimeZone");
	case SOAP_TYPE_PointerTotds__DeviceServiceCapabilities:
		return soap_in_PointerTotds__DeviceServiceCapabilities(soap, tag, NULL, "tds:DeviceServiceCapabilities");
	case SOAP_TYPE_PointerTotds__Service:
		return soap_in_PointerTotds__Service(soap, tag, NULL, "tds:Service");
	case SOAP_TYPE_PointerTo_tds__StorageConfigurationData_Extension:
		return soap_in_PointerTo_tds__StorageConfigurationData_Extension(soap, tag, NULL, "tds:StorageConfigurationData-Extension");
	case SOAP_TYPE_PointerTotds__UserCredential:
		return soap_in_PointerTotds__UserCredential(soap, tag, NULL, "tds:UserCredential");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTo_tds__UserCredential_Extension:
		return soap_in_PointerTo_tds__UserCredential_Extension(soap, tag, NULL, "tds:UserCredential-Extension");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTott__StringAttrList:
		return soap_in_PointerTott__StringAttrList(soap, tag, NULL, "tt:StringAttrList");
	case SOAP_TYPE_PointerTott__StringList:
		return soap_in_PointerTott__StringList(soap, tag, NULL, "tt:StringList");
	case SOAP_TYPE_PointerTott__IntList:
		return soap_in_PointerTott__IntList(soap, tag, NULL, "tt:IntList");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTotds__MiscCapabilities:
		return soap_in_PointerTotds__MiscCapabilities(soap, tag, NULL, "tds:MiscCapabilities");
	case SOAP_TYPE_PointerTotds__SystemCapabilities:
		return soap_in_PointerTotds__SystemCapabilities(soap, tag, NULL, "tds:SystemCapabilities");
	case SOAP_TYPE_PointerTotds__SecurityCapabilities:
		return soap_in_PointerTotds__SecurityCapabilities(soap, tag, NULL, "tds:SecurityCapabilities");
	case SOAP_TYPE_PointerTotds__NetworkCapabilities:
		return soap_in_PointerTotds__NetworkCapabilities(soap, tag, NULL, "tds:NetworkCapabilities");
	case SOAP_TYPE_PointerTott__OnvifVersion:
		return soap_in_PointerTott__OnvifVersion(soap, tag, NULL, "tt:OnvifVersion");
	case SOAP_TYPE_PointerTo_tds__Service_Capabilities:
		return soap_in_PointerTo_tds__Service_Capabilities(soap, tag, NULL, "tds:Service-Capabilities");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_in_PointerTochan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, tag, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, tag, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, tag, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, tag, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "tt:ReferenceToken"))
		{	*type = SOAP_TYPE_tt__ReferenceToken;
			return soap_in_tt__ReferenceToken(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AuxiliaryData"))
		{	*type = SOAP_TYPE_tt__AuxiliaryData;
			return soap_in_tt__AuxiliaryData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11PSKPassphrase"))
		{	*type = SOAP_TYPE_tt__Dot11PSKPassphrase;
			return soap_in_tt__Dot11PSKPassphrase(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11PSK"))
		{	*type = SOAP_TYPE_tt__Dot11PSK;
			return soap_in_tt__Dot11PSK(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11SSIDType"))
		{	*type = SOAP_TYPE_tt__Dot11SSIDType;
			return soap_in_tt__Dot11SSIDType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DNSName"))
		{	*type = SOAP_TYPE_tt__DNSName;
			return soap_in_tt__DNSName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:HwAddress"))
		{	*type = SOAP_TYPE_tt__HwAddress;
			return soap_in_tt__HwAddress(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6Address"))
		{	*type = SOAP_TYPE_tt__IPv6Address;
			return soap_in_tt__IPv6Address(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv4Address"))
		{	*type = SOAP_TYPE_tt__IPv4Address;
			return soap_in_tt__IPv4Address(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceConfigPriority"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceConfigPriority;
			return soap_in_tt__NetworkInterfaceConfigPriority(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Name"))
		{	*type = SOAP_TYPE_tt__Name;
			return soap_in_tt__Name(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:StringList"))
		{	*type = SOAP_TYPE_tt__StringList;
			return soap_in_tt__StringList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:StringAttrList"))
		{	*type = SOAP_TYPE_tt__StringAttrList;
			return soap_in_tt__StringAttrList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntList"))
		{	*type = SOAP_TYPE_tt__IntList;
			return soap_in_tt__IntList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:LocationEntity"))
		{	*type = SOAP_TYPE_tt__LocationEntity;
			return soap_in_tt__LocationEntity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:LocalOrientation"))
		{	*type = SOAP_TYPE_tt__LocalOrientation;
			return soap_in_tt__LocalOrientation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:LocalLocation"))
		{	*type = SOAP_TYPE_tt__LocalLocation;
			return soap_in_tt__LocalLocation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:GeoOrientation"))
		{	*type = SOAP_TYPE_tt__GeoOrientation;
			return soap_in_tt__GeoOrientation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:GeoLocation"))
		{	*type = SOAP_TYPE_tt__GeoLocation;
			return soap_in_tt__GeoLocation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRange"))
		{	*type = SOAP_TYPE_tt__IntRange;
			return soap_in_tt__IntRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DateTimeRange"))
		{	*type = SOAP_TYPE_tt__DateTimeRange;
			return soap_in_tt__DateTimeRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelayOutput"))
		{	*type = SOAP_TYPE_tt__RelayOutput;
			return soap_in_tt__RelayOutput(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelayOutputSettings"))
		{	*type = SOAP_TYPE_tt__RelayOutputSettings;
			return soap_in_tt__RelayOutputSettings(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:TLSConfiguration"))
		{	*type = SOAP_TYPE_tt__TLSConfiguration;
			return soap_in_tt__TLSConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EapMethodExtension"))
		{	*type = SOAP_TYPE_tt__EapMethodExtension;
			return soap_in_tt__EapMethodExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EAPMethodConfiguration"))
		{	*type = SOAP_TYPE_tt__EAPMethodConfiguration;
			return soap_in_tt__EAPMethodConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot1XConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__Dot1XConfigurationExtension;
			return soap_in_tt__Dot1XConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot1XConfiguration"))
		{	*type = SOAP_TYPE_tt__Dot1XConfiguration;
			return soap_in_tt__Dot1XConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CertificateInformationExtension"))
		{	*type = SOAP_TYPE_tt__CertificateInformationExtension;
			return soap_in_tt__CertificateInformationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CertificateUsage"))
		{	*type = SOAP_TYPE_tt__CertificateUsage;
			return soap_in_tt__CertificateUsage(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CertificateInformation"))
		{	*type = SOAP_TYPE_tt__CertificateInformation;
			return soap_in_tt__CertificateInformation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CertificateWithPrivateKey"))
		{	*type = SOAP_TYPE_tt__CertificateWithPrivateKey;
			return soap_in_tt__CertificateWithPrivateKey(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CertificateStatus"))
		{	*type = SOAP_TYPE_tt__CertificateStatus;
			return soap_in_tt__CertificateStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Certificate"))
		{	*type = SOAP_TYPE_tt__Certificate;
			return soap_in_tt__Certificate(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:UserExtension"))
		{	*type = SOAP_TYPE_tt__UserExtension;
			return soap_in_tt__UserExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:User"))
		{	*type = SOAP_TYPE_tt__User;
			return soap_in_tt__User(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RemoteUser"))
		{	*type = SOAP_TYPE_tt__RemoteUser;
			return soap_in_tt__RemoteUser(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:TimeZone"))
		{	*type = SOAP_TYPE_tt__TimeZone;
			return soap_in_tt__TimeZone(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Time"))
		{	*type = SOAP_TYPE_tt__Time;
			return soap_in_tt__Time(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Date"))
		{	*type = SOAP_TYPE_tt__Date;
			return soap_in_tt__Date(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DateTime"))
		{	*type = SOAP_TYPE_tt__DateTime;
			return soap_in_tt__DateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemDateTimeExtension"))
		{	*type = SOAP_TYPE_tt__SystemDateTimeExtension;
			return soap_in_tt__SystemDateTimeExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemDateTime"))
		{	*type = SOAP_TYPE_tt__SystemDateTime;
			return soap_in_tt__SystemDateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemLogUri"))
		{	*type = SOAP_TYPE_tt__SystemLogUri;
			return soap_in_tt__SystemLogUri(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemLogUriList"))
		{	*type = SOAP_TYPE_tt__SystemLogUriList;
			return soap_in_tt__SystemLogUriList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BackupFile"))
		{	*type = SOAP_TYPE_tt__BackupFile;
			return soap_in_tt__BackupFile(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AttachmentData"))
		{	*type = SOAP_TYPE_tt__AttachmentData;
			return soap_in_tt__AttachmentData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:BinaryData"))
		{	*type = SOAP_TYPE_tt__BinaryData;
			return soap_in_tt__BinaryData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SupportInformation"))
		{	*type = SOAP_TYPE_tt__SupportInformation;
			return soap_in_tt__SupportInformation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemLog"))
		{	*type = SOAP_TYPE_tt__SystemLog;
			return soap_in_tt__SystemLog(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AnalyticsDeviceExtension"))
		{	*type = SOAP_TYPE_tt__AnalyticsDeviceExtension;
			return soap_in_tt__AnalyticsDeviceExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AnalyticsDeviceCapabilities"))
		{	*type = SOAP_TYPE_tt__AnalyticsDeviceCapabilities;
			return soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ReceiverCapabilities"))
		{	*type = SOAP_TYPE_tt__ReceiverCapabilities;
			return soap_in_tt__ReceiverCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ReplayCapabilities"))
		{	*type = SOAP_TYPE_tt__ReplayCapabilities;
			return soap_in_tt__ReplayCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SearchCapabilities"))
		{	*type = SOAP_TYPE_tt__SearchCapabilities;
			return soap_in_tt__SearchCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RecordingCapabilities"))
		{	*type = SOAP_TYPE_tt__RecordingCapabilities;
			return soap_in_tt__RecordingCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DisplayCapabilities"))
		{	*type = SOAP_TYPE_tt__DisplayCapabilities;
			return soap_in_tt__DisplayCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DeviceIOCapabilities"))
		{	*type = SOAP_TYPE_tt__DeviceIOCapabilities;
			return soap_in_tt__DeviceIOCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZCapabilities"))
		{	*type = SOAP_TYPE_tt__PTZCapabilities;
			return soap_in_tt__PTZCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ImagingCapabilities"))
		{	*type = SOAP_TYPE_tt__ImagingCapabilities;
			return soap_in_tt__ImagingCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:OnvifVersion"))
		{	*type = SOAP_TYPE_tt__OnvifVersion;
			return soap_in_tt__OnvifVersion(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemCapabilitiesExtension2"))
		{	*type = SOAP_TYPE_tt__SystemCapabilitiesExtension2;
			return soap_in_tt__SystemCapabilitiesExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__SystemCapabilitiesExtension;
			return soap_in_tt__SystemCapabilitiesExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemCapabilities"))
		{	*type = SOAP_TYPE_tt__SystemCapabilities;
			return soap_in_tt__SystemCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SecurityCapabilitiesExtension2"))
		{	*type = SOAP_TYPE_tt__SecurityCapabilitiesExtension2;
			return soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SecurityCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__SecurityCapabilitiesExtension;
			return soap_in_tt__SecurityCapabilitiesExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SecurityCapabilities"))
		{	*type = SOAP_TYPE_tt__SecurityCapabilities;
			return soap_in_tt__SecurityCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkCapabilitiesExtension2"))
		{	*type = SOAP_TYPE_tt__NetworkCapabilitiesExtension2;
			return soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__NetworkCapabilitiesExtension;
			return soap_in_tt__NetworkCapabilitiesExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkCapabilities"))
		{	*type = SOAP_TYPE_tt__NetworkCapabilities;
			return soap_in_tt__NetworkCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ProfileCapabilities"))
		{	*type = SOAP_TYPE_tt__ProfileCapabilities;
			return soap_in_tt__ProfileCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RealTimeStreamingCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension;
			return soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RealTimeStreamingCapabilities"))
		{	*type = SOAP_TYPE_tt__RealTimeStreamingCapabilities;
			return soap_in_tt__RealTimeStreamingCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MediaCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__MediaCapabilitiesExtension;
			return soap_in_tt__MediaCapabilitiesExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MediaCapabilities"))
		{	*type = SOAP_TYPE_tt__MediaCapabilities;
			return soap_in_tt__MediaCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IOCapabilitiesExtension2"))
		{	*type = SOAP_TYPE_tt__IOCapabilitiesExtension2;
			return soap_in_tt__IOCapabilitiesExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IOCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__IOCapabilitiesExtension;
			return soap_in_tt__IOCapabilitiesExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IOCapabilities"))
		{	*type = SOAP_TYPE_tt__IOCapabilities;
			return soap_in_tt__IOCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EventCapabilities"))
		{	*type = SOAP_TYPE_tt__EventCapabilities;
			return soap_in_tt__EventCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DeviceCapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__DeviceCapabilitiesExtension;
			return soap_in_tt__DeviceCapabilitiesExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DeviceCapabilities"))
		{	*type = SOAP_TYPE_tt__DeviceCapabilities;
			return soap_in_tt__DeviceCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AnalyticsCapabilities"))
		{	*type = SOAP_TYPE_tt__AnalyticsCapabilities;
			return soap_in_tt__AnalyticsCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CapabilitiesExtension2"))
		{	*type = SOAP_TYPE_tt__CapabilitiesExtension2;
			return soap_in_tt__CapabilitiesExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CapabilitiesExtension"))
		{	*type = SOAP_TYPE_tt__CapabilitiesExtension;
			return soap_in_tt__CapabilitiesExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Capabilities"))
		{	*type = SOAP_TYPE_tt__Capabilities;
			return soap_in_tt__Capabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11AvailableNetworksExtension"))
		{	*type = SOAP_TYPE_tt__Dot11AvailableNetworksExtension;
			return soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11AvailableNetworks"))
		{	*type = SOAP_TYPE_tt__Dot11AvailableNetworks;
			return soap_in_tt__Dot11AvailableNetworks(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11Status"))
		{	*type = SOAP_TYPE_tt__Dot11Status;
			return soap_in_tt__Dot11Status(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11Capabilities"))
		{	*type = SOAP_TYPE_tt__Dot11Capabilities;
			return soap_in_tt__Dot11Capabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceSetConfigurationExtension2"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2;
			return soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11PSKSetExtension"))
		{	*type = SOAP_TYPE_tt__Dot11PSKSetExtension;
			return soap_in_tt__Dot11PSKSetExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11PSKSet"))
		{	*type = SOAP_TYPE_tt__Dot11PSKSet;
			return soap_in_tt__Dot11PSKSet(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11SecurityConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__Dot11SecurityConfigurationExtension;
			return soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11SecurityConfiguration"))
		{	*type = SOAP_TYPE_tt__Dot11SecurityConfiguration;
			return soap_in_tt__Dot11SecurityConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11Configuration"))
		{	*type = SOAP_TYPE_tt__Dot11Configuration;
			return soap_in_tt__Dot11Configuration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPAddressFilterExtension"))
		{	*type = SOAP_TYPE_tt__IPAddressFilterExtension;
			return soap_in_tt__IPAddressFilterExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPAddressFilter"))
		{	*type = SOAP_TYPE_tt__IPAddressFilter;
			return soap_in_tt__IPAddressFilter(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkZeroConfigurationExtension2"))
		{	*type = SOAP_TYPE_tt__NetworkZeroConfigurationExtension2;
			return soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkZeroConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__NetworkZeroConfigurationExtension;
			return soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkZeroConfiguration"))
		{	*type = SOAP_TYPE_tt__NetworkZeroConfiguration;
			return soap_in_tt__NetworkZeroConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkGateway"))
		{	*type = SOAP_TYPE_tt__NetworkGateway;
			return soap_in_tt__NetworkGateway(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv4NetworkInterfaceSetConfiguration"))
		{	*type = SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration;
			return soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6NetworkInterfaceSetConfiguration"))
		{	*type = SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration;
			return soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceSetConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension;
			return soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceSetConfiguration"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceSetConfiguration;
			return soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DynamicDNSInformationExtension"))
		{	*type = SOAP_TYPE_tt__DynamicDNSInformationExtension;
			return soap_in_tt__DynamicDNSInformationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DynamicDNSInformation"))
		{	*type = SOAP_TYPE_tt__DynamicDNSInformation;
			return soap_in_tt__DynamicDNSInformation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NTPInformationExtension"))
		{	*type = SOAP_TYPE_tt__NTPInformationExtension;
			return soap_in_tt__NTPInformationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NTPInformation"))
		{	*type = SOAP_TYPE_tt__NTPInformation;
			return soap_in_tt__NTPInformation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DNSInformationExtension"))
		{	*type = SOAP_TYPE_tt__DNSInformationExtension;
			return soap_in_tt__DNSInformationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DNSInformation"))
		{	*type = SOAP_TYPE_tt__DNSInformation;
			return soap_in_tt__DNSInformation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:HostnameInformationExtension"))
		{	*type = SOAP_TYPE_tt__HostnameInformationExtension;
			return soap_in_tt__HostnameInformationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:HostnameInformation"))
		{	*type = SOAP_TYPE_tt__HostnameInformation;
			return soap_in_tt__HostnameInformation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PrefixedIPv6Address"))
		{	*type = SOAP_TYPE_tt__PrefixedIPv6Address;
			return soap_in_tt__PrefixedIPv6Address(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PrefixedIPv4Address"))
		{	*type = SOAP_TYPE_tt__PrefixedIPv4Address;
			return soap_in_tt__PrefixedIPv4Address(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPAddress"))
		{	*type = SOAP_TYPE_tt__IPAddress;
			return soap_in_tt__IPAddress(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkHostExtension"))
		{	*type = SOAP_TYPE_tt__NetworkHostExtension;
			return soap_in_tt__NetworkHostExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkHost"))
		{	*type = SOAP_TYPE_tt__NetworkHost;
			return soap_in_tt__NetworkHost(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkProtocolExtension"))
		{	*type = SOAP_TYPE_tt__NetworkProtocolExtension;
			return soap_in_tt__NetworkProtocolExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkProtocol"))
		{	*type = SOAP_TYPE_tt__NetworkProtocol;
			return soap_in_tt__NetworkProtocol(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6ConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__IPv6ConfigurationExtension;
			return soap_in_tt__IPv6ConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6Configuration"))
		{	*type = SOAP_TYPE_tt__IPv6Configuration;
			return soap_in_tt__IPv6Configuration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv4Configuration"))
		{	*type = SOAP_TYPE_tt__IPv4Configuration;
			return soap_in_tt__IPv4Configuration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv4NetworkInterface"))
		{	*type = SOAP_TYPE_tt__IPv4NetworkInterface;
			return soap_in_tt__IPv4NetworkInterface(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6NetworkInterface"))
		{	*type = SOAP_TYPE_tt__IPv6NetworkInterface;
			return soap_in_tt__IPv6NetworkInterface(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceInfo"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceInfo;
			return soap_in_tt__NetworkInterfaceInfo(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceConnectionSetting"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceConnectionSetting;
			return soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceLink"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceLink;
			return soap_in_tt__NetworkInterfaceLink(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceExtension2"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceExtension2;
			return soap_in_tt__NetworkInterfaceExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot3Configuration"))
		{	*type = SOAP_TYPE_tt__Dot3Configuration;
			return soap_in_tt__Dot3Configuration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterfaceExtension"))
		{	*type = SOAP_TYPE_tt__NetworkInterfaceExtension;
			return soap_in_tt__NetworkInterfaceExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkInterface"))
		{	*type = SOAP_TYPE_tt__NetworkInterface;
			return soap_in_tt__NetworkInterface(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Scope"))
		{	*type = SOAP_TYPE_tt__Scope;
			return soap_in_tt__Scope(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DeviceEntity"))
		{	*type = SOAP_TYPE_tt__DeviceEntity;
			return soap_in_tt__DeviceEntity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:StorageConfiguration"))
		{	*type = SOAP_TYPE_tds__StorageConfiguration;
			return soap_in_tds__StorageConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:StorageConfigurationData"))
		{	*type = SOAP_TYPE_tds__StorageConfigurationData;
			return soap_in_tds__StorageConfigurationData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:UserCredential"))
		{	*type = SOAP_TYPE_tds__UserCredential;
			return soap_in_tds__UserCredential(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:MiscCapabilities"))
		{	*type = SOAP_TYPE_tds__MiscCapabilities;
			return soap_in_tds__MiscCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SystemCapabilities"))
		{	*type = SOAP_TYPE_tds__SystemCapabilities;
			return soap_in_tds__SystemCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SecurityCapabilities"))
		{	*type = SOAP_TYPE_tds__SecurityCapabilities;
			return soap_in_tds__SecurityCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:NetworkCapabilities"))
		{	*type = SOAP_TYPE_tds__NetworkCapabilities;
			return soap_in_tds__NetworkCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeviceServiceCapabilities"))
		{	*type = SOAP_TYPE_tds__DeviceServiceCapabilities;
			return soap_in_tds__DeviceServiceCapabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:Service"))
		{	*type = SOAP_TYPE_tds__Service;
			return soap_in_tds__Service(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token;
			return soap_in_xsd__token(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anySimpleType"))
		{	*type = SOAP_TYPE_xsd__anySimpleType;
			return soap_in_xsd__anySimpleType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName;
			return soap_in_xsd__NCName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:hexBinary"))
		{	*type = SOAP_TYPE_xsd__hexBinary;
			return soap_in_xsd__hexBinary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IANA-IfTypes"))
		{	*type = SOAP_TYPE_tt__IANA_IfTypes;
			return soap_in_tt__IANA_IfTypes(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelayMode"))
		{	*type = SOAP_TYPE_tt__RelayMode;
			return soap_in_tt__RelayMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelayIdleState"))
		{	*type = SOAP_TYPE_tt__RelayIdleState;
			return soap_in_tt__RelayIdleState(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:RelayLogicalState"))
		{	*type = SOAP_TYPE_tt__RelayLogicalState;
			return soap_in_tt__RelayLogicalState(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:UserLevel"))
		{	*type = SOAP_TYPE_tt__UserLevel;
			return soap_in_tt__UserLevel(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SetDateTimeType"))
		{	*type = SOAP_TYPE_tt__SetDateTimeType;
			return soap_in_tt__SetDateTimeType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FactoryDefaultType"))
		{	*type = SOAP_TYPE_tt__FactoryDefaultType;
			return soap_in_tt__FactoryDefaultType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:SystemLogType"))
		{	*type = SOAP_TYPE_tt__SystemLogType;
			return soap_in_tt__SystemLogType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:CapabilityCategory"))
		{	*type = SOAP_TYPE_tt__CapabilityCategory;
			return soap_in_tt__CapabilityCategory(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11AuthAndMangementSuite"))
		{	*type = SOAP_TYPE_tt__Dot11AuthAndMangementSuite;
			return soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11SignalStrength"))
		{	*type = SOAP_TYPE_tt__Dot11SignalStrength;
			return soap_in_tt__Dot11SignalStrength(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11Cipher"))
		{	*type = SOAP_TYPE_tt__Dot11Cipher;
			return soap_in_tt__Dot11Cipher(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11SecurityMode"))
		{	*type = SOAP_TYPE_tt__Dot11SecurityMode;
			return soap_in_tt__Dot11SecurityMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Dot11StationMode"))
		{	*type = SOAP_TYPE_tt__Dot11StationMode;
			return soap_in_tt__Dot11StationMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DynamicDNSType"))
		{	*type = SOAP_TYPE_tt__DynamicDNSType;
			return soap_in_tt__DynamicDNSType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPAddressFilterType"))
		{	*type = SOAP_TYPE_tt__IPAddressFilterType;
			return soap_in_tt__IPAddressFilterType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPType"))
		{	*type = SOAP_TYPE_tt__IPType;
			return soap_in_tt__IPType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkHostType"))
		{	*type = SOAP_TYPE_tt__NetworkHostType;
			return soap_in_tt__NetworkHostType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:NetworkProtocolType"))
		{	*type = SOAP_TYPE_tt__NetworkProtocolType;
			return soap_in_tt__NetworkProtocolType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IPv6DHCPConfiguration"))
		{	*type = SOAP_TYPE_tt__IPv6DHCPConfiguration;
			return soap_in_tt__IPv6DHCPConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Duplex"))
		{	*type = SOAP_TYPE_tt__Duplex;
			return soap_in_tt__Duplex(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DiscoveryMode"))
		{	*type = SOAP_TYPE_tt__DiscoveryMode;
			return soap_in_tt__DiscoveryMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ScopeDefinition"))
		{	*type = SOAP_TYPE_tt__ScopeDefinition;
			return soap_in_tt__ScopeDefinition(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENV:Envelope"))
		{	*type = SOAP_TYPE_SOAP_ENV__Envelope;
			return soap_in_SOAP_ENV__Envelope(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "chan:ChannelInstanceType"))
		{	*type = SOAP_TYPE_chan__ChannelInstanceType;
			return soap_in_chan__ChannelInstanceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemUrisResponse-Extension"))
		{	*type = SOAP_TYPE__tds__GetSystemUrisResponse_Extension;
			return soap_in__tds__GetSystemUrisResponse_Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:StorageConfigurationData-Extension"))
		{	*type = SOAP_TYPE__tds__StorageConfigurationData_Extension;
			return soap_in__tds__StorageConfigurationData_Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:UserCredential-Extension"))
		{	*type = SOAP_TYPE__tds__UserCredential_Extension;
			return soap_in__tds__UserCredential_Extension(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:Service-Capabilities"))
		{	*type = SOAP_TYPE__tds__Service_Capabilities;
			return soap_in__tds__Service_Capabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeleteGeoLocationResponse"))
		{	*type = SOAP_TYPE__tds__DeleteGeoLocationResponse;
			return soap_in__tds__DeleteGeoLocationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeleteGeoLocation"))
		{	*type = SOAP_TYPE__tds__DeleteGeoLocation;
			return soap_in__tds__DeleteGeoLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetGeoLocationResponse"))
		{	*type = SOAP_TYPE__tds__SetGeoLocationResponse;
			return soap_in__tds__SetGeoLocationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetGeoLocation"))
		{	*type = SOAP_TYPE__tds__SetGeoLocation;
			return soap_in__tds__SetGeoLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetGeoLocationResponse"))
		{	*type = SOAP_TYPE__tds__GetGeoLocationResponse;
			return soap_in__tds__GetGeoLocationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetGeoLocation"))
		{	*type = SOAP_TYPE__tds__GetGeoLocation;
			return soap_in__tds__GetGeoLocation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeleteStorageConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__DeleteStorageConfigurationResponse;
			return soap_in__tds__DeleteStorageConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeleteStorageConfiguration"))
		{	*type = SOAP_TYPE__tds__DeleteStorageConfiguration;
			return soap_in__tds__DeleteStorageConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetStorageConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__SetStorageConfigurationResponse;
			return soap_in__tds__SetStorageConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetStorageConfiguration"))
		{	*type = SOAP_TYPE__tds__SetStorageConfiguration;
			return soap_in__tds__SetStorageConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetStorageConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__GetStorageConfigurationResponse;
			return soap_in__tds__GetStorageConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetStorageConfiguration"))
		{	*type = SOAP_TYPE__tds__GetStorageConfiguration;
			return soap_in__tds__GetStorageConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:CreateStorageConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__CreateStorageConfigurationResponse;
			return soap_in__tds__CreateStorageConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:CreateStorageConfiguration"))
		{	*type = SOAP_TYPE__tds__CreateStorageConfiguration;
			return soap_in__tds__CreateStorageConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetStorageConfigurationsResponse"))
		{	*type = SOAP_TYPE__tds__GetStorageConfigurationsResponse;
			return soap_in__tds__GetStorageConfigurationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetStorageConfigurations"))
		{	*type = SOAP_TYPE__tds__GetStorageConfigurations;
			return soap_in__tds__GetStorageConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetHashingAlgorithmResponse"))
		{	*type = SOAP_TYPE__tds__SetHashingAlgorithmResponse;
			return soap_in__tds__SetHashingAlgorithmResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetHashingAlgorithm"))
		{	*type = SOAP_TYPE__tds__SetHashingAlgorithm;
			return soap_in__tds__SetHashingAlgorithm(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:StartSystemRestoreResponse"))
		{	*type = SOAP_TYPE__tds__StartSystemRestoreResponse;
			return soap_in__tds__StartSystemRestoreResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:StartSystemRestore"))
		{	*type = SOAP_TYPE__tds__StartSystemRestore;
			return soap_in__tds__StartSystemRestore(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:StartFirmwareUpgradeResponse"))
		{	*type = SOAP_TYPE__tds__StartFirmwareUpgradeResponse;
			return soap_in__tds__StartFirmwareUpgradeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:StartFirmwareUpgrade"))
		{	*type = SOAP_TYPE__tds__StartFirmwareUpgrade;
			return soap_in__tds__StartFirmwareUpgrade(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemUrisResponse"))
		{	*type = SOAP_TYPE__tds__GetSystemUrisResponse;
			return soap_in__tds__GetSystemUrisResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemUris"))
		{	*type = SOAP_TYPE__tds__GetSystemUris;
			return soap_in__tds__GetSystemUris(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:ScanAvailableDot11NetworksResponse"))
		{	*type = SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse;
			return soap_in__tds__ScanAvailableDot11NetworksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:ScanAvailableDot11Networks"))
		{	*type = SOAP_TYPE__tds__ScanAvailableDot11Networks;
			return soap_in__tds__ScanAvailableDot11Networks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDot11StatusResponse"))
		{	*type = SOAP_TYPE__tds__GetDot11StatusResponse;
			return soap_in__tds__GetDot11StatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDot11Status"))
		{	*type = SOAP_TYPE__tds__GetDot11Status;
			return soap_in__tds__GetDot11Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDot11CapabilitiesResponse"))
		{	*type = SOAP_TYPE__tds__GetDot11CapabilitiesResponse;
			return soap_in__tds__GetDot11CapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDot11Capabilities"))
		{	*type = SOAP_TYPE__tds__GetDot11Capabilities;
			return soap_in__tds__GetDot11Capabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SendAuxiliaryCommandResponse"))
		{	*type = SOAP_TYPE__tds__SendAuxiliaryCommandResponse;
			return soap_in__tds__SendAuxiliaryCommandResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SendAuxiliaryCommand"))
		{	*type = SOAP_TYPE__tds__SendAuxiliaryCommand;
			return soap_in__tds__SendAuxiliaryCommand(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetRelayOutputStateResponse"))
		{	*type = SOAP_TYPE__tds__SetRelayOutputStateResponse;
			return soap_in__tds__SetRelayOutputStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetRelayOutputState"))
		{	*type = SOAP_TYPE__tds__SetRelayOutputState;
			return soap_in__tds__SetRelayOutputState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetRelayOutputSettingsResponse"))
		{	*type = SOAP_TYPE__tds__SetRelayOutputSettingsResponse;
			return soap_in__tds__SetRelayOutputSettingsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetRelayOutputSettings"))
		{	*type = SOAP_TYPE__tds__SetRelayOutputSettings;
			return soap_in__tds__SetRelayOutputSettings(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetRelayOutputsResponse"))
		{	*type = SOAP_TYPE__tds__GetRelayOutputsResponse;
			return soap_in__tds__GetRelayOutputsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetRelayOutputs"))
		{	*type = SOAP_TYPE__tds__GetRelayOutputs;
			return soap_in__tds__GetRelayOutputs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeleteDot1XConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__DeleteDot1XConfigurationResponse;
			return soap_in__tds__DeleteDot1XConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeleteDot1XConfiguration"))
		{	*type = SOAP_TYPE__tds__DeleteDot1XConfiguration;
			return soap_in__tds__DeleteDot1XConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDot1XConfigurationsResponse"))
		{	*type = SOAP_TYPE__tds__GetDot1XConfigurationsResponse;
			return soap_in__tds__GetDot1XConfigurationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDot1XConfigurations"))
		{	*type = SOAP_TYPE__tds__GetDot1XConfigurations;
			return soap_in__tds__GetDot1XConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDot1XConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__GetDot1XConfigurationResponse;
			return soap_in__tds__GetDot1XConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDot1XConfiguration"))
		{	*type = SOAP_TYPE__tds__GetDot1XConfiguration;
			return soap_in__tds__GetDot1XConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetDot1XConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__SetDot1XConfigurationResponse;
			return soap_in__tds__SetDot1XConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetDot1XConfiguration"))
		{	*type = SOAP_TYPE__tds__SetDot1XConfiguration;
			return soap_in__tds__SetDot1XConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:CreateDot1XConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__CreateDot1XConfigurationResponse;
			return soap_in__tds__CreateDot1XConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:CreateDot1XConfiguration"))
		{	*type = SOAP_TYPE__tds__CreateDot1XConfiguration;
			return soap_in__tds__CreateDot1XConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:LoadCACertificatesResponse"))
		{	*type = SOAP_TYPE__tds__LoadCACertificatesResponse;
			return soap_in__tds__LoadCACertificatesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:LoadCACertificates"))
		{	*type = SOAP_TYPE__tds__LoadCACertificates;
			return soap_in__tds__LoadCACertificates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCertificateInformationResponse"))
		{	*type = SOAP_TYPE__tds__GetCertificateInformationResponse;
			return soap_in__tds__GetCertificateInformationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCertificateInformation"))
		{	*type = SOAP_TYPE__tds__GetCertificateInformation;
			return soap_in__tds__GetCertificateInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:LoadCertificateWithPrivateKeyResponse"))
		{	*type = SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse;
			return soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:LoadCertificateWithPrivateKey"))
		{	*type = SOAP_TYPE__tds__LoadCertificateWithPrivateKey;
			return soap_in__tds__LoadCertificateWithPrivateKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCACertificatesResponse"))
		{	*type = SOAP_TYPE__tds__GetCACertificatesResponse;
			return soap_in__tds__GetCACertificatesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCACertificates"))
		{	*type = SOAP_TYPE__tds__GetCACertificates;
			return soap_in__tds__GetCACertificates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetClientCertificateModeResponse"))
		{	*type = SOAP_TYPE__tds__SetClientCertificateModeResponse;
			return soap_in__tds__SetClientCertificateModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetClientCertificateMode"))
		{	*type = SOAP_TYPE__tds__SetClientCertificateMode;
			return soap_in__tds__SetClientCertificateMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetClientCertificateModeResponse"))
		{	*type = SOAP_TYPE__tds__GetClientCertificateModeResponse;
			return soap_in__tds__GetClientCertificateModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetClientCertificateMode"))
		{	*type = SOAP_TYPE__tds__GetClientCertificateMode;
			return soap_in__tds__GetClientCertificateMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:LoadCertificatesResponse"))
		{	*type = SOAP_TYPE__tds__LoadCertificatesResponse;
			return soap_in__tds__LoadCertificatesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:LoadCertificates"))
		{	*type = SOAP_TYPE__tds__LoadCertificates;
			return soap_in__tds__LoadCertificates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetPkcs10RequestResponse"))
		{	*type = SOAP_TYPE__tds__GetPkcs10RequestResponse;
			return soap_in__tds__GetPkcs10RequestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetPkcs10Request"))
		{	*type = SOAP_TYPE__tds__GetPkcs10Request;
			return soap_in__tds__GetPkcs10Request(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeleteCertificatesResponse"))
		{	*type = SOAP_TYPE__tds__DeleteCertificatesResponse;
			return soap_in__tds__DeleteCertificatesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeleteCertificates"))
		{	*type = SOAP_TYPE__tds__DeleteCertificates;
			return soap_in__tds__DeleteCertificates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetCertificatesStatusResponse"))
		{	*type = SOAP_TYPE__tds__SetCertificatesStatusResponse;
			return soap_in__tds__SetCertificatesStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetCertificatesStatus"))
		{	*type = SOAP_TYPE__tds__SetCertificatesStatus;
			return soap_in__tds__SetCertificatesStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCertificatesStatusResponse"))
		{	*type = SOAP_TYPE__tds__GetCertificatesStatusResponse;
			return soap_in__tds__GetCertificatesStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCertificatesStatus"))
		{	*type = SOAP_TYPE__tds__GetCertificatesStatus;
			return soap_in__tds__GetCertificatesStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCertificatesResponse"))
		{	*type = SOAP_TYPE__tds__GetCertificatesResponse;
			return soap_in__tds__GetCertificatesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCertificates"))
		{	*type = SOAP_TYPE__tds__GetCertificates;
			return soap_in__tds__GetCertificates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:CreateCertificateResponse"))
		{	*type = SOAP_TYPE__tds__CreateCertificateResponse;
			return soap_in__tds__CreateCertificateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:CreateCertificate"))
		{	*type = SOAP_TYPE__tds__CreateCertificate;
			return soap_in__tds__CreateCertificate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetAccessPolicyResponse"))
		{	*type = SOAP_TYPE__tds__SetAccessPolicyResponse;
			return soap_in__tds__SetAccessPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetAccessPolicy"))
		{	*type = SOAP_TYPE__tds__SetAccessPolicy;
			return soap_in__tds__SetAccessPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetAccessPolicyResponse"))
		{	*type = SOAP_TYPE__tds__GetAccessPolicyResponse;
			return soap_in__tds__GetAccessPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetAccessPolicy"))
		{	*type = SOAP_TYPE__tds__GetAccessPolicy;
			return soap_in__tds__GetAccessPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:RemoveIPAddressFilterResponse"))
		{	*type = SOAP_TYPE__tds__RemoveIPAddressFilterResponse;
			return soap_in__tds__RemoveIPAddressFilterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:RemoveIPAddressFilter"))
		{	*type = SOAP_TYPE__tds__RemoveIPAddressFilter;
			return soap_in__tds__RemoveIPAddressFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:AddIPAddressFilterResponse"))
		{	*type = SOAP_TYPE__tds__AddIPAddressFilterResponse;
			return soap_in__tds__AddIPAddressFilterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:AddIPAddressFilter"))
		{	*type = SOAP_TYPE__tds__AddIPAddressFilter;
			return soap_in__tds__AddIPAddressFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetIPAddressFilterResponse"))
		{	*type = SOAP_TYPE__tds__SetIPAddressFilterResponse;
			return soap_in__tds__SetIPAddressFilterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetIPAddressFilter"))
		{	*type = SOAP_TYPE__tds__SetIPAddressFilter;
			return soap_in__tds__SetIPAddressFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetIPAddressFilterResponse"))
		{	*type = SOAP_TYPE__tds__GetIPAddressFilterResponse;
			return soap_in__tds__GetIPAddressFilterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetIPAddressFilter"))
		{	*type = SOAP_TYPE__tds__GetIPAddressFilter;
			return soap_in__tds__GetIPAddressFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetZeroConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__SetZeroConfigurationResponse;
			return soap_in__tds__SetZeroConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetZeroConfiguration"))
		{	*type = SOAP_TYPE__tds__SetZeroConfiguration;
			return soap_in__tds__SetZeroConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetZeroConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__GetZeroConfigurationResponse;
			return soap_in__tds__GetZeroConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetZeroConfiguration"))
		{	*type = SOAP_TYPE__tds__GetZeroConfiguration;
			return soap_in__tds__GetZeroConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetNetworkDefaultGatewayResponse"))
		{	*type = SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse;
			return soap_in__tds__SetNetworkDefaultGatewayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetNetworkDefaultGateway"))
		{	*type = SOAP_TYPE__tds__SetNetworkDefaultGateway;
			return soap_in__tds__SetNetworkDefaultGateway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetNetworkDefaultGatewayResponse"))
		{	*type = SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse;
			return soap_in__tds__GetNetworkDefaultGatewayResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetNetworkDefaultGateway"))
		{	*type = SOAP_TYPE__tds__GetNetworkDefaultGateway;
			return soap_in__tds__GetNetworkDefaultGateway(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetNetworkProtocolsResponse"))
		{	*type = SOAP_TYPE__tds__SetNetworkProtocolsResponse;
			return soap_in__tds__SetNetworkProtocolsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetNetworkProtocols"))
		{	*type = SOAP_TYPE__tds__SetNetworkProtocols;
			return soap_in__tds__SetNetworkProtocols(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetNetworkProtocolsResponse"))
		{	*type = SOAP_TYPE__tds__GetNetworkProtocolsResponse;
			return soap_in__tds__GetNetworkProtocolsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetNetworkProtocols"))
		{	*type = SOAP_TYPE__tds__GetNetworkProtocols;
			return soap_in__tds__GetNetworkProtocols(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetNetworkInterfacesResponse"))
		{	*type = SOAP_TYPE__tds__SetNetworkInterfacesResponse;
			return soap_in__tds__SetNetworkInterfacesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetNetworkInterfaces"))
		{	*type = SOAP_TYPE__tds__SetNetworkInterfaces;
			return soap_in__tds__SetNetworkInterfaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetNetworkInterfacesResponse"))
		{	*type = SOAP_TYPE__tds__GetNetworkInterfacesResponse;
			return soap_in__tds__GetNetworkInterfacesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetNetworkInterfaces"))
		{	*type = SOAP_TYPE__tds__GetNetworkInterfaces;
			return soap_in__tds__GetNetworkInterfaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetDynamicDNSResponse"))
		{	*type = SOAP_TYPE__tds__SetDynamicDNSResponse;
			return soap_in__tds__SetDynamicDNSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetDynamicDNS"))
		{	*type = SOAP_TYPE__tds__SetDynamicDNS;
			return soap_in__tds__SetDynamicDNS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDynamicDNSResponse"))
		{	*type = SOAP_TYPE__tds__GetDynamicDNSResponse;
			return soap_in__tds__GetDynamicDNSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDynamicDNS"))
		{	*type = SOAP_TYPE__tds__GetDynamicDNS;
			return soap_in__tds__GetDynamicDNS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetNTPResponse"))
		{	*type = SOAP_TYPE__tds__SetNTPResponse;
			return soap_in__tds__SetNTPResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetNTP"))
		{	*type = SOAP_TYPE__tds__SetNTP;
			return soap_in__tds__SetNTP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetNTPResponse"))
		{	*type = SOAP_TYPE__tds__GetNTPResponse;
			return soap_in__tds__GetNTPResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetNTP"))
		{	*type = SOAP_TYPE__tds__GetNTP;
			return soap_in__tds__GetNTP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetDNSResponse"))
		{	*type = SOAP_TYPE__tds__SetDNSResponse;
			return soap_in__tds__SetDNSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetDNS"))
		{	*type = SOAP_TYPE__tds__SetDNS;
			return soap_in__tds__SetDNS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDNSResponse"))
		{	*type = SOAP_TYPE__tds__GetDNSResponse;
			return soap_in__tds__GetDNSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDNS"))
		{	*type = SOAP_TYPE__tds__GetDNS;
			return soap_in__tds__GetDNS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetHostnameFromDHCPResponse"))
		{	*type = SOAP_TYPE__tds__SetHostnameFromDHCPResponse;
			return soap_in__tds__SetHostnameFromDHCPResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetHostnameFromDHCP"))
		{	*type = SOAP_TYPE__tds__SetHostnameFromDHCP;
			return soap_in__tds__SetHostnameFromDHCP(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetHostnameResponse"))
		{	*type = SOAP_TYPE__tds__SetHostnameResponse;
			return soap_in__tds__SetHostnameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetHostname"))
		{	*type = SOAP_TYPE__tds__SetHostname;
			return soap_in__tds__SetHostname(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetHostnameResponse"))
		{	*type = SOAP_TYPE__tds__GetHostnameResponse;
			return soap_in__tds__GetHostnameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetHostname"))
		{	*type = SOAP_TYPE__tds__GetHostname;
			return soap_in__tds__GetHostname(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCapabilitiesResponse"))
		{	*type = SOAP_TYPE__tds__GetCapabilitiesResponse;
			return soap_in__tds__GetCapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetCapabilities"))
		{	*type = SOAP_TYPE__tds__GetCapabilities;
			return soap_in__tds__GetCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetAuthFailureWarningConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse;
			return soap_in__tds__SetAuthFailureWarningConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetAuthFailureWarningConfiguration"))
		{	*type = SOAP_TYPE__tds__SetAuthFailureWarningConfiguration;
			return soap_in__tds__SetAuthFailureWarningConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetAuthFailureWarningConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse;
			return soap_in__tds__GetAuthFailureWarningConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetAuthFailureWarningConfiguration"))
		{	*type = SOAP_TYPE__tds__GetAuthFailureWarningConfiguration;
			return soap_in__tds__GetAuthFailureWarningConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetAuthFailureWarningOptionsResponse"))
		{	*type = SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse;
			return soap_in__tds__GetAuthFailureWarningOptionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetAuthFailureWarningOptions"))
		{	*type = SOAP_TYPE__tds__GetAuthFailureWarningOptions;
			return soap_in__tds__GetAuthFailureWarningOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetPasswordHistoryConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse;
			return soap_in__tds__SetPasswordHistoryConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetPasswordHistoryConfiguration"))
		{	*type = SOAP_TYPE__tds__SetPasswordHistoryConfiguration;
			return soap_in__tds__SetPasswordHistoryConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetPasswordHistoryConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse;
			return soap_in__tds__GetPasswordHistoryConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetPasswordHistoryConfiguration"))
		{	*type = SOAP_TYPE__tds__GetPasswordHistoryConfiguration;
			return soap_in__tds__GetPasswordHistoryConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetPasswordComplexityConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse;
			return soap_in__tds__SetPasswordComplexityConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetPasswordComplexityConfiguration"))
		{	*type = SOAP_TYPE__tds__SetPasswordComplexityConfiguration;
			return soap_in__tds__SetPasswordComplexityConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetPasswordComplexityConfigurationResponse"))
		{	*type = SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse;
			return soap_in__tds__GetPasswordComplexityConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetPasswordComplexityConfiguration"))
		{	*type = SOAP_TYPE__tds__GetPasswordComplexityConfiguration;
			return soap_in__tds__GetPasswordComplexityConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetPasswordComplexityOptionsResponse"))
		{	*type = SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse;
			return soap_in__tds__GetPasswordComplexityOptionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetPasswordComplexityOptions"))
		{	*type = SOAP_TYPE__tds__GetPasswordComplexityOptions;
			return soap_in__tds__GetPasswordComplexityOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetWsdlUrlResponse"))
		{	*type = SOAP_TYPE__tds__GetWsdlUrlResponse;
			return soap_in__tds__GetWsdlUrlResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetWsdlUrl"))
		{	*type = SOAP_TYPE__tds__GetWsdlUrl;
			return soap_in__tds__GetWsdlUrl(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetUserResponse"))
		{	*type = SOAP_TYPE__tds__SetUserResponse;
			return soap_in__tds__SetUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetUser"))
		{	*type = SOAP_TYPE__tds__SetUser;
			return soap_in__tds__SetUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeleteUsersResponse"))
		{	*type = SOAP_TYPE__tds__DeleteUsersResponse;
			return soap_in__tds__DeleteUsersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:DeleteUsers"))
		{	*type = SOAP_TYPE__tds__DeleteUsers;
			return soap_in__tds__DeleteUsers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:CreateUsersResponse"))
		{	*type = SOAP_TYPE__tds__CreateUsersResponse;
			return soap_in__tds__CreateUsersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:CreateUsers"))
		{	*type = SOAP_TYPE__tds__CreateUsers;
			return soap_in__tds__CreateUsers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetUsersResponse"))
		{	*type = SOAP_TYPE__tds__GetUsersResponse;
			return soap_in__tds__GetUsersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetUsers"))
		{	*type = SOAP_TYPE__tds__GetUsers;
			return soap_in__tds__GetUsers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetRemoteUserResponse"))
		{	*type = SOAP_TYPE__tds__SetRemoteUserResponse;
			return soap_in__tds__SetRemoteUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetRemoteUser"))
		{	*type = SOAP_TYPE__tds__SetRemoteUser;
			return soap_in__tds__SetRemoteUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetRemoteUserResponse"))
		{	*type = SOAP_TYPE__tds__GetRemoteUserResponse;
			return soap_in__tds__GetRemoteUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetRemoteUser"))
		{	*type = SOAP_TYPE__tds__GetRemoteUser;
			return soap_in__tds__GetRemoteUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetEndpointReferenceResponse"))
		{	*type = SOAP_TYPE__tds__GetEndpointReferenceResponse;
			return soap_in__tds__GetEndpointReferenceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetEndpointReference"))
		{	*type = SOAP_TYPE__tds__GetEndpointReference;
			return soap_in__tds__GetEndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetDPAddressesResponse"))
		{	*type = SOAP_TYPE__tds__SetDPAddressesResponse;
			return soap_in__tds__SetDPAddressesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetDPAddresses"))
		{	*type = SOAP_TYPE__tds__SetDPAddresses;
			return soap_in__tds__SetDPAddresses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDPAddressesResponse"))
		{	*type = SOAP_TYPE__tds__GetDPAddressesResponse;
			return soap_in__tds__GetDPAddressesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDPAddresses"))
		{	*type = SOAP_TYPE__tds__GetDPAddresses;
			return soap_in__tds__GetDPAddresses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetRemoteDiscoveryModeResponse"))
		{	*type = SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse;
			return soap_in__tds__SetRemoteDiscoveryModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetRemoteDiscoveryMode"))
		{	*type = SOAP_TYPE__tds__SetRemoteDiscoveryMode;
			return soap_in__tds__SetRemoteDiscoveryMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetRemoteDiscoveryModeResponse"))
		{	*type = SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse;
			return soap_in__tds__GetRemoteDiscoveryModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetRemoteDiscoveryMode"))
		{	*type = SOAP_TYPE__tds__GetRemoteDiscoveryMode;
			return soap_in__tds__GetRemoteDiscoveryMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetDiscoveryModeResponse"))
		{	*type = SOAP_TYPE__tds__SetDiscoveryModeResponse;
			return soap_in__tds__SetDiscoveryModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetDiscoveryMode"))
		{	*type = SOAP_TYPE__tds__SetDiscoveryMode;
			return soap_in__tds__SetDiscoveryMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDiscoveryModeResponse"))
		{	*type = SOAP_TYPE__tds__GetDiscoveryModeResponse;
			return soap_in__tds__GetDiscoveryModeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDiscoveryMode"))
		{	*type = SOAP_TYPE__tds__GetDiscoveryMode;
			return soap_in__tds__GetDiscoveryMode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:RemoveScopesResponse"))
		{	*type = SOAP_TYPE__tds__RemoveScopesResponse;
			return soap_in__tds__RemoveScopesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:RemoveScopes"))
		{	*type = SOAP_TYPE__tds__RemoveScopes;
			return soap_in__tds__RemoveScopes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:AddScopesResponse"))
		{	*type = SOAP_TYPE__tds__AddScopesResponse;
			return soap_in__tds__AddScopesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:AddScopes"))
		{	*type = SOAP_TYPE__tds__AddScopes;
			return soap_in__tds__AddScopes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetScopesResponse"))
		{	*type = SOAP_TYPE__tds__SetScopesResponse;
			return soap_in__tds__SetScopesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetScopes"))
		{	*type = SOAP_TYPE__tds__SetScopes;
			return soap_in__tds__SetScopes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetScopesResponse"))
		{	*type = SOAP_TYPE__tds__GetScopesResponse;
			return soap_in__tds__GetScopesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetScopes"))
		{	*type = SOAP_TYPE__tds__GetScopes;
			return soap_in__tds__GetScopes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemLogResponse"))
		{	*type = SOAP_TYPE__tds__GetSystemLogResponse;
			return soap_in__tds__GetSystemLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemLog"))
		{	*type = SOAP_TYPE__tds__GetSystemLog;
			return soap_in__tds__GetSystemLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemSupportInformationResponse"))
		{	*type = SOAP_TYPE__tds__GetSystemSupportInformationResponse;
			return soap_in__tds__GetSystemSupportInformationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemSupportInformation"))
		{	*type = SOAP_TYPE__tds__GetSystemSupportInformation;
			return soap_in__tds__GetSystemSupportInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemBackupResponse"))
		{	*type = SOAP_TYPE__tds__GetSystemBackupResponse;
			return soap_in__tds__GetSystemBackupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemBackup"))
		{	*type = SOAP_TYPE__tds__GetSystemBackup;
			return soap_in__tds__GetSystemBackup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:RestoreSystemResponse"))
		{	*type = SOAP_TYPE__tds__RestoreSystemResponse;
			return soap_in__tds__RestoreSystemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:RestoreSystem"))
		{	*type = SOAP_TYPE__tds__RestoreSystem;
			return soap_in__tds__RestoreSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SystemRebootResponse"))
		{	*type = SOAP_TYPE__tds__SystemRebootResponse;
			return soap_in__tds__SystemRebootResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SystemReboot"))
		{	*type = SOAP_TYPE__tds__SystemReboot;
			return soap_in__tds__SystemReboot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:UpgradeSystemFirmwareResponse"))
		{	*type = SOAP_TYPE__tds__UpgradeSystemFirmwareResponse;
			return soap_in__tds__UpgradeSystemFirmwareResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:UpgradeSystemFirmware"))
		{	*type = SOAP_TYPE__tds__UpgradeSystemFirmware;
			return soap_in__tds__UpgradeSystemFirmware(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetSystemFactoryDefaultResponse"))
		{	*type = SOAP_TYPE__tds__SetSystemFactoryDefaultResponse;
			return soap_in__tds__SetSystemFactoryDefaultResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetSystemFactoryDefault"))
		{	*type = SOAP_TYPE__tds__SetSystemFactoryDefault;
			return soap_in__tds__SetSystemFactoryDefault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemDateAndTimeResponse"))
		{	*type = SOAP_TYPE__tds__GetSystemDateAndTimeResponse;
			return soap_in__tds__GetSystemDateAndTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetSystemDateAndTime"))
		{	*type = SOAP_TYPE__tds__GetSystemDateAndTime;
			return soap_in__tds__GetSystemDateAndTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetSystemDateAndTimeResponse"))
		{	*type = SOAP_TYPE__tds__SetSystemDateAndTimeResponse;
			return soap_in__tds__SetSystemDateAndTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:SetSystemDateAndTime"))
		{	*type = SOAP_TYPE__tds__SetSystemDateAndTime;
			return soap_in__tds__SetSystemDateAndTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDeviceInformationResponse"))
		{	*type = SOAP_TYPE__tds__GetDeviceInformationResponse;
			return soap_in__tds__GetDeviceInformationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetDeviceInformation"))
		{	*type = SOAP_TYPE__tds__GetDeviceInformation;
			return soap_in__tds__GetDeviceInformation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetServiceCapabilitiesResponse"))
		{	*type = SOAP_TYPE__tds__GetServiceCapabilitiesResponse;
			return soap_in__tds__GetServiceCapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetServiceCapabilities"))
		{	*type = SOAP_TYPE__tds__GetServiceCapabilities;
			return soap_in__tds__GetServiceCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetServicesResponse"))
		{	*type = SOAP_TYPE__tds__GetServicesResponse;
			return soap_in__tds__GetServicesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tds:GetServices"))
		{	*type = SOAP_TYPE__tds__GetServices;
			return soap_in__tds__GetServices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	*type = SOAP_TYPE__xml__lang;
			return soap_in__xml__lang(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xop:Include"))
		{	*type = SOAP_TYPE__xop__Include;
			return soap_in__xop__Include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_tt__IANA_IfTypes:
		return soap_out_tt__IANA_IfTypes(soap, tag, id, (const int *)ptr, "tt:IANA-IfTypes");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, "");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_tt__RelayMode:
		return soap_out_tt__RelayMode(soap, tag, id, (const enum tt__RelayMode *)ptr, "tt:RelayMode");
	case SOAP_TYPE_tt__RelayIdleState:
		return soap_out_tt__RelayIdleState(soap, tag, id, (const enum tt__RelayIdleState *)ptr, "tt:RelayIdleState");
	case SOAP_TYPE_tt__RelayLogicalState:
		return soap_out_tt__RelayLogicalState(soap, tag, id, (const enum tt__RelayLogicalState *)ptr, "tt:RelayLogicalState");
	case SOAP_TYPE_tt__UserLevel:
		return soap_out_tt__UserLevel(soap, tag, id, (const enum tt__UserLevel *)ptr, "tt:UserLevel");
	case SOAP_TYPE_tt__SetDateTimeType:
		return soap_out_tt__SetDateTimeType(soap, tag, id, (const enum tt__SetDateTimeType *)ptr, "tt:SetDateTimeType");
	case SOAP_TYPE_tt__FactoryDefaultType:
		return soap_out_tt__FactoryDefaultType(soap, tag, id, (const enum tt__FactoryDefaultType *)ptr, "tt:FactoryDefaultType");
	case SOAP_TYPE_tt__SystemLogType:
		return soap_out_tt__SystemLogType(soap, tag, id, (const enum tt__SystemLogType *)ptr, "tt:SystemLogType");
	case SOAP_TYPE_tt__CapabilityCategory:
		return soap_out_tt__CapabilityCategory(soap, tag, id, (const enum tt__CapabilityCategory *)ptr, "tt:CapabilityCategory");
	case SOAP_TYPE_tt__Dot11AuthAndMangementSuite:
		return soap_out_tt__Dot11AuthAndMangementSuite(soap, tag, id, (const enum tt__Dot11AuthAndMangementSuite *)ptr, "tt:Dot11AuthAndMangementSuite");
	case SOAP_TYPE_tt__Dot11SignalStrength:
		return soap_out_tt__Dot11SignalStrength(soap, tag, id, (const enum tt__Dot11SignalStrength *)ptr, "tt:Dot11SignalStrength");
	case SOAP_TYPE_tt__Dot11Cipher:
		return soap_out_tt__Dot11Cipher(soap, tag, id, (const enum tt__Dot11Cipher *)ptr, "tt:Dot11Cipher");
	case SOAP_TYPE_tt__Dot11SecurityMode:
		return soap_out_tt__Dot11SecurityMode(soap, tag, id, (const enum tt__Dot11SecurityMode *)ptr, "tt:Dot11SecurityMode");
	case SOAP_TYPE_tt__Dot11StationMode:
		return soap_out_tt__Dot11StationMode(soap, tag, id, (const enum tt__Dot11StationMode *)ptr, "tt:Dot11StationMode");
	case SOAP_TYPE_tt__DynamicDNSType:
		return soap_out_tt__DynamicDNSType(soap, tag, id, (const enum tt__DynamicDNSType *)ptr, "tt:DynamicDNSType");
	case SOAP_TYPE_tt__IPAddressFilterType:
		return soap_out_tt__IPAddressFilterType(soap, tag, id, (const enum tt__IPAddressFilterType *)ptr, "tt:IPAddressFilterType");
	case SOAP_TYPE_tt__IPType:
		return soap_out_tt__IPType(soap, tag, id, (const enum tt__IPType *)ptr, "tt:IPType");
	case SOAP_TYPE_tt__NetworkHostType:
		return soap_out_tt__NetworkHostType(soap, tag, id, (const enum tt__NetworkHostType *)ptr, "tt:NetworkHostType");
	case SOAP_TYPE_tt__NetworkProtocolType:
		return soap_out_tt__NetworkProtocolType(soap, tag, id, (const enum tt__NetworkProtocolType *)ptr, "tt:NetworkProtocolType");
	case SOAP_TYPE_tt__IPv6DHCPConfiguration:
		return soap_out_tt__IPv6DHCPConfiguration(soap, tag, id, (const enum tt__IPv6DHCPConfiguration *)ptr, "tt:IPv6DHCPConfiguration");
	case SOAP_TYPE_tt__Duplex:
		return soap_out_tt__Duplex(soap, tag, id, (const enum tt__Duplex *)ptr, "tt:Duplex");
	case SOAP_TYPE_tt__DiscoveryMode:
		return soap_out_tt__DiscoveryMode(soap, tag, id, (const enum tt__DiscoveryMode *)ptr, "tt:DiscoveryMode");
	case SOAP_TYPE_tt__ScopeDefinition:
		return soap_out_tt__ScopeDefinition(soap, tag, id, (const enum tt__ScopeDefinition *)ptr, "tt:ScopeDefinition");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE__tds__GetSystemUrisResponse_Extension:
		return ((_tds__GetSystemUrisResponse_Extension *)ptr)->soap_out(soap, "tds:GetSystemUrisResponse-Extension", id, "");
	case SOAP_TYPE__tds__StorageConfigurationData_Extension:
		return ((_tds__StorageConfigurationData_Extension *)ptr)->soap_out(soap, "tds:StorageConfigurationData-Extension", id, "");
	case SOAP_TYPE__tds__UserCredential_Extension:
		return ((_tds__UserCredential_Extension *)ptr)->soap_out(soap, "tds:UserCredential-Extension", id, "");
	case SOAP_TYPE__tds__Service_Capabilities:
		return ((_tds__Service_Capabilities *)ptr)->soap_out(soap, "tds:Service-Capabilities", id, "");
	case SOAP_TYPE_tt__ReferenceToken:
		return soap_out_tt__ReferenceToken(soap, tag, id, (const std::string *)ptr, "tt:ReferenceToken");
	case SOAP_TYPE_tt__AuxiliaryData:
		return soap_out_tt__AuxiliaryData(soap, tag, id, (const std::string *)ptr, "tt:AuxiliaryData");
	case SOAP_TYPE_tt__Dot11PSKPassphrase:
		return soap_out_tt__Dot11PSKPassphrase(soap, tag, id, (const std::string *)ptr, "tt:Dot11PSKPassphrase");
	case SOAP_TYPE_tt__Dot11PSK:
		return soap_out_tt__Dot11PSK(soap, tag, id, (const xsd__hexBinary *)ptr, "tt:Dot11PSK");
	case SOAP_TYPE_tt__Dot11SSIDType:
		return soap_out_tt__Dot11SSIDType(soap, tag, id, (const xsd__hexBinary *)ptr, "tt:Dot11SSIDType");
	case SOAP_TYPE_tt__DNSName:
		return soap_out_tt__DNSName(soap, tag, id, (const std::string *)ptr, "tt:DNSName");
	case SOAP_TYPE_tt__HwAddress:
		return soap_out_tt__HwAddress(soap, tag, id, (const std::string *)ptr, "tt:HwAddress");
	case SOAP_TYPE_tt__IPv6Address:
		return soap_out_tt__IPv6Address(soap, tag, id, (const std::string *)ptr, "tt:IPv6Address");
	case SOAP_TYPE_tt__IPv4Address:
		return soap_out_tt__IPv4Address(soap, tag, id, (const std::string *)ptr, "tt:IPv4Address");
	case SOAP_TYPE_tt__NetworkInterfaceConfigPriority:
		return soap_out_tt__NetworkInterfaceConfigPriority(soap, tag, id, (const std::string *)ptr, "tt:NetworkInterfaceConfigPriority");
	case SOAP_TYPE_tt__Name:
		return soap_out_tt__Name(soap, tag, id, (const std::string *)ptr, "tt:Name");
	case SOAP_TYPE_tt__StringList:
		return soap_out_tt__StringList(soap, tag, id, (const std::string *)ptr, "tt:StringList");
	case SOAP_TYPE_tt__StringAttrList:
		return soap_out_tt__StringAttrList(soap, tag, id, (const std::string *)ptr, "tt:StringAttrList");
	case SOAP_TYPE_tt__IntList:
		return soap_out_tt__IntList(soap, tag, id, (const std::string *)ptr, "tt:IntList");
	case SOAP_TYPE_tt__LocationEntity:
		return ((tt__LocationEntity *)ptr)->soap_out(soap, tag, id, "tt:LocationEntity");
	case SOAP_TYPE_tt__LocalOrientation:
		return ((tt__LocalOrientation *)ptr)->soap_out(soap, tag, id, "tt:LocalOrientation");
	case SOAP_TYPE_tt__LocalLocation:
		return ((tt__LocalLocation *)ptr)->soap_out(soap, tag, id, "tt:LocalLocation");
	case SOAP_TYPE_tt__GeoOrientation:
		return ((tt__GeoOrientation *)ptr)->soap_out(soap, tag, id, "tt:GeoOrientation");
	case SOAP_TYPE_tt__GeoLocation:
		return ((tt__GeoLocation *)ptr)->soap_out(soap, tag, id, "tt:GeoLocation");
	case SOAP_TYPE_tt__IntRange:
		return ((tt__IntRange *)ptr)->soap_out(soap, tag, id, "tt:IntRange");
	case SOAP_TYPE_tt__DateTimeRange:
		return ((tt__DateTimeRange *)ptr)->soap_out(soap, tag, id, "tt:DateTimeRange");
	case SOAP_TYPE_tt__RelayOutput:
		return ((tt__RelayOutput *)ptr)->soap_out(soap, tag, id, "tt:RelayOutput");
	case SOAP_TYPE_tt__RelayOutputSettings:
		return ((tt__RelayOutputSettings *)ptr)->soap_out(soap, tag, id, "tt:RelayOutputSettings");
	case SOAP_TYPE_tt__TLSConfiguration:
		return ((tt__TLSConfiguration *)ptr)->soap_out(soap, tag, id, "tt:TLSConfiguration");
	case SOAP_TYPE_tt__EapMethodExtension:
		return ((tt__EapMethodExtension *)ptr)->soap_out(soap, tag, id, "tt:EapMethodExtension");
	case SOAP_TYPE_tt__EAPMethodConfiguration:
		return ((tt__EAPMethodConfiguration *)ptr)->soap_out(soap, tag, id, "tt:EAPMethodConfiguration");
	case SOAP_TYPE_tt__Dot1XConfigurationExtension:
		return ((tt__Dot1XConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:Dot1XConfigurationExtension");
	case SOAP_TYPE_tt__Dot1XConfiguration:
		return ((tt__Dot1XConfiguration *)ptr)->soap_out(soap, tag, id, "tt:Dot1XConfiguration");
	case SOAP_TYPE_tt__CertificateInformationExtension:
		return ((tt__CertificateInformationExtension *)ptr)->soap_out(soap, tag, id, "tt:CertificateInformationExtension");
	case SOAP_TYPE_tt__CertificateUsage:
		return ((tt__CertificateUsage *)ptr)->soap_out(soap, tag, id, "tt:CertificateUsage");
	case SOAP_TYPE_tt__CertificateInformation:
		return ((tt__CertificateInformation *)ptr)->soap_out(soap, tag, id, "tt:CertificateInformation");
	case SOAP_TYPE_tt__CertificateWithPrivateKey:
		return ((tt__CertificateWithPrivateKey *)ptr)->soap_out(soap, tag, id, "tt:CertificateWithPrivateKey");
	case SOAP_TYPE_tt__CertificateStatus:
		return ((tt__CertificateStatus *)ptr)->soap_out(soap, tag, id, "tt:CertificateStatus");
	case SOAP_TYPE_tt__Certificate:
		return ((tt__Certificate *)ptr)->soap_out(soap, tag, id, "tt:Certificate");
	case SOAP_TYPE_tt__UserExtension:
		return ((tt__UserExtension *)ptr)->soap_out(soap, tag, id, "tt:UserExtension");
	case SOAP_TYPE_tt__User:
		return ((tt__User *)ptr)->soap_out(soap, tag, id, "tt:User");
	case SOAP_TYPE_tt__RemoteUser:
		return ((tt__RemoteUser *)ptr)->soap_out(soap, tag, id, "tt:RemoteUser");
	case SOAP_TYPE_tt__TimeZone:
		return ((tt__TimeZone *)ptr)->soap_out(soap, tag, id, "tt:TimeZone");
	case SOAP_TYPE_tt__Time:
		return ((tt__Time *)ptr)->soap_out(soap, tag, id, "tt:Time");
	case SOAP_TYPE_tt__Date:
		return ((tt__Date *)ptr)->soap_out(soap, tag, id, "tt:Date");
	case SOAP_TYPE_tt__DateTime:
		return ((tt__DateTime *)ptr)->soap_out(soap, tag, id, "tt:DateTime");
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		return ((tt__SystemDateTimeExtension *)ptr)->soap_out(soap, tag, id, "tt:SystemDateTimeExtension");
	case SOAP_TYPE_tt__SystemDateTime:
		return ((tt__SystemDateTime *)ptr)->soap_out(soap, tag, id, "tt:SystemDateTime");
	case SOAP_TYPE_tt__SystemLogUri:
		return ((tt__SystemLogUri *)ptr)->soap_out(soap, tag, id, "tt:SystemLogUri");
	case SOAP_TYPE_tt__SystemLogUriList:
		return ((tt__SystemLogUriList *)ptr)->soap_out(soap, tag, id, "tt:SystemLogUriList");
	case SOAP_TYPE_tt__BackupFile:
		return ((tt__BackupFile *)ptr)->soap_out(soap, tag, id, "tt:BackupFile");
	case SOAP_TYPE_tt__AttachmentData:
		return ((tt__AttachmentData *)ptr)->soap_out(soap, tag, id, "tt:AttachmentData");
	case SOAP_TYPE_tt__BinaryData:
		return ((tt__BinaryData *)ptr)->soap_out(soap, tag, id, "tt:BinaryData");
	case SOAP_TYPE_tt__SupportInformation:
		return ((tt__SupportInformation *)ptr)->soap_out(soap, tag, id, "tt:SupportInformation");
	case SOAP_TYPE_tt__SystemLog:
		return ((tt__SystemLog *)ptr)->soap_out(soap, tag, id, "tt:SystemLog");
	case SOAP_TYPE_tt__AnalyticsDeviceExtension:
		return ((tt__AnalyticsDeviceExtension *)ptr)->soap_out(soap, tag, id, "tt:AnalyticsDeviceExtension");
	case SOAP_TYPE_tt__AnalyticsDeviceCapabilities:
		return ((tt__AnalyticsDeviceCapabilities *)ptr)->soap_out(soap, tag, id, "tt:AnalyticsDeviceCapabilities");
	case SOAP_TYPE_tt__ReceiverCapabilities:
		return ((tt__ReceiverCapabilities *)ptr)->soap_out(soap, tag, id, "tt:ReceiverCapabilities");
	case SOAP_TYPE_tt__ReplayCapabilities:
		return ((tt__ReplayCapabilities *)ptr)->soap_out(soap, tag, id, "tt:ReplayCapabilities");
	case SOAP_TYPE_tt__SearchCapabilities:
		return ((tt__SearchCapabilities *)ptr)->soap_out(soap, tag, id, "tt:SearchCapabilities");
	case SOAP_TYPE_tt__RecordingCapabilities:
		return ((tt__RecordingCapabilities *)ptr)->soap_out(soap, tag, id, "tt:RecordingCapabilities");
	case SOAP_TYPE_tt__DisplayCapabilities:
		return ((tt__DisplayCapabilities *)ptr)->soap_out(soap, tag, id, "tt:DisplayCapabilities");
	case SOAP_TYPE_tt__DeviceIOCapabilities:
		return ((tt__DeviceIOCapabilities *)ptr)->soap_out(soap, tag, id, "tt:DeviceIOCapabilities");
	case SOAP_TYPE_tt__PTZCapabilities:
		return ((tt__PTZCapabilities *)ptr)->soap_out(soap, tag, id, "tt:PTZCapabilities");
	case SOAP_TYPE_tt__ImagingCapabilities:
		return ((tt__ImagingCapabilities *)ptr)->soap_out(soap, tag, id, "tt:ImagingCapabilities");
	case SOAP_TYPE_tt__OnvifVersion:
		return ((tt__OnvifVersion *)ptr)->soap_out(soap, tag, id, "tt:OnvifVersion");
	case SOAP_TYPE_tt__SystemCapabilitiesExtension2:
		return ((tt__SystemCapabilitiesExtension2 *)ptr)->soap_out(soap, tag, id, "tt:SystemCapabilitiesExtension2");
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		return ((tt__SystemCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:SystemCapabilitiesExtension");
	case SOAP_TYPE_tt__SystemCapabilities:
		return ((tt__SystemCapabilities *)ptr)->soap_out(soap, tag, id, "tt:SystemCapabilities");
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension2:
		return ((tt__SecurityCapabilitiesExtension2 *)ptr)->soap_out(soap, tag, id, "tt:SecurityCapabilitiesExtension2");
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		return ((tt__SecurityCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:SecurityCapabilitiesExtension");
	case SOAP_TYPE_tt__SecurityCapabilities:
		return ((tt__SecurityCapabilities *)ptr)->soap_out(soap, tag, id, "tt:SecurityCapabilities");
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension2:
		return ((tt__NetworkCapabilitiesExtension2 *)ptr)->soap_out(soap, tag, id, "tt:NetworkCapabilitiesExtension2");
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		return ((tt__NetworkCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkCapabilitiesExtension");
	case SOAP_TYPE_tt__NetworkCapabilities:
		return ((tt__NetworkCapabilities *)ptr)->soap_out(soap, tag, id, "tt:NetworkCapabilities");
	case SOAP_TYPE_tt__ProfileCapabilities:
		return ((tt__ProfileCapabilities *)ptr)->soap_out(soap, tag, id, "tt:ProfileCapabilities");
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		return ((tt__RealTimeStreamingCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		return ((tt__RealTimeStreamingCapabilities *)ptr)->soap_out(soap, tag, id, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		return ((tt__MediaCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_tt__MediaCapabilities:
		return ((tt__MediaCapabilities *)ptr)->soap_out(soap, tag, id, "tt:MediaCapabilities");
	case SOAP_TYPE_tt__IOCapabilitiesExtension2:
		return ((tt__IOCapabilitiesExtension2 *)ptr)->soap_out(soap, tag, id, "tt:IOCapabilitiesExtension2");
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		return ((tt__IOCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:IOCapabilitiesExtension");
	case SOAP_TYPE_tt__IOCapabilities:
		return ((tt__IOCapabilities *)ptr)->soap_out(soap, tag, id, "tt:IOCapabilities");
	case SOAP_TYPE_tt__EventCapabilities:
		return ((tt__EventCapabilities *)ptr)->soap_out(soap, tag, id, "tt:EventCapabilities");
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		return ((tt__DeviceCapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:DeviceCapabilitiesExtension");
	case SOAP_TYPE_tt__DeviceCapabilities:
		return ((tt__DeviceCapabilities *)ptr)->soap_out(soap, tag, id, "tt:DeviceCapabilities");
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		return ((tt__AnalyticsCapabilities *)ptr)->soap_out(soap, tag, id, "tt:AnalyticsCapabilities");
	case SOAP_TYPE_tt__CapabilitiesExtension2:
		return ((tt__CapabilitiesExtension2 *)ptr)->soap_out(soap, tag, id, "tt:CapabilitiesExtension2");
	case SOAP_TYPE_tt__CapabilitiesExtension:
		return ((tt__CapabilitiesExtension *)ptr)->soap_out(soap, tag, id, "tt:CapabilitiesExtension");
	case SOAP_TYPE_tt__Capabilities:
		return ((tt__Capabilities *)ptr)->soap_out(soap, tag, id, "tt:Capabilities");
	case SOAP_TYPE_tt__Dot11AvailableNetworksExtension:
		return ((tt__Dot11AvailableNetworksExtension *)ptr)->soap_out(soap, tag, id, "tt:Dot11AvailableNetworksExtension");
	case SOAP_TYPE_tt__Dot11AvailableNetworks:
		return ((tt__Dot11AvailableNetworks *)ptr)->soap_out(soap, tag, id, "tt:Dot11AvailableNetworks");
	case SOAP_TYPE_tt__Dot11Status:
		return ((tt__Dot11Status *)ptr)->soap_out(soap, tag, id, "tt:Dot11Status");
	case SOAP_TYPE_tt__Dot11Capabilities:
		return ((tt__Dot11Capabilities *)ptr)->soap_out(soap, tag, id, "tt:Dot11Capabilities");
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2:
		return ((tt__NetworkInterfaceSetConfigurationExtension2 *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceSetConfigurationExtension2");
	case SOAP_TYPE_tt__Dot11PSKSetExtension:
		return ((tt__Dot11PSKSetExtension *)ptr)->soap_out(soap, tag, id, "tt:Dot11PSKSetExtension");
	case SOAP_TYPE_tt__Dot11PSKSet:
		return ((tt__Dot11PSKSet *)ptr)->soap_out(soap, tag, id, "tt:Dot11PSKSet");
	case SOAP_TYPE_tt__Dot11SecurityConfigurationExtension:
		return ((tt__Dot11SecurityConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:Dot11SecurityConfigurationExtension");
	case SOAP_TYPE_tt__Dot11SecurityConfiguration:
		return ((tt__Dot11SecurityConfiguration *)ptr)->soap_out(soap, tag, id, "tt:Dot11SecurityConfiguration");
	case SOAP_TYPE_tt__Dot11Configuration:
		return ((tt__Dot11Configuration *)ptr)->soap_out(soap, tag, id, "tt:Dot11Configuration");
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		return ((tt__IPAddressFilterExtension *)ptr)->soap_out(soap, tag, id, "tt:IPAddressFilterExtension");
	case SOAP_TYPE_tt__IPAddressFilter:
		return ((tt__IPAddressFilter *)ptr)->soap_out(soap, tag, id, "tt:IPAddressFilter");
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension2:
		return ((tt__NetworkZeroConfigurationExtension2 *)ptr)->soap_out(soap, tag, id, "tt:NetworkZeroConfigurationExtension2");
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		return ((tt__NetworkZeroConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		return ((tt__NetworkZeroConfiguration *)ptr)->soap_out(soap, tag, id, "tt:NetworkZeroConfiguration");
	case SOAP_TYPE_tt__NetworkGateway:
		return ((tt__NetworkGateway *)ptr)->soap_out(soap, tag, id, "tt:NetworkGateway");
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		return ((tt__IPv4NetworkInterfaceSetConfiguration *)ptr)->soap_out(soap, tag, id, "tt:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		return ((tt__IPv6NetworkInterfaceSetConfiguration *)ptr)->soap_out(soap, tag, id, "tt:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		return ((tt__NetworkInterfaceSetConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		return ((tt__NetworkInterfaceSetConfiguration *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		return ((tt__DynamicDNSInformationExtension *)ptr)->soap_out(soap, tag, id, "tt:DynamicDNSInformationExtension");
	case SOAP_TYPE_tt__DynamicDNSInformation:
		return ((tt__DynamicDNSInformation *)ptr)->soap_out(soap, tag, id, "tt:DynamicDNSInformation");
	case SOAP_TYPE_tt__NTPInformationExtension:
		return ((tt__NTPInformationExtension *)ptr)->soap_out(soap, tag, id, "tt:NTPInformationExtension");
	case SOAP_TYPE_tt__NTPInformation:
		return ((tt__NTPInformation *)ptr)->soap_out(soap, tag, id, "tt:NTPInformation");
	case SOAP_TYPE_tt__DNSInformationExtension:
		return ((tt__DNSInformationExtension *)ptr)->soap_out(soap, tag, id, "tt:DNSInformationExtension");
	case SOAP_TYPE_tt__DNSInformation:
		return ((tt__DNSInformation *)ptr)->soap_out(soap, tag, id, "tt:DNSInformation");
	case SOAP_TYPE_tt__HostnameInformationExtension:
		return ((tt__HostnameInformationExtension *)ptr)->soap_out(soap, tag, id, "tt:HostnameInformationExtension");
	case SOAP_TYPE_tt__HostnameInformation:
		return ((tt__HostnameInformation *)ptr)->soap_out(soap, tag, id, "tt:HostnameInformation");
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		return ((tt__PrefixedIPv6Address *)ptr)->soap_out(soap, tag, id, "tt:PrefixedIPv6Address");
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		return ((tt__PrefixedIPv4Address *)ptr)->soap_out(soap, tag, id, "tt:PrefixedIPv4Address");
	case SOAP_TYPE_tt__IPAddress:
		return ((tt__IPAddress *)ptr)->soap_out(soap, tag, id, "tt:IPAddress");
	case SOAP_TYPE_tt__NetworkHostExtension:
		return ((tt__NetworkHostExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkHostExtension");
	case SOAP_TYPE_tt__NetworkHost:
		return ((tt__NetworkHost *)ptr)->soap_out(soap, tag, id, "tt:NetworkHost");
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		return ((tt__NetworkProtocolExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkProtocolExtension");
	case SOAP_TYPE_tt__NetworkProtocol:
		return ((tt__NetworkProtocol *)ptr)->soap_out(soap, tag, id, "tt:NetworkProtocol");
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		return ((tt__IPv6ConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:IPv6ConfigurationExtension");
	case SOAP_TYPE_tt__IPv6Configuration:
		return ((tt__IPv6Configuration *)ptr)->soap_out(soap, tag, id, "tt:IPv6Configuration");
	case SOAP_TYPE_tt__IPv4Configuration:
		return ((tt__IPv4Configuration *)ptr)->soap_out(soap, tag, id, "tt:IPv4Configuration");
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		return ((tt__IPv4NetworkInterface *)ptr)->soap_out(soap, tag, id, "tt:IPv4NetworkInterface");
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		return ((tt__IPv6NetworkInterface *)ptr)->soap_out(soap, tag, id, "tt:IPv6NetworkInterface");
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		return ((tt__NetworkInterfaceInfo *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceInfo");
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		return ((tt__NetworkInterfaceConnectionSetting *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		return ((tt__NetworkInterfaceLink *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceLink");
	case SOAP_TYPE_tt__NetworkInterfaceExtension2:
		return ((tt__NetworkInterfaceExtension2 *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceExtension2");
	case SOAP_TYPE_tt__Dot3Configuration:
		return ((tt__Dot3Configuration *)ptr)->soap_out(soap, tag, id, "tt:Dot3Configuration");
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		return ((tt__NetworkInterfaceExtension *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterfaceExtension");
	case SOAP_TYPE_tt__NetworkInterface:
		return ((tt__NetworkInterface *)ptr)->soap_out(soap, tag, id, "tt:NetworkInterface");
	case SOAP_TYPE_tt__Scope:
		return ((tt__Scope *)ptr)->soap_out(soap, tag, id, "tt:Scope");
	case SOAP_TYPE_tt__DeviceEntity:
		return ((tt__DeviceEntity *)ptr)->soap_out(soap, tag, id, "tt:DeviceEntity");
	case SOAP_TYPE__tds__DeleteGeoLocationResponse:
		return ((_tds__DeleteGeoLocationResponse *)ptr)->soap_out(soap, "tds:DeleteGeoLocationResponse", id, "");
	case SOAP_TYPE__tds__DeleteGeoLocation:
		return ((_tds__DeleteGeoLocation *)ptr)->soap_out(soap, "tds:DeleteGeoLocation", id, "");
	case SOAP_TYPE__tds__SetGeoLocationResponse:
		return ((_tds__SetGeoLocationResponse *)ptr)->soap_out(soap, "tds:SetGeoLocationResponse", id, "");
	case SOAP_TYPE__tds__SetGeoLocation:
		return ((_tds__SetGeoLocation *)ptr)->soap_out(soap, "tds:SetGeoLocation", id, "");
	case SOAP_TYPE__tds__GetGeoLocationResponse:
		return ((_tds__GetGeoLocationResponse *)ptr)->soap_out(soap, "tds:GetGeoLocationResponse", id, "");
	case SOAP_TYPE__tds__GetGeoLocation:
		return ((_tds__GetGeoLocation *)ptr)->soap_out(soap, "tds:GetGeoLocation", id, "");
	case SOAP_TYPE__tds__DeleteStorageConfigurationResponse:
		return ((_tds__DeleteStorageConfigurationResponse *)ptr)->soap_out(soap, "tds:DeleteStorageConfigurationResponse", id, "");
	case SOAP_TYPE__tds__DeleteStorageConfiguration:
		return ((_tds__DeleteStorageConfiguration *)ptr)->soap_out(soap, "tds:DeleteStorageConfiguration", id, "");
	case SOAP_TYPE__tds__SetStorageConfigurationResponse:
		return ((_tds__SetStorageConfigurationResponse *)ptr)->soap_out(soap, "tds:SetStorageConfigurationResponse", id, "");
	case SOAP_TYPE__tds__SetStorageConfiguration:
		return ((_tds__SetStorageConfiguration *)ptr)->soap_out(soap, "tds:SetStorageConfiguration", id, "");
	case SOAP_TYPE__tds__GetStorageConfigurationResponse:
		return ((_tds__GetStorageConfigurationResponse *)ptr)->soap_out(soap, "tds:GetStorageConfigurationResponse", id, "");
	case SOAP_TYPE__tds__GetStorageConfiguration:
		return ((_tds__GetStorageConfiguration *)ptr)->soap_out(soap, "tds:GetStorageConfiguration", id, "");
	case SOAP_TYPE__tds__CreateStorageConfigurationResponse:
		return ((_tds__CreateStorageConfigurationResponse *)ptr)->soap_out(soap, "tds:CreateStorageConfigurationResponse", id, "");
	case SOAP_TYPE__tds__CreateStorageConfiguration:
		return ((_tds__CreateStorageConfiguration *)ptr)->soap_out(soap, "tds:CreateStorageConfiguration", id, "");
	case SOAP_TYPE__tds__GetStorageConfigurationsResponse:
		return ((_tds__GetStorageConfigurationsResponse *)ptr)->soap_out(soap, "tds:GetStorageConfigurationsResponse", id, "");
	case SOAP_TYPE__tds__GetStorageConfigurations:
		return ((_tds__GetStorageConfigurations *)ptr)->soap_out(soap, "tds:GetStorageConfigurations", id, "");
	case SOAP_TYPE__tds__SetHashingAlgorithmResponse:
		return ((_tds__SetHashingAlgorithmResponse *)ptr)->soap_out(soap, "tds:SetHashingAlgorithmResponse", id, "");
	case SOAP_TYPE__tds__SetHashingAlgorithm:
		return ((_tds__SetHashingAlgorithm *)ptr)->soap_out(soap, "tds:SetHashingAlgorithm", id, "");
	case SOAP_TYPE__tds__StartSystemRestoreResponse:
		return ((_tds__StartSystemRestoreResponse *)ptr)->soap_out(soap, "tds:StartSystemRestoreResponse", id, "");
	case SOAP_TYPE__tds__StartSystemRestore:
		return ((_tds__StartSystemRestore *)ptr)->soap_out(soap, "tds:StartSystemRestore", id, "");
	case SOAP_TYPE__tds__StartFirmwareUpgradeResponse:
		return ((_tds__StartFirmwareUpgradeResponse *)ptr)->soap_out(soap, "tds:StartFirmwareUpgradeResponse", id, "");
	case SOAP_TYPE__tds__StartFirmwareUpgrade:
		return ((_tds__StartFirmwareUpgrade *)ptr)->soap_out(soap, "tds:StartFirmwareUpgrade", id, "");
	case SOAP_TYPE__tds__GetSystemUrisResponse:
		return ((_tds__GetSystemUrisResponse *)ptr)->soap_out(soap, "tds:GetSystemUrisResponse", id, "");
	case SOAP_TYPE__tds__GetSystemUris:
		return ((_tds__GetSystemUris *)ptr)->soap_out(soap, "tds:GetSystemUris", id, "");
	case SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse:
		return ((_tds__ScanAvailableDot11NetworksResponse *)ptr)->soap_out(soap, "tds:ScanAvailableDot11NetworksResponse", id, "");
	case SOAP_TYPE__tds__ScanAvailableDot11Networks:
		return ((_tds__ScanAvailableDot11Networks *)ptr)->soap_out(soap, "tds:ScanAvailableDot11Networks", id, "");
	case SOAP_TYPE__tds__GetDot11StatusResponse:
		return ((_tds__GetDot11StatusResponse *)ptr)->soap_out(soap, "tds:GetDot11StatusResponse", id, "");
	case SOAP_TYPE__tds__GetDot11Status:
		return ((_tds__GetDot11Status *)ptr)->soap_out(soap, "tds:GetDot11Status", id, "");
	case SOAP_TYPE__tds__GetDot11CapabilitiesResponse:
		return ((_tds__GetDot11CapabilitiesResponse *)ptr)->soap_out(soap, "tds:GetDot11CapabilitiesResponse", id, "");
	case SOAP_TYPE__tds__GetDot11Capabilities:
		return ((_tds__GetDot11Capabilities *)ptr)->soap_out(soap, "tds:GetDot11Capabilities", id, "");
	case SOAP_TYPE__tds__SendAuxiliaryCommandResponse:
		return ((_tds__SendAuxiliaryCommandResponse *)ptr)->soap_out(soap, "tds:SendAuxiliaryCommandResponse", id, "");
	case SOAP_TYPE__tds__SendAuxiliaryCommand:
		return ((_tds__SendAuxiliaryCommand *)ptr)->soap_out(soap, "tds:SendAuxiliaryCommand", id, "");
	case SOAP_TYPE__tds__SetRelayOutputStateResponse:
		return ((_tds__SetRelayOutputStateResponse *)ptr)->soap_out(soap, "tds:SetRelayOutputStateResponse", id, "");
	case SOAP_TYPE__tds__SetRelayOutputState:
		return ((_tds__SetRelayOutputState *)ptr)->soap_out(soap, "tds:SetRelayOutputState", id, "");
	case SOAP_TYPE__tds__SetRelayOutputSettingsResponse:
		return ((_tds__SetRelayOutputSettingsResponse *)ptr)->soap_out(soap, "tds:SetRelayOutputSettingsResponse", id, "");
	case SOAP_TYPE__tds__SetRelayOutputSettings:
		return ((_tds__SetRelayOutputSettings *)ptr)->soap_out(soap, "tds:SetRelayOutputSettings", id, "");
	case SOAP_TYPE__tds__GetRelayOutputsResponse:
		return ((_tds__GetRelayOutputsResponse *)ptr)->soap_out(soap, "tds:GetRelayOutputsResponse", id, "");
	case SOAP_TYPE__tds__GetRelayOutputs:
		return ((_tds__GetRelayOutputs *)ptr)->soap_out(soap, "tds:GetRelayOutputs", id, "");
	case SOAP_TYPE__tds__DeleteDot1XConfigurationResponse:
		return ((_tds__DeleteDot1XConfigurationResponse *)ptr)->soap_out(soap, "tds:DeleteDot1XConfigurationResponse", id, "");
	case SOAP_TYPE__tds__DeleteDot1XConfiguration:
		return ((_tds__DeleteDot1XConfiguration *)ptr)->soap_out(soap, "tds:DeleteDot1XConfiguration", id, "");
	case SOAP_TYPE__tds__GetDot1XConfigurationsResponse:
		return ((_tds__GetDot1XConfigurationsResponse *)ptr)->soap_out(soap, "tds:GetDot1XConfigurationsResponse", id, "");
	case SOAP_TYPE__tds__GetDot1XConfigurations:
		return ((_tds__GetDot1XConfigurations *)ptr)->soap_out(soap, "tds:GetDot1XConfigurations", id, "");
	case SOAP_TYPE__tds__GetDot1XConfigurationResponse:
		return ((_tds__GetDot1XConfigurationResponse *)ptr)->soap_out(soap, "tds:GetDot1XConfigurationResponse", id, "");
	case SOAP_TYPE__tds__GetDot1XConfiguration:
		return ((_tds__GetDot1XConfiguration *)ptr)->soap_out(soap, "tds:GetDot1XConfiguration", id, "");
	case SOAP_TYPE__tds__SetDot1XConfigurationResponse:
		return ((_tds__SetDot1XConfigurationResponse *)ptr)->soap_out(soap, "tds:SetDot1XConfigurationResponse", id, "");
	case SOAP_TYPE__tds__SetDot1XConfiguration:
		return ((_tds__SetDot1XConfiguration *)ptr)->soap_out(soap, "tds:SetDot1XConfiguration", id, "");
	case SOAP_TYPE__tds__CreateDot1XConfigurationResponse:
		return ((_tds__CreateDot1XConfigurationResponse *)ptr)->soap_out(soap, "tds:CreateDot1XConfigurationResponse", id, "");
	case SOAP_TYPE__tds__CreateDot1XConfiguration:
		return ((_tds__CreateDot1XConfiguration *)ptr)->soap_out(soap, "tds:CreateDot1XConfiguration", id, "");
	case SOAP_TYPE__tds__LoadCACertificatesResponse:
		return ((_tds__LoadCACertificatesResponse *)ptr)->soap_out(soap, "tds:LoadCACertificatesResponse", id, "");
	case SOAP_TYPE__tds__LoadCACertificates:
		return ((_tds__LoadCACertificates *)ptr)->soap_out(soap, "tds:LoadCACertificates", id, "");
	case SOAP_TYPE__tds__GetCertificateInformationResponse:
		return ((_tds__GetCertificateInformationResponse *)ptr)->soap_out(soap, "tds:GetCertificateInformationResponse", id, "");
	case SOAP_TYPE__tds__GetCertificateInformation:
		return ((_tds__GetCertificateInformation *)ptr)->soap_out(soap, "tds:GetCertificateInformation", id, "");
	case SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse:
		return ((_tds__LoadCertificateWithPrivateKeyResponse *)ptr)->soap_out(soap, "tds:LoadCertificateWithPrivateKeyResponse", id, "");
	case SOAP_TYPE__tds__LoadCertificateWithPrivateKey:
		return ((_tds__LoadCertificateWithPrivateKey *)ptr)->soap_out(soap, "tds:LoadCertificateWithPrivateKey", id, "");
	case SOAP_TYPE__tds__GetCACertificatesResponse:
		return ((_tds__GetCACertificatesResponse *)ptr)->soap_out(soap, "tds:GetCACertificatesResponse", id, "");
	case SOAP_TYPE__tds__GetCACertificates:
		return ((_tds__GetCACertificates *)ptr)->soap_out(soap, "tds:GetCACertificates", id, "");
	case SOAP_TYPE__tds__SetClientCertificateModeResponse:
		return ((_tds__SetClientCertificateModeResponse *)ptr)->soap_out(soap, "tds:SetClientCertificateModeResponse", id, "");
	case SOAP_TYPE__tds__SetClientCertificateMode:
		return ((_tds__SetClientCertificateMode *)ptr)->soap_out(soap, "tds:SetClientCertificateMode", id, "");
	case SOAP_TYPE__tds__GetClientCertificateModeResponse:
		return ((_tds__GetClientCertificateModeResponse *)ptr)->soap_out(soap, "tds:GetClientCertificateModeResponse", id, "");
	case SOAP_TYPE__tds__GetClientCertificateMode:
		return ((_tds__GetClientCertificateMode *)ptr)->soap_out(soap, "tds:GetClientCertificateMode", id, "");
	case SOAP_TYPE__tds__LoadCertificatesResponse:
		return ((_tds__LoadCertificatesResponse *)ptr)->soap_out(soap, "tds:LoadCertificatesResponse", id, "");
	case SOAP_TYPE__tds__LoadCertificates:
		return ((_tds__LoadCertificates *)ptr)->soap_out(soap, "tds:LoadCertificates", id, "");
	case SOAP_TYPE__tds__GetPkcs10RequestResponse:
		return ((_tds__GetPkcs10RequestResponse *)ptr)->soap_out(soap, "tds:GetPkcs10RequestResponse", id, "");
	case SOAP_TYPE__tds__GetPkcs10Request:
		return ((_tds__GetPkcs10Request *)ptr)->soap_out(soap, "tds:GetPkcs10Request", id, "");
	case SOAP_TYPE__tds__DeleteCertificatesResponse:
		return ((_tds__DeleteCertificatesResponse *)ptr)->soap_out(soap, "tds:DeleteCertificatesResponse", id, "");
	case SOAP_TYPE__tds__DeleteCertificates:
		return ((_tds__DeleteCertificates *)ptr)->soap_out(soap, "tds:DeleteCertificates", id, "");
	case SOAP_TYPE__tds__SetCertificatesStatusResponse:
		return ((_tds__SetCertificatesStatusResponse *)ptr)->soap_out(soap, "tds:SetCertificatesStatusResponse", id, "");
	case SOAP_TYPE__tds__SetCertificatesStatus:
		return ((_tds__SetCertificatesStatus *)ptr)->soap_out(soap, "tds:SetCertificatesStatus", id, "");
	case SOAP_TYPE__tds__GetCertificatesStatusResponse:
		return ((_tds__GetCertificatesStatusResponse *)ptr)->soap_out(soap, "tds:GetCertificatesStatusResponse", id, "");
	case SOAP_TYPE__tds__GetCertificatesStatus:
		return ((_tds__GetCertificatesStatus *)ptr)->soap_out(soap, "tds:GetCertificatesStatus", id, "");
	case SOAP_TYPE__tds__GetCertificatesResponse:
		return ((_tds__GetCertificatesResponse *)ptr)->soap_out(soap, "tds:GetCertificatesResponse", id, "");
	case SOAP_TYPE__tds__GetCertificates:
		return ((_tds__GetCertificates *)ptr)->soap_out(soap, "tds:GetCertificates", id, "");
	case SOAP_TYPE__tds__CreateCertificateResponse:
		return ((_tds__CreateCertificateResponse *)ptr)->soap_out(soap, "tds:CreateCertificateResponse", id, "");
	case SOAP_TYPE__tds__CreateCertificate:
		return ((_tds__CreateCertificate *)ptr)->soap_out(soap, "tds:CreateCertificate", id, "");
	case SOAP_TYPE__tds__SetAccessPolicyResponse:
		return ((_tds__SetAccessPolicyResponse *)ptr)->soap_out(soap, "tds:SetAccessPolicyResponse", id, "");
	case SOAP_TYPE__tds__SetAccessPolicy:
		return ((_tds__SetAccessPolicy *)ptr)->soap_out(soap, "tds:SetAccessPolicy", id, "");
	case SOAP_TYPE__tds__GetAccessPolicyResponse:
		return ((_tds__GetAccessPolicyResponse *)ptr)->soap_out(soap, "tds:GetAccessPolicyResponse", id, "");
	case SOAP_TYPE__tds__GetAccessPolicy:
		return ((_tds__GetAccessPolicy *)ptr)->soap_out(soap, "tds:GetAccessPolicy", id, "");
	case SOAP_TYPE__tds__RemoveIPAddressFilterResponse:
		return ((_tds__RemoveIPAddressFilterResponse *)ptr)->soap_out(soap, "tds:RemoveIPAddressFilterResponse", id, "");
	case SOAP_TYPE__tds__RemoveIPAddressFilter:
		return ((_tds__RemoveIPAddressFilter *)ptr)->soap_out(soap, "tds:RemoveIPAddressFilter", id, "");
	case SOAP_TYPE__tds__AddIPAddressFilterResponse:
		return ((_tds__AddIPAddressFilterResponse *)ptr)->soap_out(soap, "tds:AddIPAddressFilterResponse", id, "");
	case SOAP_TYPE__tds__AddIPAddressFilter:
		return ((_tds__AddIPAddressFilter *)ptr)->soap_out(soap, "tds:AddIPAddressFilter", id, "");
	case SOAP_TYPE__tds__SetIPAddressFilterResponse:
		return ((_tds__SetIPAddressFilterResponse *)ptr)->soap_out(soap, "tds:SetIPAddressFilterResponse", id, "");
	case SOAP_TYPE__tds__SetIPAddressFilter:
		return ((_tds__SetIPAddressFilter *)ptr)->soap_out(soap, "tds:SetIPAddressFilter", id, "");
	case SOAP_TYPE__tds__GetIPAddressFilterResponse:
		return ((_tds__GetIPAddressFilterResponse *)ptr)->soap_out(soap, "tds:GetIPAddressFilterResponse", id, "");
	case SOAP_TYPE__tds__GetIPAddressFilter:
		return ((_tds__GetIPAddressFilter *)ptr)->soap_out(soap, "tds:GetIPAddressFilter", id, "");
	case SOAP_TYPE__tds__SetZeroConfigurationResponse:
		return ((_tds__SetZeroConfigurationResponse *)ptr)->soap_out(soap, "tds:SetZeroConfigurationResponse", id, "");
	case SOAP_TYPE__tds__SetZeroConfiguration:
		return ((_tds__SetZeroConfiguration *)ptr)->soap_out(soap, "tds:SetZeroConfiguration", id, "");
	case SOAP_TYPE__tds__GetZeroConfigurationResponse:
		return ((_tds__GetZeroConfigurationResponse *)ptr)->soap_out(soap, "tds:GetZeroConfigurationResponse", id, "");
	case SOAP_TYPE__tds__GetZeroConfiguration:
		return ((_tds__GetZeroConfiguration *)ptr)->soap_out(soap, "tds:GetZeroConfiguration", id, "");
	case SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse:
		return ((_tds__SetNetworkDefaultGatewayResponse *)ptr)->soap_out(soap, "tds:SetNetworkDefaultGatewayResponse", id, "");
	case SOAP_TYPE__tds__SetNetworkDefaultGateway:
		return ((_tds__SetNetworkDefaultGateway *)ptr)->soap_out(soap, "tds:SetNetworkDefaultGateway", id, "");
	case SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse:
		return ((_tds__GetNetworkDefaultGatewayResponse *)ptr)->soap_out(soap, "tds:GetNetworkDefaultGatewayResponse", id, "");
	case SOAP_TYPE__tds__GetNetworkDefaultGateway:
		return ((_tds__GetNetworkDefaultGateway *)ptr)->soap_out(soap, "tds:GetNetworkDefaultGateway", id, "");
	case SOAP_TYPE__tds__SetNetworkProtocolsResponse:
		return ((_tds__SetNetworkProtocolsResponse *)ptr)->soap_out(soap, "tds:SetNetworkProtocolsResponse", id, "");
	case SOAP_TYPE__tds__SetNetworkProtocols:
		return ((_tds__SetNetworkProtocols *)ptr)->soap_out(soap, "tds:SetNetworkProtocols", id, "");
	case SOAP_TYPE__tds__GetNetworkProtocolsResponse:
		return ((_tds__GetNetworkProtocolsResponse *)ptr)->soap_out(soap, "tds:GetNetworkProtocolsResponse", id, "");
	case SOAP_TYPE__tds__GetNetworkProtocols:
		return ((_tds__GetNetworkProtocols *)ptr)->soap_out(soap, "tds:GetNetworkProtocols", id, "");
	case SOAP_TYPE__tds__SetNetworkInterfacesResponse:
		return ((_tds__SetNetworkInterfacesResponse *)ptr)->soap_out(soap, "tds:SetNetworkInterfacesResponse", id, "");
	case SOAP_TYPE__tds__SetNetworkInterfaces:
		return ((_tds__SetNetworkInterfaces *)ptr)->soap_out(soap, "tds:SetNetworkInterfaces", id, "");
	case SOAP_TYPE__tds__GetNetworkInterfacesResponse:
		return ((_tds__GetNetworkInterfacesResponse *)ptr)->soap_out(soap, "tds:GetNetworkInterfacesResponse", id, "");
	case SOAP_TYPE__tds__GetNetworkInterfaces:
		return ((_tds__GetNetworkInterfaces *)ptr)->soap_out(soap, "tds:GetNetworkInterfaces", id, "");
	case SOAP_TYPE__tds__SetDynamicDNSResponse:
		return ((_tds__SetDynamicDNSResponse *)ptr)->soap_out(soap, "tds:SetDynamicDNSResponse", id, "");
	case SOAP_TYPE__tds__SetDynamicDNS:
		return ((_tds__SetDynamicDNS *)ptr)->soap_out(soap, "tds:SetDynamicDNS", id, "");
	case SOAP_TYPE__tds__GetDynamicDNSResponse:
		return ((_tds__GetDynamicDNSResponse *)ptr)->soap_out(soap, "tds:GetDynamicDNSResponse", id, "");
	case SOAP_TYPE__tds__GetDynamicDNS:
		return ((_tds__GetDynamicDNS *)ptr)->soap_out(soap, "tds:GetDynamicDNS", id, "");
	case SOAP_TYPE__tds__SetNTPResponse:
		return ((_tds__SetNTPResponse *)ptr)->soap_out(soap, "tds:SetNTPResponse", id, "");
	case SOAP_TYPE__tds__SetNTP:
		return ((_tds__SetNTP *)ptr)->soap_out(soap, "tds:SetNTP", id, "");
	case SOAP_TYPE__tds__GetNTPResponse:
		return ((_tds__GetNTPResponse *)ptr)->soap_out(soap, "tds:GetNTPResponse", id, "");
	case SOAP_TYPE__tds__GetNTP:
		return ((_tds__GetNTP *)ptr)->soap_out(soap, "tds:GetNTP", id, "");
	case SOAP_TYPE__tds__SetDNSResponse:
		return ((_tds__SetDNSResponse *)ptr)->soap_out(soap, "tds:SetDNSResponse", id, "");
	case SOAP_TYPE__tds__SetDNS:
		return ((_tds__SetDNS *)ptr)->soap_out(soap, "tds:SetDNS", id, "");
	case SOAP_TYPE__tds__GetDNSResponse:
		return ((_tds__GetDNSResponse *)ptr)->soap_out(soap, "tds:GetDNSResponse", id, "");
	case SOAP_TYPE__tds__GetDNS:
		return ((_tds__GetDNS *)ptr)->soap_out(soap, "tds:GetDNS", id, "");
	case SOAP_TYPE__tds__SetHostnameFromDHCPResponse:
		return ((_tds__SetHostnameFromDHCPResponse *)ptr)->soap_out(soap, "tds:SetHostnameFromDHCPResponse", id, "");
	case SOAP_TYPE__tds__SetHostnameFromDHCP:
		return ((_tds__SetHostnameFromDHCP *)ptr)->soap_out(soap, "tds:SetHostnameFromDHCP", id, "");
	case SOAP_TYPE__tds__SetHostnameResponse:
		return ((_tds__SetHostnameResponse *)ptr)->soap_out(soap, "tds:SetHostnameResponse", id, "");
	case SOAP_TYPE__tds__SetHostname:
		return ((_tds__SetHostname *)ptr)->soap_out(soap, "tds:SetHostname", id, "");
	case SOAP_TYPE__tds__GetHostnameResponse:
		return ((_tds__GetHostnameResponse *)ptr)->soap_out(soap, "tds:GetHostnameResponse", id, "");
	case SOAP_TYPE__tds__GetHostname:
		return ((_tds__GetHostname *)ptr)->soap_out(soap, "tds:GetHostname", id, "");
	case SOAP_TYPE__tds__GetCapabilitiesResponse:
		return ((_tds__GetCapabilitiesResponse *)ptr)->soap_out(soap, "tds:GetCapabilitiesResponse", id, "");
	case SOAP_TYPE__tds__GetCapabilities:
		return ((_tds__GetCapabilities *)ptr)->soap_out(soap, "tds:GetCapabilities", id, "");
	case SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse:
		return ((_tds__SetAuthFailureWarningConfigurationResponse *)ptr)->soap_out(soap, "tds:SetAuthFailureWarningConfigurationResponse", id, "");
	case SOAP_TYPE__tds__SetAuthFailureWarningConfiguration:
		return ((_tds__SetAuthFailureWarningConfiguration *)ptr)->soap_out(soap, "tds:SetAuthFailureWarningConfiguration", id, "");
	case SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse:
		return ((_tds__GetAuthFailureWarningConfigurationResponse *)ptr)->soap_out(soap, "tds:GetAuthFailureWarningConfigurationResponse", id, "");
	case SOAP_TYPE__tds__GetAuthFailureWarningConfiguration:
		return ((_tds__GetAuthFailureWarningConfiguration *)ptr)->soap_out(soap, "tds:GetAuthFailureWarningConfiguration", id, "");
	case SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse:
		return ((_tds__GetAuthFailureWarningOptionsResponse *)ptr)->soap_out(soap, "tds:GetAuthFailureWarningOptionsResponse", id, "");
	case SOAP_TYPE__tds__GetAuthFailureWarningOptions:
		return ((_tds__GetAuthFailureWarningOptions *)ptr)->soap_out(soap, "tds:GetAuthFailureWarningOptions", id, "");
	case SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse:
		return ((_tds__SetPasswordHistoryConfigurationResponse *)ptr)->soap_out(soap, "tds:SetPasswordHistoryConfigurationResponse", id, "");
	case SOAP_TYPE__tds__SetPasswordHistoryConfiguration:
		return ((_tds__SetPasswordHistoryConfiguration *)ptr)->soap_out(soap, "tds:SetPasswordHistoryConfiguration", id, "");
	case SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse:
		return ((_tds__GetPasswordHistoryConfigurationResponse *)ptr)->soap_out(soap, "tds:GetPasswordHistoryConfigurationResponse", id, "");
	case SOAP_TYPE__tds__GetPasswordHistoryConfiguration:
		return ((_tds__GetPasswordHistoryConfiguration *)ptr)->soap_out(soap, "tds:GetPasswordHistoryConfiguration", id, "");
	case SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse:
		return ((_tds__SetPasswordComplexityConfigurationResponse *)ptr)->soap_out(soap, "tds:SetPasswordComplexityConfigurationResponse", id, "");
	case SOAP_TYPE__tds__SetPasswordComplexityConfiguration:
		return ((_tds__SetPasswordComplexityConfiguration *)ptr)->soap_out(soap, "tds:SetPasswordComplexityConfiguration", id, "");
	case SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse:
		return ((_tds__GetPasswordComplexityConfigurationResponse *)ptr)->soap_out(soap, "tds:GetPasswordComplexityConfigurationResponse", id, "");
	case SOAP_TYPE__tds__GetPasswordComplexityConfiguration:
		return ((_tds__GetPasswordComplexityConfiguration *)ptr)->soap_out(soap, "tds:GetPasswordComplexityConfiguration", id, "");
	case SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse:
		return ((_tds__GetPasswordComplexityOptionsResponse *)ptr)->soap_out(soap, "tds:GetPasswordComplexityOptionsResponse", id, "");
	case SOAP_TYPE__tds__GetPasswordComplexityOptions:
		return ((_tds__GetPasswordComplexityOptions *)ptr)->soap_out(soap, "tds:GetPasswordComplexityOptions", id, "");
	case SOAP_TYPE__tds__GetWsdlUrlResponse:
		return ((_tds__GetWsdlUrlResponse *)ptr)->soap_out(soap, "tds:GetWsdlUrlResponse", id, "");
	case SOAP_TYPE__tds__GetWsdlUrl:
		return ((_tds__GetWsdlUrl *)ptr)->soap_out(soap, "tds:GetWsdlUrl", id, "");
	case SOAP_TYPE__tds__SetUserResponse:
		return ((_tds__SetUserResponse *)ptr)->soap_out(soap, "tds:SetUserResponse", id, "");
	case SOAP_TYPE__tds__SetUser:
		return ((_tds__SetUser *)ptr)->soap_out(soap, "tds:SetUser", id, "");
	case SOAP_TYPE__tds__DeleteUsersResponse:
		return ((_tds__DeleteUsersResponse *)ptr)->soap_out(soap, "tds:DeleteUsersResponse", id, "");
	case SOAP_TYPE__tds__DeleteUsers:
		return ((_tds__DeleteUsers *)ptr)->soap_out(soap, "tds:DeleteUsers", id, "");
	case SOAP_TYPE__tds__CreateUsersResponse:
		return ((_tds__CreateUsersResponse *)ptr)->soap_out(soap, "tds:CreateUsersResponse", id, "");
	case SOAP_TYPE__tds__CreateUsers:
		return ((_tds__CreateUsers *)ptr)->soap_out(soap, "tds:CreateUsers", id, "");
	case SOAP_TYPE__tds__GetUsersResponse:
		return ((_tds__GetUsersResponse *)ptr)->soap_out(soap, "tds:GetUsersResponse", id, "");
	case SOAP_TYPE__tds__GetUsers:
		return ((_tds__GetUsers *)ptr)->soap_out(soap, "tds:GetUsers", id, "");
	case SOAP_TYPE__tds__SetRemoteUserResponse:
		return ((_tds__SetRemoteUserResponse *)ptr)->soap_out(soap, "tds:SetRemoteUserResponse", id, "");
	case SOAP_TYPE__tds__SetRemoteUser:
		return ((_tds__SetRemoteUser *)ptr)->soap_out(soap, "tds:SetRemoteUser", id, "");
	case SOAP_TYPE__tds__GetRemoteUserResponse:
		return ((_tds__GetRemoteUserResponse *)ptr)->soap_out(soap, "tds:GetRemoteUserResponse", id, "");
	case SOAP_TYPE__tds__GetRemoteUser:
		return ((_tds__GetRemoteUser *)ptr)->soap_out(soap, "tds:GetRemoteUser", id, "");
	case SOAP_TYPE__tds__GetEndpointReferenceResponse:
		return ((_tds__GetEndpointReferenceResponse *)ptr)->soap_out(soap, "tds:GetEndpointReferenceResponse", id, "");
	case SOAP_TYPE__tds__GetEndpointReference:
		return ((_tds__GetEndpointReference *)ptr)->soap_out(soap, "tds:GetEndpointReference", id, "");
	case SOAP_TYPE__tds__SetDPAddressesResponse:
		return ((_tds__SetDPAddressesResponse *)ptr)->soap_out(soap, "tds:SetDPAddressesResponse", id, "");
	case SOAP_TYPE__tds__SetDPAddresses:
		return ((_tds__SetDPAddresses *)ptr)->soap_out(soap, "tds:SetDPAddresses", id, "");
	case SOAP_TYPE__tds__GetDPAddressesResponse:
		return ((_tds__GetDPAddressesResponse *)ptr)->soap_out(soap, "tds:GetDPAddressesResponse", id, "");
	case SOAP_TYPE__tds__GetDPAddresses:
		return ((_tds__GetDPAddresses *)ptr)->soap_out(soap, "tds:GetDPAddresses", id, "");
	case SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse:
		return ((_tds__SetRemoteDiscoveryModeResponse *)ptr)->soap_out(soap, "tds:SetRemoteDiscoveryModeResponse", id, "");
	case SOAP_TYPE__tds__SetRemoteDiscoveryMode:
		return ((_tds__SetRemoteDiscoveryMode *)ptr)->soap_out(soap, "tds:SetRemoteDiscoveryMode", id, "");
	case SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse:
		return ((_tds__GetRemoteDiscoveryModeResponse *)ptr)->soap_out(soap, "tds:GetRemoteDiscoveryModeResponse", id, "");
	case SOAP_TYPE__tds__GetRemoteDiscoveryMode:
		return ((_tds__GetRemoteDiscoveryMode *)ptr)->soap_out(soap, "tds:GetRemoteDiscoveryMode", id, "");
	case SOAP_TYPE__tds__SetDiscoveryModeResponse:
		return ((_tds__SetDiscoveryModeResponse *)ptr)->soap_out(soap, "tds:SetDiscoveryModeResponse", id, "");
	case SOAP_TYPE__tds__SetDiscoveryMode:
		return ((_tds__SetDiscoveryMode *)ptr)->soap_out(soap, "tds:SetDiscoveryMode", id, "");
	case SOAP_TYPE__tds__GetDiscoveryModeResponse:
		return ((_tds__GetDiscoveryModeResponse *)ptr)->soap_out(soap, "tds:GetDiscoveryModeResponse", id, "");
	case SOAP_TYPE__tds__GetDiscoveryMode:
		return ((_tds__GetDiscoveryMode *)ptr)->soap_out(soap, "tds:GetDiscoveryMode", id, "");
	case SOAP_TYPE__tds__RemoveScopesResponse:
		return ((_tds__RemoveScopesResponse *)ptr)->soap_out(soap, "tds:RemoveScopesResponse", id, "");
	case SOAP_TYPE__tds__RemoveScopes:
		return ((_tds__RemoveScopes *)ptr)->soap_out(soap, "tds:RemoveScopes", id, "");
	case SOAP_TYPE__tds__AddScopesResponse:
		return ((_tds__AddScopesResponse *)ptr)->soap_out(soap, "tds:AddScopesResponse", id, "");
	case SOAP_TYPE__tds__AddScopes:
		return ((_tds__AddScopes *)ptr)->soap_out(soap, "tds:AddScopes", id, "");
	case SOAP_TYPE__tds__SetScopesResponse:
		return ((_tds__SetScopesResponse *)ptr)->soap_out(soap, "tds:SetScopesResponse", id, "");
	case SOAP_TYPE__tds__SetScopes:
		return ((_tds__SetScopes *)ptr)->soap_out(soap, "tds:SetScopes", id, "");
	case SOAP_TYPE__tds__GetScopesResponse:
		return ((_tds__GetScopesResponse *)ptr)->soap_out(soap, "tds:GetScopesResponse", id, "");
	case SOAP_TYPE__tds__GetScopes:
		return ((_tds__GetScopes *)ptr)->soap_out(soap, "tds:GetScopes", id, "");
	case SOAP_TYPE__tds__GetSystemLogResponse:
		return ((_tds__GetSystemLogResponse *)ptr)->soap_out(soap, "tds:GetSystemLogResponse", id, "");
	case SOAP_TYPE__tds__GetSystemLog:
		return ((_tds__GetSystemLog *)ptr)->soap_out(soap, "tds:GetSystemLog", id, "");
	case SOAP_TYPE__tds__GetSystemSupportInformationResponse:
		return ((_tds__GetSystemSupportInformationResponse *)ptr)->soap_out(soap, "tds:GetSystemSupportInformationResponse", id, "");
	case SOAP_TYPE__tds__GetSystemSupportInformation:
		return ((_tds__GetSystemSupportInformation *)ptr)->soap_out(soap, "tds:GetSystemSupportInformation", id, "");
	case SOAP_TYPE__tds__GetSystemBackupResponse:
		return ((_tds__GetSystemBackupResponse *)ptr)->soap_out(soap, "tds:GetSystemBackupResponse", id, "");
	case SOAP_TYPE__tds__GetSystemBackup:
		return ((_tds__GetSystemBackup *)ptr)->soap_out(soap, "tds:GetSystemBackup", id, "");
	case SOAP_TYPE__tds__RestoreSystemResponse:
		return ((_tds__RestoreSystemResponse *)ptr)->soap_out(soap, "tds:RestoreSystemResponse", id, "");
	case SOAP_TYPE__tds__RestoreSystem:
		return ((_tds__RestoreSystem *)ptr)->soap_out(soap, "tds:RestoreSystem", id, "");
	case SOAP_TYPE__tds__SystemRebootResponse:
		return ((_tds__SystemRebootResponse *)ptr)->soap_out(soap, "tds:SystemRebootResponse", id, "");
	case SOAP_TYPE__tds__SystemReboot:
		return ((_tds__SystemReboot *)ptr)->soap_out(soap, "tds:SystemReboot", id, "");
	case SOAP_TYPE__tds__UpgradeSystemFirmwareResponse:
		return ((_tds__UpgradeSystemFirmwareResponse *)ptr)->soap_out(soap, "tds:UpgradeSystemFirmwareResponse", id, "");
	case SOAP_TYPE__tds__UpgradeSystemFirmware:
		return ((_tds__UpgradeSystemFirmware *)ptr)->soap_out(soap, "tds:UpgradeSystemFirmware", id, "");
	case SOAP_TYPE__tds__SetSystemFactoryDefaultResponse:
		return ((_tds__SetSystemFactoryDefaultResponse *)ptr)->soap_out(soap, "tds:SetSystemFactoryDefaultResponse", id, "");
	case SOAP_TYPE__tds__SetSystemFactoryDefault:
		return ((_tds__SetSystemFactoryDefault *)ptr)->soap_out(soap, "tds:SetSystemFactoryDefault", id, "");
	case SOAP_TYPE__tds__GetSystemDateAndTimeResponse:
		return ((_tds__GetSystemDateAndTimeResponse *)ptr)->soap_out(soap, "tds:GetSystemDateAndTimeResponse", id, "");
	case SOAP_TYPE__tds__GetSystemDateAndTime:
		return ((_tds__GetSystemDateAndTime *)ptr)->soap_out(soap, "tds:GetSystemDateAndTime", id, "");
	case SOAP_TYPE__tds__SetSystemDateAndTimeResponse:
		return ((_tds__SetSystemDateAndTimeResponse *)ptr)->soap_out(soap, "tds:SetSystemDateAndTimeResponse", id, "");
	case SOAP_TYPE__tds__SetSystemDateAndTime:
		return ((_tds__SetSystemDateAndTime *)ptr)->soap_out(soap, "tds:SetSystemDateAndTime", id, "");
	case SOAP_TYPE__tds__GetDeviceInformationResponse:
		return ((_tds__GetDeviceInformationResponse *)ptr)->soap_out(soap, "tds:GetDeviceInformationResponse", id, "");
	case SOAP_TYPE__tds__GetDeviceInformation:
		return ((_tds__GetDeviceInformation *)ptr)->soap_out(soap, "tds:GetDeviceInformation", id, "");
	case SOAP_TYPE__tds__GetServiceCapabilitiesResponse:
		return ((_tds__GetServiceCapabilitiesResponse *)ptr)->soap_out(soap, "tds:GetServiceCapabilitiesResponse", id, "");
	case SOAP_TYPE__tds__GetServiceCapabilities:
		return ((_tds__GetServiceCapabilities *)ptr)->soap_out(soap, "tds:GetServiceCapabilities", id, "");
	case SOAP_TYPE__tds__GetServicesResponse:
		return ((_tds__GetServicesResponse *)ptr)->soap_out(soap, "tds:GetServicesResponse", id, "");
	case SOAP_TYPE__tds__GetServices:
		return ((_tds__GetServices *)ptr)->soap_out(soap, "tds:GetServices", id, "");
	case SOAP_TYPE_tds__StorageConfiguration:
		return ((tds__StorageConfiguration *)ptr)->soap_out(soap, tag, id, "tds:StorageConfiguration");
	case SOAP_TYPE_tds__StorageConfigurationData:
		return ((tds__StorageConfigurationData *)ptr)->soap_out(soap, tag, id, "tds:StorageConfigurationData");
	case SOAP_TYPE_tds__UserCredential:
		return ((tds__UserCredential *)ptr)->soap_out(soap, tag, id, "tds:UserCredential");
	case SOAP_TYPE_tds__MiscCapabilities:
		return ((tds__MiscCapabilities *)ptr)->soap_out(soap, tag, id, "tds:MiscCapabilities");
	case SOAP_TYPE_tds__SystemCapabilities:
		return ((tds__SystemCapabilities *)ptr)->soap_out(soap, tag, id, "tds:SystemCapabilities");
	case SOAP_TYPE_tds__SecurityCapabilities:
		return ((tds__SecurityCapabilities *)ptr)->soap_out(soap, tag, id, "tds:SecurityCapabilities");
	case SOAP_TYPE_tds__NetworkCapabilities:
		return ((tds__NetworkCapabilities *)ptr)->soap_out(soap, tag, id, "tds:NetworkCapabilities");
	case SOAP_TYPE_tds__DeviceServiceCapabilities:
		return ((tds__DeviceServiceCapabilities *)ptr)->soap_out(soap, tag, id, "tds:DeviceServiceCapabilities");
	case SOAP_TYPE_tds__Service:
		return ((tds__Service *)ptr)->soap_out(soap, tag, id, "tds:Service");
	case SOAP_TYPE__xml__lang:
		return soap_out__xml__lang(soap, "xml:lang", id, (const std::string *)ptr, "");
	case SOAP_TYPE_xsd__token:
		return soap_out_xsd__token(soap, tag, id, (const std::string *)ptr, "xsd:token");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const std::string *)ptr, "xsd:duration");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_out_xsd__anySimpleType(soap, tag, id, (const std::string *)ptr, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_xsd__NCName(soap, tag, id, (const std::string *)ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__hexBinary:
		return ((xsd__hexBinary *)ptr)->soap_out(soap, tag, id, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_SOAP_ENV__Envelope:
		return soap_out_SOAP_ENV__Envelope(soap, tag, id, (const struct SOAP_ENV__Envelope *)ptr, "SOAP-ENV:Envelope");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_out_chan__ChannelInstanceType(soap, tag, id, (const struct chan__ChannelInstanceType *)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, "");
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, "");
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, "");
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, "");
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE__xop__Include:
		return soap_out__xop__Include(soap, "xop:Include", id, (const struct _xop__Include *)ptr, "");
	case SOAP_TYPE_PointerTo_tds__SetHashingAlgorithm:
		return soap_out_PointerTo_tds__SetHashingAlgorithm(soap, tag, id, (_tds__SetHashingAlgorithm *const*)ptr, "tds:SetHashingAlgorithm");
	case SOAP_TYPE_PointerTo_tds__DeleteGeoLocation:
		return soap_out_PointerTo_tds__DeleteGeoLocation(soap, tag, id, (_tds__DeleteGeoLocation *const*)ptr, "tds:DeleteGeoLocation");
	case SOAP_TYPE_PointerTo_tds__SetGeoLocation:
		return soap_out_PointerTo_tds__SetGeoLocation(soap, tag, id, (_tds__SetGeoLocation *const*)ptr, "tds:SetGeoLocation");
	case SOAP_TYPE_PointerTo_tds__GetGeoLocation:
		return soap_out_PointerTo_tds__GetGeoLocation(soap, tag, id, (_tds__GetGeoLocation *const*)ptr, "tds:GetGeoLocation");
	case SOAP_TYPE_PointerTo_tds__DeleteStorageConfiguration:
		return soap_out_PointerTo_tds__DeleteStorageConfiguration(soap, tag, id, (_tds__DeleteStorageConfiguration *const*)ptr, "tds:DeleteStorageConfiguration");
	case SOAP_TYPE_PointerTo_tds__SetStorageConfiguration:
		return soap_out_PointerTo_tds__SetStorageConfiguration(soap, tag, id, (_tds__SetStorageConfiguration *const*)ptr, "tds:SetStorageConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetStorageConfiguration:
		return soap_out_PointerTo_tds__GetStorageConfiguration(soap, tag, id, (_tds__GetStorageConfiguration *const*)ptr, "tds:GetStorageConfiguration");
	case SOAP_TYPE_PointerTo_tds__CreateStorageConfiguration:
		return soap_out_PointerTo_tds__CreateStorageConfiguration(soap, tag, id, (_tds__CreateStorageConfiguration *const*)ptr, "tds:CreateStorageConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetStorageConfigurations:
		return soap_out_PointerTo_tds__GetStorageConfigurations(soap, tag, id, (_tds__GetStorageConfigurations *const*)ptr, "tds:GetStorageConfigurations");
	case SOAP_TYPE_PointerTo_tds__StartSystemRestore:
		return soap_out_PointerTo_tds__StartSystemRestore(soap, tag, id, (_tds__StartSystemRestore *const*)ptr, "tds:StartSystemRestore");
	case SOAP_TYPE_PointerTo_tds__StartFirmwareUpgrade:
		return soap_out_PointerTo_tds__StartFirmwareUpgrade(soap, tag, id, (_tds__StartFirmwareUpgrade *const*)ptr, "tds:StartFirmwareUpgrade");
	case SOAP_TYPE_PointerTo_tds__GetSystemUris:
		return soap_out_PointerTo_tds__GetSystemUris(soap, tag, id, (_tds__GetSystemUris *const*)ptr, "tds:GetSystemUris");
	case SOAP_TYPE_PointerTo_tds__ScanAvailableDot11Networks:
		return soap_out_PointerTo_tds__ScanAvailableDot11Networks(soap, tag, id, (_tds__ScanAvailableDot11Networks *const*)ptr, "tds:ScanAvailableDot11Networks");
	case SOAP_TYPE_PointerTo_tds__GetDot11Status:
		return soap_out_PointerTo_tds__GetDot11Status(soap, tag, id, (_tds__GetDot11Status *const*)ptr, "tds:GetDot11Status");
	case SOAP_TYPE_PointerTo_tds__GetDot11Capabilities:
		return soap_out_PointerTo_tds__GetDot11Capabilities(soap, tag, id, (_tds__GetDot11Capabilities *const*)ptr, "tds:GetDot11Capabilities");
	case SOAP_TYPE_PointerTo_tds__DeleteDot1XConfiguration:
		return soap_out_PointerTo_tds__DeleteDot1XConfiguration(soap, tag, id, (_tds__DeleteDot1XConfiguration *const*)ptr, "tds:DeleteDot1XConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetDot1XConfigurations:
		return soap_out_PointerTo_tds__GetDot1XConfigurations(soap, tag, id, (_tds__GetDot1XConfigurations *const*)ptr, "tds:GetDot1XConfigurations");
	case SOAP_TYPE_PointerTo_tds__GetDot1XConfiguration:
		return soap_out_PointerTo_tds__GetDot1XConfiguration(soap, tag, id, (_tds__GetDot1XConfiguration *const*)ptr, "tds:GetDot1XConfiguration");
	case SOAP_TYPE_PointerTo_tds__SetDot1XConfiguration:
		return soap_out_PointerTo_tds__SetDot1XConfiguration(soap, tag, id, (_tds__SetDot1XConfiguration *const*)ptr, "tds:SetDot1XConfiguration");
	case SOAP_TYPE_PointerTo_tds__CreateDot1XConfiguration:
		return soap_out_PointerTo_tds__CreateDot1XConfiguration(soap, tag, id, (_tds__CreateDot1XConfiguration *const*)ptr, "tds:CreateDot1XConfiguration");
	case SOAP_TYPE_PointerTo_tds__LoadCACertificates:
		return soap_out_PointerTo_tds__LoadCACertificates(soap, tag, id, (_tds__LoadCACertificates *const*)ptr, "tds:LoadCACertificates");
	case SOAP_TYPE_PointerTo_tds__GetCertificateInformation:
		return soap_out_PointerTo_tds__GetCertificateInformation(soap, tag, id, (_tds__GetCertificateInformation *const*)ptr, "tds:GetCertificateInformation");
	case SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKey:
		return soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag, id, (_tds__LoadCertificateWithPrivateKey *const*)ptr, "tds:LoadCertificateWithPrivateKey");
	case SOAP_TYPE_PointerTo_tds__GetCACertificates:
		return soap_out_PointerTo_tds__GetCACertificates(soap, tag, id, (_tds__GetCACertificates *const*)ptr, "tds:GetCACertificates");
	case SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand:
		return soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, tag, id, (_tds__SendAuxiliaryCommand *const*)ptr, "tds:SendAuxiliaryCommand");
	case SOAP_TYPE_PointerTo_tds__SetRelayOutputState:
		return soap_out_PointerTo_tds__SetRelayOutputState(soap, tag, id, (_tds__SetRelayOutputState *const*)ptr, "tds:SetRelayOutputState");
	case SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings:
		return soap_out_PointerTo_tds__SetRelayOutputSettings(soap, tag, id, (_tds__SetRelayOutputSettings *const*)ptr, "tds:SetRelayOutputSettings");
	case SOAP_TYPE_PointerTo_tds__GetRelayOutputs:
		return soap_out_PointerTo_tds__GetRelayOutputs(soap, tag, id, (_tds__GetRelayOutputs *const*)ptr, "tds:GetRelayOutputs");
	case SOAP_TYPE_PointerTo_tds__SetClientCertificateMode:
		return soap_out_PointerTo_tds__SetClientCertificateMode(soap, tag, id, (_tds__SetClientCertificateMode *const*)ptr, "tds:SetClientCertificateMode");
	case SOAP_TYPE_PointerTo_tds__GetClientCertificateMode:
		return soap_out_PointerTo_tds__GetClientCertificateMode(soap, tag, id, (_tds__GetClientCertificateMode *const*)ptr, "tds:GetClientCertificateMode");
	case SOAP_TYPE_PointerTo_tds__LoadCertificates:
		return soap_out_PointerTo_tds__LoadCertificates(soap, tag, id, (_tds__LoadCertificates *const*)ptr, "tds:LoadCertificates");
	case SOAP_TYPE_PointerTo_tds__GetPkcs10Request:
		return soap_out_PointerTo_tds__GetPkcs10Request(soap, tag, id, (_tds__GetPkcs10Request *const*)ptr, "tds:GetPkcs10Request");
	case SOAP_TYPE_PointerTo_tds__DeleteCertificates:
		return soap_out_PointerTo_tds__DeleteCertificates(soap, tag, id, (_tds__DeleteCertificates *const*)ptr, "tds:DeleteCertificates");
	case SOAP_TYPE_PointerTo_tds__SetCertificatesStatus:
		return soap_out_PointerTo_tds__SetCertificatesStatus(soap, tag, id, (_tds__SetCertificatesStatus *const*)ptr, "tds:SetCertificatesStatus");
	case SOAP_TYPE_PointerTo_tds__GetCertificatesStatus:
		return soap_out_PointerTo_tds__GetCertificatesStatus(soap, tag, id, (_tds__GetCertificatesStatus *const*)ptr, "tds:GetCertificatesStatus");
	case SOAP_TYPE_PointerTo_tds__GetCertificates:
		return soap_out_PointerTo_tds__GetCertificates(soap, tag, id, (_tds__GetCertificates *const*)ptr, "tds:GetCertificates");
	case SOAP_TYPE_PointerTo_tds__CreateCertificate:
		return soap_out_PointerTo_tds__CreateCertificate(soap, tag, id, (_tds__CreateCertificate *const*)ptr, "tds:CreateCertificate");
	case SOAP_TYPE_PointerTo_tds__SetAccessPolicy:
		return soap_out_PointerTo_tds__SetAccessPolicy(soap, tag, id, (_tds__SetAccessPolicy *const*)ptr, "tds:SetAccessPolicy");
	case SOAP_TYPE_PointerTo_tds__GetAccessPolicy:
		return soap_out_PointerTo_tds__GetAccessPolicy(soap, tag, id, (_tds__GetAccessPolicy *const*)ptr, "tds:GetAccessPolicy");
	case SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter:
		return soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, tag, id, (_tds__RemoveIPAddressFilter *const*)ptr, "tds:RemoveIPAddressFilter");
	case SOAP_TYPE_PointerTo_tds__AddIPAddressFilter:
		return soap_out_PointerTo_tds__AddIPAddressFilter(soap, tag, id, (_tds__AddIPAddressFilter *const*)ptr, "tds:AddIPAddressFilter");
	case SOAP_TYPE_PointerTo_tds__SetIPAddressFilter:
		return soap_out_PointerTo_tds__SetIPAddressFilter(soap, tag, id, (_tds__SetIPAddressFilter *const*)ptr, "tds:SetIPAddressFilter");
	case SOAP_TYPE_PointerTo_tds__GetIPAddressFilter:
		return soap_out_PointerTo_tds__GetIPAddressFilter(soap, tag, id, (_tds__GetIPAddressFilter *const*)ptr, "tds:GetIPAddressFilter");
	case SOAP_TYPE_PointerTo_tds__SetZeroConfiguration:
		return soap_out_PointerTo_tds__SetZeroConfiguration(soap, tag, id, (_tds__SetZeroConfiguration *const*)ptr, "tds:SetZeroConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetZeroConfiguration:
		return soap_out_PointerTo_tds__GetZeroConfiguration(soap, tag, id, (_tds__GetZeroConfiguration *const*)ptr, "tds:GetZeroConfiguration");
	case SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway:
		return soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, tag, id, (_tds__SetNetworkDefaultGateway *const*)ptr, "tds:SetNetworkDefaultGateway");
	case SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway:
		return soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, tag, id, (_tds__GetNetworkDefaultGateway *const*)ptr, "tds:GetNetworkDefaultGateway");
	case SOAP_TYPE_PointerTo_tds__SetNetworkProtocols:
		return soap_out_PointerTo_tds__SetNetworkProtocols(soap, tag, id, (_tds__SetNetworkProtocols *const*)ptr, "tds:SetNetworkProtocols");
	case SOAP_TYPE_PointerTo_tds__GetNetworkProtocols:
		return soap_out_PointerTo_tds__GetNetworkProtocols(soap, tag, id, (_tds__GetNetworkProtocols *const*)ptr, "tds:GetNetworkProtocols");
	case SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces:
		return soap_out_PointerTo_tds__SetNetworkInterfaces(soap, tag, id, (_tds__SetNetworkInterfaces *const*)ptr, "tds:SetNetworkInterfaces");
	case SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces:
		return soap_out_PointerTo_tds__GetNetworkInterfaces(soap, tag, id, (_tds__GetNetworkInterfaces *const*)ptr, "tds:GetNetworkInterfaces");
	case SOAP_TYPE_PointerTo_tds__SetDynamicDNS:
		return soap_out_PointerTo_tds__SetDynamicDNS(soap, tag, id, (_tds__SetDynamicDNS *const*)ptr, "tds:SetDynamicDNS");
	case SOAP_TYPE_PointerTo_tds__GetDynamicDNS:
		return soap_out_PointerTo_tds__GetDynamicDNS(soap, tag, id, (_tds__GetDynamicDNS *const*)ptr, "tds:GetDynamicDNS");
	case SOAP_TYPE_PointerTo_tds__SetNTP:
		return soap_out_PointerTo_tds__SetNTP(soap, tag, id, (_tds__SetNTP *const*)ptr, "tds:SetNTP");
	case SOAP_TYPE_PointerTo_tds__GetNTP:
		return soap_out_PointerTo_tds__GetNTP(soap, tag, id, (_tds__GetNTP *const*)ptr, "tds:GetNTP");
	case SOAP_TYPE_PointerTo_tds__SetDNS:
		return soap_out_PointerTo_tds__SetDNS(soap, tag, id, (_tds__SetDNS *const*)ptr, "tds:SetDNS");
	case SOAP_TYPE_PointerTo_tds__GetDNS:
		return soap_out_PointerTo_tds__GetDNS(soap, tag, id, (_tds__GetDNS *const*)ptr, "tds:GetDNS");
	case SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP:
		return soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, tag, id, (_tds__SetHostnameFromDHCP *const*)ptr, "tds:SetHostnameFromDHCP");
	case SOAP_TYPE_PointerTo_tds__SetHostname:
		return soap_out_PointerTo_tds__SetHostname(soap, tag, id, (_tds__SetHostname *const*)ptr, "tds:SetHostname");
	case SOAP_TYPE_PointerTo_tds__GetHostname:
		return soap_out_PointerTo_tds__GetHostname(soap, tag, id, (_tds__GetHostname *const*)ptr, "tds:GetHostname");
	case SOAP_TYPE_PointerTo_tds__SetDPAddresses:
		return soap_out_PointerTo_tds__SetDPAddresses(soap, tag, id, (_tds__SetDPAddresses *const*)ptr, "tds:SetDPAddresses");
	case SOAP_TYPE_PointerTo_tds__GetCapabilities:
		return soap_out_PointerTo_tds__GetCapabilities(soap, tag, id, (_tds__GetCapabilities *const*)ptr, "tds:GetCapabilities");
	case SOAP_TYPE_PointerTo_tds__SetAuthFailureWarningConfiguration:
		return soap_out_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, tag, id, (_tds__SetAuthFailureWarningConfiguration *const*)ptr, "tds:SetAuthFailureWarningConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetAuthFailureWarningConfiguration:
		return soap_out_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, tag, id, (_tds__GetAuthFailureWarningConfiguration *const*)ptr, "tds:GetAuthFailureWarningConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetAuthFailureWarningOptions:
		return soap_out_PointerTo_tds__GetAuthFailureWarningOptions(soap, tag, id, (_tds__GetAuthFailureWarningOptions *const*)ptr, "tds:GetAuthFailureWarningOptions");
	case SOAP_TYPE_PointerTo_tds__SetPasswordHistoryConfiguration:
		return soap_out_PointerTo_tds__SetPasswordHistoryConfiguration(soap, tag, id, (_tds__SetPasswordHistoryConfiguration *const*)ptr, "tds:SetPasswordHistoryConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetPasswordHistoryConfiguration:
		return soap_out_PointerTo_tds__GetPasswordHistoryConfiguration(soap, tag, id, (_tds__GetPasswordHistoryConfiguration *const*)ptr, "tds:GetPasswordHistoryConfiguration");
	case SOAP_TYPE_PointerTo_tds__SetPasswordComplexityConfiguration:
		return soap_out_PointerTo_tds__SetPasswordComplexityConfiguration(soap, tag, id, (_tds__SetPasswordComplexityConfiguration *const*)ptr, "tds:SetPasswordComplexityConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetPasswordComplexityConfiguration:
		return soap_out_PointerTo_tds__GetPasswordComplexityConfiguration(soap, tag, id, (_tds__GetPasswordComplexityConfiguration *const*)ptr, "tds:GetPasswordComplexityConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetPasswordComplexityOptions:
		return soap_out_PointerTo_tds__GetPasswordComplexityOptions(soap, tag, id, (_tds__GetPasswordComplexityOptions *const*)ptr, "tds:GetPasswordComplexityOptions");
	case SOAP_TYPE_PointerTo_tds__GetWsdlUrl:
		return soap_out_PointerTo_tds__GetWsdlUrl(soap, tag, id, (_tds__GetWsdlUrl *const*)ptr, "tds:GetWsdlUrl");
	case SOAP_TYPE_PointerTo_tds__SetUser:
		return soap_out_PointerTo_tds__SetUser(soap, tag, id, (_tds__SetUser *const*)ptr, "tds:SetUser");
	case SOAP_TYPE_PointerTo_tds__DeleteUsers:
		return soap_out_PointerTo_tds__DeleteUsers(soap, tag, id, (_tds__DeleteUsers *const*)ptr, "tds:DeleteUsers");
	case SOAP_TYPE_PointerTo_tds__CreateUsers:
		return soap_out_PointerTo_tds__CreateUsers(soap, tag, id, (_tds__CreateUsers *const*)ptr, "tds:CreateUsers");
	case SOAP_TYPE_PointerTo_tds__GetUsers:
		return soap_out_PointerTo_tds__GetUsers(soap, tag, id, (_tds__GetUsers *const*)ptr, "tds:GetUsers");
	case SOAP_TYPE_PointerTo_tds__SetRemoteUser:
		return soap_out_PointerTo_tds__SetRemoteUser(soap, tag, id, (_tds__SetRemoteUser *const*)ptr, "tds:SetRemoteUser");
	case SOAP_TYPE_PointerTo_tds__GetRemoteUser:
		return soap_out_PointerTo_tds__GetRemoteUser(soap, tag, id, (_tds__GetRemoteUser *const*)ptr, "tds:GetRemoteUser");
	case SOAP_TYPE_PointerTo_tds__GetEndpointReference:
		return soap_out_PointerTo_tds__GetEndpointReference(soap, tag, id, (_tds__GetEndpointReference *const*)ptr, "tds:GetEndpointReference");
	case SOAP_TYPE_PointerTo_tds__GetDPAddresses:
		return soap_out_PointerTo_tds__GetDPAddresses(soap, tag, id, (_tds__GetDPAddresses *const*)ptr, "tds:GetDPAddresses");
	case SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryMode:
		return soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag, id, (_tds__SetRemoteDiscoveryMode *const*)ptr, "tds:SetRemoteDiscoveryMode");
	case SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryMode:
		return soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag, id, (_tds__GetRemoteDiscoveryMode *const*)ptr, "tds:GetRemoteDiscoveryMode");
	case SOAP_TYPE_PointerTo_tds__SetDiscoveryMode:
		return soap_out_PointerTo_tds__SetDiscoveryMode(soap, tag, id, (_tds__SetDiscoveryMode *const*)ptr, "tds:SetDiscoveryMode");
	case SOAP_TYPE_PointerTo_tds__GetDiscoveryMode:
		return soap_out_PointerTo_tds__GetDiscoveryMode(soap, tag, id, (_tds__GetDiscoveryMode *const*)ptr, "tds:GetDiscoveryMode");
	case SOAP_TYPE_PointerTo_tds__RemoveScopes:
		return soap_out_PointerTo_tds__RemoveScopes(soap, tag, id, (_tds__RemoveScopes *const*)ptr, "tds:RemoveScopes");
	case SOAP_TYPE_PointerTo_tds__AddScopes:
		return soap_out_PointerTo_tds__AddScopes(soap, tag, id, (_tds__AddScopes *const*)ptr, "tds:AddScopes");
	case SOAP_TYPE_PointerTo_tds__SetScopes:
		return soap_out_PointerTo_tds__SetScopes(soap, tag, id, (_tds__SetScopes *const*)ptr, "tds:SetScopes");
	case SOAP_TYPE_PointerTo_tds__GetScopes:
		return soap_out_PointerTo_tds__GetScopes(soap, tag, id, (_tds__GetScopes *const*)ptr, "tds:GetScopes");
	case SOAP_TYPE_PointerTo_tds__GetSystemSupportInformation:
		return soap_out_PointerTo_tds__GetSystemSupportInformation(soap, tag, id, (_tds__GetSystemSupportInformation *const*)ptr, "tds:GetSystemSupportInformation");
	case SOAP_TYPE_PointerTo_tds__GetSystemLog:
		return soap_out_PointerTo_tds__GetSystemLog(soap, tag, id, (_tds__GetSystemLog *const*)ptr, "tds:GetSystemLog");
	case SOAP_TYPE_PointerTo_tds__GetSystemBackup:
		return soap_out_PointerTo_tds__GetSystemBackup(soap, tag, id, (_tds__GetSystemBackup *const*)ptr, "tds:GetSystemBackup");
	case SOAP_TYPE_PointerTo_tds__RestoreSystem:
		return soap_out_PointerTo_tds__RestoreSystem(soap, tag, id, (_tds__RestoreSystem *const*)ptr, "tds:RestoreSystem");
	case SOAP_TYPE_PointerTo_tds__SystemReboot:
		return soap_out_PointerTo_tds__SystemReboot(soap, tag, id, (_tds__SystemReboot *const*)ptr, "tds:SystemReboot");
	case SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmware:
		return soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, tag, id, (_tds__UpgradeSystemFirmware *const*)ptr, "tds:UpgradeSystemFirmware");
	case SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault:
		return soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, tag, id, (_tds__SetSystemFactoryDefault *const*)ptr, "tds:SetSystemFactoryDefault");
	case SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime:
		return soap_out_PointerTo_tds__GetSystemDateAndTime(soap, tag, id, (_tds__GetSystemDateAndTime *const*)ptr, "tds:GetSystemDateAndTime");
	case SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime:
		return soap_out_PointerTo_tds__SetSystemDateAndTime(soap, tag, id, (_tds__SetSystemDateAndTime *const*)ptr, "tds:SetSystemDateAndTime");
	case SOAP_TYPE_PointerTo_tds__GetDeviceInformation:
		return soap_out_PointerTo_tds__GetDeviceInformation(soap, tag, id, (_tds__GetDeviceInformation *const*)ptr, "tds:GetDeviceInformation");
	case SOAP_TYPE_PointerTo_tds__GetServiceCapabilities:
		return soap_out_PointerTo_tds__GetServiceCapabilities(soap, tag, id, (_tds__GetServiceCapabilities *const*)ptr, "tds:GetServiceCapabilities");
	case SOAP_TYPE_PointerTo_tds__GetServices:
		return soap_out_PointerTo_tds__GetServices(soap, tag, id, (_tds__GetServices *const*)ptr, "tds:GetServices");
	case SOAP_TYPE_PointerTott__NetworkInterfaceExtension:
		return soap_out_PointerTott__NetworkInterfaceExtension(soap, tag, id, (tt__NetworkInterfaceExtension *const*)ptr, "tt:NetworkInterfaceExtension");
	case SOAP_TYPE_PointerTott__IPv6NetworkInterface:
		return soap_out_PointerTott__IPv6NetworkInterface(soap, tag, id, (tt__IPv6NetworkInterface *const*)ptr, "tt:IPv6NetworkInterface");
	case SOAP_TYPE_PointerTott__IPv4NetworkInterface:
		return soap_out_PointerTott__IPv4NetworkInterface(soap, tag, id, (tt__IPv4NetworkInterface *const*)ptr, "tt:IPv4NetworkInterface");
	case SOAP_TYPE_PointerTott__NetworkInterfaceLink:
		return soap_out_PointerTott__NetworkInterfaceLink(soap, tag, id, (tt__NetworkInterfaceLink *const*)ptr, "tt:NetworkInterfaceLink");
	case SOAP_TYPE_PointerTott__NetworkInterfaceInfo:
		return soap_out_PointerTott__NetworkInterfaceInfo(soap, tag, id, (tt__NetworkInterfaceInfo *const*)ptr, "tt:NetworkInterfaceInfo");
	case SOAP_TYPE_PointerTott__LocalOrientation:
		return soap_out_PointerTott__LocalOrientation(soap, tag, id, (tt__LocalOrientation *const*)ptr, "tt:LocalOrientation");
	case SOAP_TYPE_PointerTott__LocalLocation:
		return soap_out_PointerTott__LocalLocation(soap, tag, id, (tt__LocalLocation *const*)ptr, "tt:LocalLocation");
	case SOAP_TYPE_PointerTott__GeoOrientation:
		return soap_out_PointerTott__GeoOrientation(soap, tag, id, (tt__GeoOrientation *const*)ptr, "tt:GeoOrientation");
	case SOAP_TYPE_PointerTott__GeoLocation:
		return soap_out_PointerTott__GeoLocation(soap, tag, id, (tt__GeoLocation *const*)ptr, "tt:GeoLocation");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTott__EapMethodExtension:
		return soap_out_PointerTott__EapMethodExtension(soap, tag, id, (tt__EapMethodExtension *const*)ptr, "tt:EapMethodExtension");
	case SOAP_TYPE_PointerTott__TLSConfiguration:
		return soap_out_PointerTott__TLSConfiguration(soap, tag, id, (tt__TLSConfiguration *const*)ptr, "tt:TLSConfiguration");
	case SOAP_TYPE_PointerTott__Dot1XConfigurationExtension:
		return soap_out_PointerTott__Dot1XConfigurationExtension(soap, tag, id, (tt__Dot1XConfigurationExtension *const*)ptr, "tt:Dot1XConfigurationExtension");
	case SOAP_TYPE_PointerTott__EAPMethodConfiguration:
		return soap_out_PointerTott__EAPMethodConfiguration(soap, tag, id, (tt__EAPMethodConfiguration *const*)ptr, "tt:EAPMethodConfiguration");
	case SOAP_TYPE_PointerTott__CertificateInformationExtension:
		return soap_out_PointerTott__CertificateInformationExtension(soap, tag, id, (tt__CertificateInformationExtension *const*)ptr, "tt:CertificateInformationExtension");
	case SOAP_TYPE_PointerTott__DateTimeRange:
		return soap_out_PointerTott__DateTimeRange(soap, tag, id, (tt__DateTimeRange *const*)ptr, "tt:DateTimeRange");
	case SOAP_TYPE_PointerTott__CertificateUsage:
		return soap_out_PointerTott__CertificateUsage(soap, tag, id, (tt__CertificateUsage *const*)ptr, "tt:CertificateUsage");
	case SOAP_TYPE_PointerTott__UserExtension:
		return soap_out_PointerTott__UserExtension(soap, tag, id, (tt__UserExtension *const*)ptr, "tt:UserExtension");
	case SOAP_TYPE_PointerTott__Date:
		return soap_out_PointerTott__Date(soap, tag, id, (tt__Date *const*)ptr, "tt:Date");
	case SOAP_TYPE_PointerTott__Time:
		return soap_out_PointerTott__Time(soap, tag, id, (tt__Time *const*)ptr, "tt:Time");
	case SOAP_TYPE_PointerTott__SystemDateTimeExtension:
		return soap_out_PointerTott__SystemDateTimeExtension(soap, tag, id, (tt__SystemDateTimeExtension *const*)ptr, "tt:SystemDateTimeExtension");
	case SOAP_TYPE_PointerTott__SystemLogUri:
		return soap_out_PointerTott__SystemLogUri(soap, tag, id, (tt__SystemLogUri *const*)ptr, "tt:SystemLogUri");
	case SOAP_TYPE_PointerTott__AnalyticsDeviceExtension:
		return soap_out_PointerTott__AnalyticsDeviceExtension(soap, tag, id, (tt__AnalyticsDeviceExtension *const*)ptr, "tt:AnalyticsDeviceExtension");
	case SOAP_TYPE_PointerTott__SystemCapabilitiesExtension2:
		return soap_out_PointerTott__SystemCapabilitiesExtension2(soap, tag, id, (tt__SystemCapabilitiesExtension2 *const*)ptr, "tt:SystemCapabilitiesExtension2");
	case SOAP_TYPE_PointerTott__SystemCapabilitiesExtension:
		return soap_out_PointerTott__SystemCapabilitiesExtension(soap, tag, id, (tt__SystemCapabilitiesExtension *const*)ptr, "tt:SystemCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension2:
		return soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, tag, id, (tt__SecurityCapabilitiesExtension2 *const*)ptr, "tt:SecurityCapabilitiesExtension2");
	case SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension:
		return soap_out_PointerTott__SecurityCapabilitiesExtension(soap, tag, id, (tt__SecurityCapabilitiesExtension *const*)ptr, "tt:SecurityCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension2:
		return soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, tag, id, (tt__NetworkCapabilitiesExtension2 *const*)ptr, "tt:NetworkCapabilitiesExtension2");
	case SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension:
		return soap_out_PointerTott__NetworkCapabilitiesExtension(soap, tag, id, (tt__NetworkCapabilitiesExtension *const*)ptr, "tt:NetworkCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension:
		return soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag, id, (tt__RealTimeStreamingCapabilitiesExtension *const*)ptr, "tt:RealTimeStreamingCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__ProfileCapabilities:
		return soap_out_PointerTott__ProfileCapabilities(soap, tag, id, (tt__ProfileCapabilities *const*)ptr, "tt:ProfileCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilitiesExtension:
		return soap_out_PointerTott__MediaCapabilitiesExtension(soap, tag, id, (tt__MediaCapabilitiesExtension *const*)ptr, "tt:MediaCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities:
		return soap_out_PointerTott__RealTimeStreamingCapabilities(soap, tag, id, (tt__RealTimeStreamingCapabilities *const*)ptr, "tt:RealTimeStreamingCapabilities");
	case SOAP_TYPE_PointerTott__IOCapabilitiesExtension2:
		return soap_out_PointerTott__IOCapabilitiesExtension2(soap, tag, id, (tt__IOCapabilitiesExtension2 *const*)ptr, "tt:IOCapabilitiesExtension2");
	case SOAP_TYPE_PointerTott__IOCapabilitiesExtension:
		return soap_out_PointerTott__IOCapabilitiesExtension(soap, tag, id, (tt__IOCapabilitiesExtension *const*)ptr, "tt:IOCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension:
		return soap_out_PointerTott__DeviceCapabilitiesExtension(soap, tag, id, (tt__DeviceCapabilitiesExtension *const*)ptr, "tt:DeviceCapabilitiesExtension");
	case SOAP_TYPE_PointerTott__SecurityCapabilities:
		return soap_out_PointerTott__SecurityCapabilities(soap, tag, id, (tt__SecurityCapabilities *const*)ptr, "tt:SecurityCapabilities");
	case SOAP_TYPE_PointerTott__IOCapabilities:
		return soap_out_PointerTott__IOCapabilities(soap, tag, id, (tt__IOCapabilities *const*)ptr, "tt:IOCapabilities");
	case SOAP_TYPE_PointerTott__SystemCapabilities:
		return soap_out_PointerTott__SystemCapabilities(soap, tag, id, (tt__SystemCapabilities *const*)ptr, "tt:SystemCapabilities");
	case SOAP_TYPE_PointerTott__NetworkCapabilities:
		return soap_out_PointerTott__NetworkCapabilities(soap, tag, id, (tt__NetworkCapabilities *const*)ptr, "tt:NetworkCapabilities");
	case SOAP_TYPE_PointerTott__CapabilitiesExtension2:
		return soap_out_PointerTott__CapabilitiesExtension2(soap, tag, id, (tt__CapabilitiesExtension2 *const*)ptr, "tt:CapabilitiesExtension2");
	case SOAP_TYPE_PointerTott__AnalyticsDeviceCapabilities:
		return soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, tag, id, (tt__AnalyticsDeviceCapabilities *const*)ptr, "tt:AnalyticsDeviceCapabilities");
	case SOAP_TYPE_PointerTott__ReceiverCapabilities:
		return soap_out_PointerTott__ReceiverCapabilities(soap, tag, id, (tt__ReceiverCapabilities *const*)ptr, "tt:ReceiverCapabilities");
	case SOAP_TYPE_PointerTott__ReplayCapabilities:
		return soap_out_PointerTott__ReplayCapabilities(soap, tag, id, (tt__ReplayCapabilities *const*)ptr, "tt:ReplayCapabilities");
	case SOAP_TYPE_PointerTott__SearchCapabilities:
		return soap_out_PointerTott__SearchCapabilities(soap, tag, id, (tt__SearchCapabilities *const*)ptr, "tt:SearchCapabilities");
	case SOAP_TYPE_PointerTott__RecordingCapabilities:
		return soap_out_PointerTott__RecordingCapabilities(soap, tag, id, (tt__RecordingCapabilities *const*)ptr, "tt:RecordingCapabilities");
	case SOAP_TYPE_PointerTott__DisplayCapabilities:
		return soap_out_PointerTott__DisplayCapabilities(soap, tag, id, (tt__DisplayCapabilities *const*)ptr, "tt:DisplayCapabilities");
	case SOAP_TYPE_PointerTott__DeviceIOCapabilities:
		return soap_out_PointerTott__DeviceIOCapabilities(soap, tag, id, (tt__DeviceIOCapabilities *const*)ptr, "tt:DeviceIOCapabilities");
	case SOAP_TYPE_PointerTott__CapabilitiesExtension:
		return soap_out_PointerTott__CapabilitiesExtension(soap, tag, id, (tt__CapabilitiesExtension *const*)ptr, "tt:CapabilitiesExtension");
	case SOAP_TYPE_PointerTott__PTZCapabilities:
		return soap_out_PointerTott__PTZCapabilities(soap, tag, id, (tt__PTZCapabilities *const*)ptr, "tt:PTZCapabilities");
	case SOAP_TYPE_PointerTott__MediaCapabilities:
		return soap_out_PointerTott__MediaCapabilities(soap, tag, id, (tt__MediaCapabilities *const*)ptr, "tt:MediaCapabilities");
	case SOAP_TYPE_PointerTott__ImagingCapabilities:
		return soap_out_PointerTott__ImagingCapabilities(soap, tag, id, (tt__ImagingCapabilities *const*)ptr, "tt:ImagingCapabilities");
	case SOAP_TYPE_PointerTott__EventCapabilities:
		return soap_out_PointerTott__EventCapabilities(soap, tag, id, (tt__EventCapabilities *const*)ptr, "tt:EventCapabilities");
	case SOAP_TYPE_PointerTott__DeviceCapabilities:
		return soap_out_PointerTott__DeviceCapabilities(soap, tag, id, (tt__DeviceCapabilities *const*)ptr, "tt:DeviceCapabilities");
	case SOAP_TYPE_PointerTott__AnalyticsCapabilities:
		return soap_out_PointerTott__AnalyticsCapabilities(soap, tag, id, (tt__AnalyticsCapabilities *const*)ptr, "tt:AnalyticsCapabilities");
	case SOAP_TYPE_PointerTott__Dot11AvailableNetworksExtension:
		return soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, tag, id, (tt__Dot11AvailableNetworksExtension *const*)ptr, "tt:Dot11AvailableNetworksExtension");
	case SOAP_TYPE_PointerTott__Dot11SignalStrength:
		return soap_out_PointerTott__Dot11SignalStrength(soap, tag, id, (enum tt__Dot11SignalStrength *const*)ptr, "tt:Dot11SignalStrength");
	case SOAP_TYPE_PointerTott__Dot11PSKSetExtension:
		return soap_out_PointerTott__Dot11PSKSetExtension(soap, tag, id, (tt__Dot11PSKSetExtension *const*)ptr, "tt:Dot11PSKSetExtension");
	case SOAP_TYPE_PointerTott__Dot11PSKPassphrase:
		return soap_out_PointerTott__Dot11PSKPassphrase(soap, tag, id, (std::string *const*)ptr, "tt:Dot11PSKPassphrase");
	case SOAP_TYPE_PointerTott__Dot11PSK:
		return soap_out_PointerTott__Dot11PSK(soap, tag, id, (xsd__hexBinary *const*)ptr, "tt:Dot11PSK");
	case SOAP_TYPE_PointerTott__Dot11SecurityConfigurationExtension:
		return soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, tag, id, (tt__Dot11SecurityConfigurationExtension *const*)ptr, "tt:Dot11SecurityConfigurationExtension");
	case SOAP_TYPE_PointerTott__ReferenceToken:
		return soap_out_PointerTott__ReferenceToken(soap, tag, id, (std::string *const*)ptr, "tt:ReferenceToken");
	case SOAP_TYPE_PointerTott__Dot11PSKSet:
		return soap_out_PointerTott__Dot11PSKSet(soap, tag, id, (tt__Dot11PSKSet *const*)ptr, "tt:Dot11PSKSet");
	case SOAP_TYPE_PointerTott__Dot11Cipher:
		return soap_out_PointerTott__Dot11Cipher(soap, tag, id, (enum tt__Dot11Cipher *const*)ptr, "tt:Dot11Cipher");
	case SOAP_TYPE_PointerTott__Dot11SecurityConfiguration:
		return soap_out_PointerTott__Dot11SecurityConfiguration(soap, tag, id, (tt__Dot11SecurityConfiguration *const*)ptr, "tt:Dot11SecurityConfiguration");
	case SOAP_TYPE_PointerTott__IPAddressFilterExtension:
		return soap_out_PointerTott__IPAddressFilterExtension(soap, tag, id, (tt__IPAddressFilterExtension *const*)ptr, "tt:IPAddressFilterExtension");
	case SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension2:
		return soap_out_PointerTott__NetworkZeroConfigurationExtension2(soap, tag, id, (tt__NetworkZeroConfigurationExtension2 *const*)ptr, "tt:NetworkZeroConfigurationExtension2");
	case SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension:
		return soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, tag, id, (tt__NetworkZeroConfigurationExtension *const*)ptr, "tt:NetworkZeroConfigurationExtension");
	case SOAP_TYPE_PointerTott__IPv6DHCPConfiguration:
		return soap_out_PointerTott__IPv6DHCPConfiguration(soap, tag, id, (enum tt__IPv6DHCPConfiguration *const*)ptr, "tt:IPv6DHCPConfiguration");
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension2:
		return soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag, id, (tt__NetworkInterfaceSetConfigurationExtension2 *const*)ptr, "tt:NetworkInterfaceSetConfigurationExtension2");
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension:
		return soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag, id, (tt__NetworkInterfaceSetConfigurationExtension *const*)ptr, "tt:NetworkInterfaceSetConfigurationExtension");
	case SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration:
		return soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, (tt__IPv6NetworkInterfaceSetConfiguration *const*)ptr, "tt:IPv6NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration:
		return soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, (tt__IPv4NetworkInterfaceSetConfiguration *const*)ptr, "tt:IPv4NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTott__DynamicDNSInformationExtension:
		return soap_out_PointerTott__DynamicDNSInformationExtension(soap, tag, id, (tt__DynamicDNSInformationExtension *const*)ptr, "tt:DynamicDNSInformationExtension");
	case SOAP_TYPE_PointerTott__NTPInformationExtension:
		return soap_out_PointerTott__NTPInformationExtension(soap, tag, id, (tt__NTPInformationExtension *const*)ptr, "tt:NTPInformationExtension");
	case SOAP_TYPE_PointerTott__DNSInformationExtension:
		return soap_out_PointerTott__DNSInformationExtension(soap, tag, id, (tt__DNSInformationExtension *const*)ptr, "tt:DNSInformationExtension");
	case SOAP_TYPE_PointerTott__HostnameInformationExtension:
		return soap_out_PointerTott__HostnameInformationExtension(soap, tag, id, (tt__HostnameInformationExtension *const*)ptr, "tt:HostnameInformationExtension");
	case SOAP_TYPE_PointerTott__NetworkHostExtension:
		return soap_out_PointerTott__NetworkHostExtension(soap, tag, id, (tt__NetworkHostExtension *const*)ptr, "tt:NetworkHostExtension");
	case SOAP_TYPE_PointerTott__IPv6Address:
		return soap_out_PointerTott__IPv6Address(soap, tag, id, (std::string *const*)ptr, "tt:IPv6Address");
	case SOAP_TYPE_PointerTott__IPv4Address:
		return soap_out_PointerTott__IPv4Address(soap, tag, id, (std::string *const*)ptr, "tt:IPv4Address");
	case SOAP_TYPE_PointerTott__NetworkProtocolExtension:
		return soap_out_PointerTott__NetworkProtocolExtension(soap, tag, id, (tt__NetworkProtocolExtension *const*)ptr, "tt:NetworkProtocolExtension");
	case SOAP_TYPE_PointerTott__IPv6ConfigurationExtension:
		return soap_out_PointerTott__IPv6ConfigurationExtension(soap, tag, id, (tt__IPv6ConfigurationExtension *const*)ptr, "tt:IPv6ConfigurationExtension");
	case SOAP_TYPE_PointerTott__PrefixedIPv6Address:
		return soap_out_PointerTott__PrefixedIPv6Address(soap, tag, id, (tt__PrefixedIPv6Address *const*)ptr, "tt:PrefixedIPv6Address");
	case SOAP_TYPE_PointerTott__PrefixedIPv4Address:
		return soap_out_PointerTott__PrefixedIPv4Address(soap, tag, id, (tt__PrefixedIPv4Address *const*)ptr, "tt:PrefixedIPv4Address");
	case SOAP_TYPE_PointerTott__IPv4Configuration:
		return soap_out_PointerTott__IPv4Configuration(soap, tag, id, (tt__IPv4Configuration *const*)ptr, "tt:IPv4Configuration");
	case SOAP_TYPE_PointerTott__IPv6Configuration:
		return soap_out_PointerTott__IPv6Configuration(soap, tag, id, (tt__IPv6Configuration *const*)ptr, "tt:IPv6Configuration");
	case SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting:
		return soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, tag, id, (tt__NetworkInterfaceConnectionSetting *const*)ptr, "tt:NetworkInterfaceConnectionSetting");
	case SOAP_TYPE_PointerTott__NetworkInterfaceExtension2:
		return soap_out_PointerTott__NetworkInterfaceExtension2(soap, tag, id, (tt__NetworkInterfaceExtension2 *const*)ptr, "tt:NetworkInterfaceExtension2");
	case SOAP_TYPE_PointerTott__Dot11Configuration:
		return soap_out_PointerTott__Dot11Configuration(soap, tag, id, (tt__Dot11Configuration *const*)ptr, "tt:Dot11Configuration");
	case SOAP_TYPE_PointerTott__Dot3Configuration:
		return soap_out_PointerTott__Dot3Configuration(soap, tag, id, (tt__Dot3Configuration *const*)ptr, "tt:Dot3Configuration");
	case SOAP_TYPE_PointerTott__LocationEntity:
		return soap_out_PointerTott__LocationEntity(soap, tag, id, (tt__LocationEntity *const*)ptr, "tt:LocationEntity");
	case SOAP_TYPE_PointerTotds__StorageConfigurationData:
		return soap_out_PointerTotds__StorageConfigurationData(soap, tag, id, (tds__StorageConfigurationData *const*)ptr, "tds:StorageConfigurationData");
	case SOAP_TYPE_PointerTotds__StorageConfiguration:
		return soap_out_PointerTotds__StorageConfiguration(soap, tag, id, (tds__StorageConfiguration *const*)ptr, "tds:StorageConfiguration");
	case SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse_Extension:
		return soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag, id, (_tds__GetSystemUrisResponse_Extension *const*)ptr, "tds:GetSystemUrisResponse-Extension");
	case SOAP_TYPE_PointerTott__SystemLogUriList:
		return soap_out_PointerTott__SystemLogUriList(soap, tag, id, (tt__SystemLogUriList *const*)ptr, "tt:SystemLogUriList");
	case SOAP_TYPE_PointerTott__Dot11AvailableNetworks:
		return soap_out_PointerTott__Dot11AvailableNetworks(soap, tag, id, (tt__Dot11AvailableNetworks *const*)ptr, "tt:Dot11AvailableNetworks");
	case SOAP_TYPE_PointerTott__Dot11Status:
		return soap_out_PointerTott__Dot11Status(soap, tag, id, (tt__Dot11Status *const*)ptr, "tt:Dot11Status");
	case SOAP_TYPE_PointerTott__Dot11Capabilities:
		return soap_out_PointerTott__Dot11Capabilities(soap, tag, id, (tt__Dot11Capabilities *const*)ptr, "tt:Dot11Capabilities");
	case SOAP_TYPE_PointerTott__AuxiliaryData:
		return soap_out_PointerTott__AuxiliaryData(soap, tag, id, (std::string *const*)ptr, "tt:AuxiliaryData");
	case SOAP_TYPE_PointerTott__RelayOutputSettings:
		return soap_out_PointerTott__RelayOutputSettings(soap, tag, id, (tt__RelayOutputSettings *const*)ptr, "tt:RelayOutputSettings");
	case SOAP_TYPE_PointerTott__RelayOutput:
		return soap_out_PointerTott__RelayOutput(soap, tag, id, (tt__RelayOutput *const*)ptr, "tt:RelayOutput");
	case SOAP_TYPE_PointerTott__Dot1XConfiguration:
		return soap_out_PointerTott__Dot1XConfiguration(soap, tag, id, (tt__Dot1XConfiguration *const*)ptr, "tt:Dot1XConfiguration");
	case SOAP_TYPE_PointerTott__CertificateInformation:
		return soap_out_PointerTott__CertificateInformation(soap, tag, id, (tt__CertificateInformation *const*)ptr, "tt:CertificateInformation");
	case SOAP_TYPE_PointerTott__CertificateWithPrivateKey:
		return soap_out_PointerTott__CertificateWithPrivateKey(soap, tag, id, (tt__CertificateWithPrivateKey *const*)ptr, "tt:CertificateWithPrivateKey");
	case SOAP_TYPE_PointerTott__CertificateStatus:
		return soap_out_PointerTott__CertificateStatus(soap, tag, id, (tt__CertificateStatus *const*)ptr, "tt:CertificateStatus");
	case SOAP_TYPE_PointerTott__Certificate:
		return soap_out_PointerTott__Certificate(soap, tag, id, (tt__Certificate *const*)ptr, "tt:Certificate");
	case SOAP_TYPE_PointerTodateTime:
		return soap_out_PointerTodateTime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToxsd__token:
		return soap_out_PointerToxsd__token(soap, tag, id, (std::string *const*)ptr, "xsd:token");
	case SOAP_TYPE_PointerTott__BinaryData:
		return soap_out_PointerTott__BinaryData(soap, tag, id, (tt__BinaryData *const*)ptr, "tt:BinaryData");
	case SOAP_TYPE_PointerTott__IPAddressFilter:
		return soap_out_PointerTott__IPAddressFilter(soap, tag, id, (tt__IPAddressFilter *const*)ptr, "tt:IPAddressFilter");
	case SOAP_TYPE_PointerTott__NetworkZeroConfiguration:
		return soap_out_PointerTott__NetworkZeroConfiguration(soap, tag, id, (tt__NetworkZeroConfiguration *const*)ptr, "tt:NetworkZeroConfiguration");
	case SOAP_TYPE_PointerTott__NetworkGateway:
		return soap_out_PointerTott__NetworkGateway(soap, tag, id, (tt__NetworkGateway *const*)ptr, "tt:NetworkGateway");
	case SOAP_TYPE_PointerTott__NetworkProtocol:
		return soap_out_PointerTott__NetworkProtocol(soap, tag, id, (tt__NetworkProtocol *const*)ptr, "tt:NetworkProtocol");
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfiguration:
		return soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, tag, id, (tt__NetworkInterfaceSetConfiguration *const*)ptr, "tt:NetworkInterfaceSetConfiguration");
	case SOAP_TYPE_PointerTott__NetworkInterface:
		return soap_out_PointerTott__NetworkInterface(soap, tag, id, (tt__NetworkInterface *const*)ptr, "tt:NetworkInterface");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (std::string *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTott__DNSName:
		return soap_out_PointerTott__DNSName(soap, tag, id, (std::string *const*)ptr, "tt:DNSName");
	case SOAP_TYPE_PointerTott__DynamicDNSInformation:
		return soap_out_PointerTott__DynamicDNSInformation(soap, tag, id, (tt__DynamicDNSInformation *const*)ptr, "tt:DynamicDNSInformation");
	case SOAP_TYPE_PointerTott__NTPInformation:
		return soap_out_PointerTott__NTPInformation(soap, tag, id, (tt__NTPInformation *const*)ptr, "tt:NTPInformation");
	case SOAP_TYPE_PointerTott__IPAddress:
		return soap_out_PointerTott__IPAddress(soap, tag, id, (tt__IPAddress *const*)ptr, "tt:IPAddress");
	case SOAP_TYPE_PointerTott__DNSInformation:
		return soap_out_PointerTott__DNSInformation(soap, tag, id, (tt__DNSInformation *const*)ptr, "tt:DNSInformation");
	case SOAP_TYPE_PointerTott__HostnameInformation:
		return soap_out_PointerTott__HostnameInformation(soap, tag, id, (tt__HostnameInformation *const*)ptr, "tt:HostnameInformation");
	case SOAP_TYPE_PointerTott__Capabilities:
		return soap_out_PointerTott__Capabilities(soap, tag, id, (tt__Capabilities *const*)ptr, "tt:Capabilities");
	case SOAP_TYPE_PointerTott__IntRange:
		return soap_out_PointerTott__IntRange(soap, tag, id, (tt__IntRange *const*)ptr, "tt:IntRange");
	case SOAP_TYPE_PointerTott__User:
		return soap_out_PointerTott__User(soap, tag, id, (tt__User *const*)ptr, "tt:User");
	case SOAP_TYPE_PointerTott__RemoteUser:
		return soap_out_PointerTott__RemoteUser(soap, tag, id, (tt__RemoteUser *const*)ptr, "tt:RemoteUser");
	case SOAP_TYPE_PointerTott__NetworkHost:
		return soap_out_PointerTott__NetworkHost(soap, tag, id, (tt__NetworkHost *const*)ptr, "tt:NetworkHost");
	case SOAP_TYPE_PointerTott__Scope:
		return soap_out_PointerTott__Scope(soap, tag, id, (tt__Scope *const*)ptr, "tt:Scope");
	case SOAP_TYPE_PointerTott__SystemLog:
		return soap_out_PointerTott__SystemLog(soap, tag, id, (tt__SystemLog *const*)ptr, "tt:SystemLog");
	case SOAP_TYPE_PointerTott__SupportInformation:
		return soap_out_PointerTott__SupportInformation(soap, tag, id, (tt__SupportInformation *const*)ptr, "tt:SupportInformation");
	case SOAP_TYPE_PointerTott__BackupFile:
		return soap_out_PointerTott__BackupFile(soap, tag, id, (tt__BackupFile *const*)ptr, "tt:BackupFile");
	case SOAP_TYPE_PointerTott__AttachmentData:
		return soap_out_PointerTott__AttachmentData(soap, tag, id, (tt__AttachmentData *const*)ptr, "tt:AttachmentData");
	case SOAP_TYPE_PointerTott__SystemDateTime:
		return soap_out_PointerTott__SystemDateTime(soap, tag, id, (tt__SystemDateTime *const*)ptr, "tt:SystemDateTime");
	case SOAP_TYPE_PointerTott__DateTime:
		return soap_out_PointerTott__DateTime(soap, tag, id, (tt__DateTime *const*)ptr, "tt:DateTime");
	case SOAP_TYPE_PointerTott__TimeZone:
		return soap_out_PointerTott__TimeZone(soap, tag, id, (tt__TimeZone *const*)ptr, "tt:TimeZone");
	case SOAP_TYPE_PointerTotds__DeviceServiceCapabilities:
		return soap_out_PointerTotds__DeviceServiceCapabilities(soap, tag, id, (tds__DeviceServiceCapabilities *const*)ptr, "tds:DeviceServiceCapabilities");
	case SOAP_TYPE_PointerTotds__Service:
		return soap_out_PointerTotds__Service(soap, tag, id, (tds__Service *const*)ptr, "tds:Service");
	case SOAP_TYPE_PointerTo_tds__StorageConfigurationData_Extension:
		return soap_out_PointerTo_tds__StorageConfigurationData_Extension(soap, tag, id, (_tds__StorageConfigurationData_Extension *const*)ptr, "tds:StorageConfigurationData-Extension");
	case SOAP_TYPE_PointerTotds__UserCredential:
		return soap_out_PointerTotds__UserCredential(soap, tag, id, (tds__UserCredential *const*)ptr, "tds:UserCredential");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTo_tds__UserCredential_Extension:
		return soap_out_PointerTo_tds__UserCredential_Extension(soap, tag, id, (_tds__UserCredential_Extension *const*)ptr, "tds:UserCredential-Extension");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTott__StringAttrList:
		return soap_out_PointerTott__StringAttrList(soap, tag, id, (std::string *const*)ptr, "tt:StringAttrList");
	case SOAP_TYPE_PointerTott__StringList:
		return soap_out_PointerTott__StringList(soap, tag, id, (std::string *const*)ptr, "tt:StringList");
	case SOAP_TYPE_PointerTott__IntList:
		return soap_out_PointerTott__IntList(soap, tag, id, (std::string *const*)ptr, "tt:IntList");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTotds__MiscCapabilities:
		return soap_out_PointerTotds__MiscCapabilities(soap, tag, id, (tds__MiscCapabilities *const*)ptr, "tds:MiscCapabilities");
	case SOAP_TYPE_PointerTotds__SystemCapabilities:
		return soap_out_PointerTotds__SystemCapabilities(soap, tag, id, (tds__SystemCapabilities *const*)ptr, "tds:SystemCapabilities");
	case SOAP_TYPE_PointerTotds__SecurityCapabilities:
		return soap_out_PointerTotds__SecurityCapabilities(soap, tag, id, (tds__SecurityCapabilities *const*)ptr, "tds:SecurityCapabilities");
	case SOAP_TYPE_PointerTotds__NetworkCapabilities:
		return soap_out_PointerTotds__NetworkCapabilities(soap, tag, id, (tds__NetworkCapabilities *const*)ptr, "tds:NetworkCapabilities");
	case SOAP_TYPE_PointerTott__OnvifVersion:
		return soap_out_PointerTott__OnvifVersion(soap, tag, id, (tt__OnvifVersion *const*)ptr, "tt:OnvifVersion");
	case SOAP_TYPE_PointerTo_tds__Service_Capabilities:
		return soap_out_PointerTo_tds__Service_Capabilities(soap, tag, id, (_tds__Service_Capabilities *const*)ptr, "tds:Service-Capabilities");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_out_PointerTochan__ChannelInstanceType(soap, tag, id, (struct chan__ChannelInstanceType *const*)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__tds__GetSystemUrisResponse_Extension:
		((_tds__GetSystemUrisResponse_Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__StorageConfigurationData_Extension:
		((_tds__StorageConfigurationData_Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__UserCredential_Extension:
		((_tds__UserCredential_Extension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__Service_Capabilities:
		((_tds__Service_Capabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		soap_serialize_tt__ReferenceToken(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__AuxiliaryData:
		soap_serialize_tt__AuxiliaryData(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__Dot11PSKPassphrase:
		soap_serialize_tt__Dot11PSKPassphrase(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__Dot11PSK:
		soap_serialize_tt__Dot11PSK(soap, (const xsd__hexBinary *)ptr);
		break;
	case SOAP_TYPE_tt__Dot11SSIDType:
		soap_serialize_tt__Dot11SSIDType(soap, (const xsd__hexBinary *)ptr);
		break;
	case SOAP_TYPE_tt__DNSName:
		soap_serialize_tt__DNSName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__HwAddress:
		soap_serialize_tt__HwAddress(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__IPv6Address:
		soap_serialize_tt__IPv6Address(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__IPv4Address:
		soap_serialize_tt__IPv4Address(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceConfigPriority:
		soap_serialize_tt__NetworkInterfaceConfigPriority(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__Name:
		soap_serialize_tt__Name(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__StringList:
		soap_serialize_tt__StringList(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__StringAttrList:
		soap_serialize_tt__StringAttrList(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__IntList:
		soap_serialize_tt__IntList(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__LocationEntity:
		((tt__LocationEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__LocalOrientation:
		((tt__LocalOrientation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__LocalLocation:
		((tt__LocalLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__GeoOrientation:
		((tt__GeoOrientation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__GeoLocation:
		((tt__GeoLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IntRange:
		((tt__IntRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DateTimeRange:
		((tt__DateTimeRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RelayOutput:
		((tt__RelayOutput *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RelayOutputSettings:
		((tt__RelayOutputSettings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__TLSConfiguration:
		((tt__TLSConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EapMethodExtension:
		((tt__EapMethodExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EAPMethodConfiguration:
		((tt__EAPMethodConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot1XConfigurationExtension:
		((tt__Dot1XConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot1XConfiguration:
		((tt__Dot1XConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CertificateInformationExtension:
		((tt__CertificateInformationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CertificateUsage:
		((tt__CertificateUsage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CertificateInformation:
		((tt__CertificateInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CertificateWithPrivateKey:
		((tt__CertificateWithPrivateKey *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CertificateStatus:
		((tt__CertificateStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Certificate:
		((tt__Certificate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__UserExtension:
		((tt__UserExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__User:
		((tt__User *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RemoteUser:
		((tt__RemoteUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__TimeZone:
		((tt__TimeZone *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Time:
		((tt__Time *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Date:
		((tt__Date *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DateTime:
		((tt__DateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		((tt__SystemDateTimeExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemDateTime:
		((tt__SystemDateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemLogUri:
		((tt__SystemLogUri *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemLogUriList:
		((tt__SystemLogUriList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BackupFile:
		((tt__BackupFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AttachmentData:
		((tt__AttachmentData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__BinaryData:
		((tt__BinaryData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SupportInformation:
		((tt__SupportInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemLog:
		((tt__SystemLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AnalyticsDeviceExtension:
		((tt__AnalyticsDeviceExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AnalyticsDeviceCapabilities:
		((tt__AnalyticsDeviceCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ReceiverCapabilities:
		((tt__ReceiverCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ReplayCapabilities:
		((tt__ReplayCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SearchCapabilities:
		((tt__SearchCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RecordingCapabilities:
		((tt__RecordingCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DisplayCapabilities:
		((tt__DisplayCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DeviceIOCapabilities:
		((tt__DeviceIOCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZCapabilities:
		((tt__PTZCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ImagingCapabilities:
		((tt__ImagingCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__OnvifVersion:
		((tt__OnvifVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemCapabilitiesExtension2:
		((tt__SystemCapabilitiesExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		((tt__SystemCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SystemCapabilities:
		((tt__SystemCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension2:
		((tt__SecurityCapabilitiesExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		((tt__SecurityCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__SecurityCapabilities:
		((tt__SecurityCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension2:
		((tt__NetworkCapabilitiesExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		((tt__NetworkCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkCapabilities:
		((tt__NetworkCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ProfileCapabilities:
		((tt__ProfileCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		((tt__RealTimeStreamingCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		((tt__RealTimeStreamingCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		((tt__MediaCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__MediaCapabilities:
		((tt__MediaCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IOCapabilitiesExtension2:
		((tt__IOCapabilitiesExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		((tt__IOCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IOCapabilities:
		((tt__IOCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EventCapabilities:
		((tt__EventCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		((tt__DeviceCapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DeviceCapabilities:
		((tt__DeviceCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		((tt__AnalyticsCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CapabilitiesExtension2:
		((tt__CapabilitiesExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__CapabilitiesExtension:
		((tt__CapabilitiesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Capabilities:
		((tt__Capabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot11AvailableNetworksExtension:
		((tt__Dot11AvailableNetworksExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot11AvailableNetworks:
		((tt__Dot11AvailableNetworks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot11Status:
		((tt__Dot11Status *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot11Capabilities:
		((tt__Dot11Capabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2:
		((tt__NetworkInterfaceSetConfigurationExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot11PSKSetExtension:
		((tt__Dot11PSKSetExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot11PSKSet:
		((tt__Dot11PSKSet *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot11SecurityConfigurationExtension:
		((tt__Dot11SecurityConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot11SecurityConfiguration:
		((tt__Dot11SecurityConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot11Configuration:
		((tt__Dot11Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		((tt__IPAddressFilterExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPAddressFilter:
		((tt__IPAddressFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension2:
		((tt__NetworkZeroConfigurationExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		((tt__NetworkZeroConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		((tt__NetworkZeroConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkGateway:
		((tt__NetworkGateway *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		((tt__IPv4NetworkInterfaceSetConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		((tt__IPv6NetworkInterfaceSetConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		((tt__NetworkInterfaceSetConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		((tt__NetworkInterfaceSetConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		((tt__DynamicDNSInformationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DynamicDNSInformation:
		((tt__DynamicDNSInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NTPInformationExtension:
		((tt__NTPInformationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NTPInformation:
		((tt__NTPInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DNSInformationExtension:
		((tt__DNSInformationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DNSInformation:
		((tt__DNSInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__HostnameInformationExtension:
		((tt__HostnameInformationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__HostnameInformation:
		((tt__HostnameInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		((tt__PrefixedIPv6Address *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		((tt__PrefixedIPv4Address *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPAddress:
		((tt__IPAddress *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkHostExtension:
		((tt__NetworkHostExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkHost:
		((tt__NetworkHost *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		((tt__NetworkProtocolExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkProtocol:
		((tt__NetworkProtocol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		((tt__IPv6ConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv6Configuration:
		((tt__IPv6Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv4Configuration:
		((tt__IPv4Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		((tt__IPv4NetworkInterface *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		((tt__IPv6NetworkInterface *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		((tt__NetworkInterfaceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		((tt__NetworkInterfaceConnectionSetting *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		((tt__NetworkInterfaceLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceExtension2:
		((tt__NetworkInterfaceExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Dot3Configuration:
		((tt__Dot3Configuration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		((tt__NetworkInterfaceExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__NetworkInterface:
		((tt__NetworkInterface *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Scope:
		((tt__Scope *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DeviceEntity:
		((tt__DeviceEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__DeleteGeoLocationResponse:
		((_tds__DeleteGeoLocationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__DeleteGeoLocation:
		((_tds__DeleteGeoLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetGeoLocationResponse:
		((_tds__SetGeoLocationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetGeoLocation:
		((_tds__SetGeoLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetGeoLocationResponse:
		((_tds__GetGeoLocationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetGeoLocation:
		((_tds__GetGeoLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__DeleteStorageConfigurationResponse:
		((_tds__DeleteStorageConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__DeleteStorageConfiguration:
		((_tds__DeleteStorageConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetStorageConfigurationResponse:
		((_tds__SetStorageConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetStorageConfiguration:
		((_tds__SetStorageConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetStorageConfigurationResponse:
		((_tds__GetStorageConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetStorageConfiguration:
		((_tds__GetStorageConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__CreateStorageConfigurationResponse:
		((_tds__CreateStorageConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__CreateStorageConfiguration:
		((_tds__CreateStorageConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetStorageConfigurationsResponse:
		((_tds__GetStorageConfigurationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetStorageConfigurations:
		((_tds__GetStorageConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetHashingAlgorithmResponse:
		((_tds__SetHashingAlgorithmResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetHashingAlgorithm:
		((_tds__SetHashingAlgorithm *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__StartSystemRestoreResponse:
		((_tds__StartSystemRestoreResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__StartSystemRestore:
		((_tds__StartSystemRestore *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__StartFirmwareUpgradeResponse:
		((_tds__StartFirmwareUpgradeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__StartFirmwareUpgrade:
		((_tds__StartFirmwareUpgrade *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetSystemUrisResponse:
		((_tds__GetSystemUrisResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetSystemUris:
		((_tds__GetSystemUris *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse:
		((_tds__ScanAvailableDot11NetworksResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__ScanAvailableDot11Networks:
		((_tds__ScanAvailableDot11Networks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDot11StatusResponse:
		((_tds__GetDot11StatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDot11Status:
		((_tds__GetDot11Status *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDot11CapabilitiesResponse:
		((_tds__GetDot11CapabilitiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDot11Capabilities:
		((_tds__GetDot11Capabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SendAuxiliaryCommandResponse:
		((_tds__SendAuxiliaryCommandResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SendAuxiliaryCommand:
		((_tds__SendAuxiliaryCommand *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetRelayOutputStateResponse:
		((_tds__SetRelayOutputStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetRelayOutputState:
		((_tds__SetRelayOutputState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetRelayOutputSettingsResponse:
		((_tds__SetRelayOutputSettingsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetRelayOutputSettings:
		((_tds__SetRelayOutputSettings *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetRelayOutputsResponse:
		((_tds__GetRelayOutputsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetRelayOutputs:
		((_tds__GetRelayOutputs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__DeleteDot1XConfigurationResponse:
		((_tds__DeleteDot1XConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__DeleteDot1XConfiguration:
		((_tds__DeleteDot1XConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDot1XConfigurationsResponse:
		((_tds__GetDot1XConfigurationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDot1XConfigurations:
		((_tds__GetDot1XConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDot1XConfigurationResponse:
		((_tds__GetDot1XConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDot1XConfiguration:
		((_tds__GetDot1XConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetDot1XConfigurationResponse:
		((_tds__SetDot1XConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetDot1XConfiguration:
		((_tds__SetDot1XConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__CreateDot1XConfigurationResponse:
		((_tds__CreateDot1XConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__CreateDot1XConfiguration:
		((_tds__CreateDot1XConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__LoadCACertificatesResponse:
		((_tds__LoadCACertificatesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__LoadCACertificates:
		((_tds__LoadCACertificates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetCertificateInformationResponse:
		((_tds__GetCertificateInformationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetCertificateInformation:
		((_tds__GetCertificateInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse:
		((_tds__LoadCertificateWithPrivateKeyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__LoadCertificateWithPrivateKey:
		((_tds__LoadCertificateWithPrivateKey *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetCACertificatesResponse:
		((_tds__GetCACertificatesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetCACertificates:
		((_tds__GetCACertificates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetClientCertificateModeResponse:
		((_tds__SetClientCertificateModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetClientCertificateMode:
		((_tds__SetClientCertificateMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetClientCertificateModeResponse:
		((_tds__GetClientCertificateModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetClientCertificateMode:
		((_tds__GetClientCertificateMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__LoadCertificatesResponse:
		((_tds__LoadCertificatesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__LoadCertificates:
		((_tds__LoadCertificates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetPkcs10RequestResponse:
		((_tds__GetPkcs10RequestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetPkcs10Request:
		((_tds__GetPkcs10Request *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__DeleteCertificatesResponse:
		((_tds__DeleteCertificatesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__DeleteCertificates:
		((_tds__DeleteCertificates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetCertificatesStatusResponse:
		((_tds__SetCertificatesStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetCertificatesStatus:
		((_tds__SetCertificatesStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetCertificatesStatusResponse:
		((_tds__GetCertificatesStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetCertificatesStatus:
		((_tds__GetCertificatesStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetCertificatesResponse:
		((_tds__GetCertificatesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetCertificates:
		((_tds__GetCertificates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__CreateCertificateResponse:
		((_tds__CreateCertificateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__CreateCertificate:
		((_tds__CreateCertificate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetAccessPolicyResponse:
		((_tds__SetAccessPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetAccessPolicy:
		((_tds__SetAccessPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetAccessPolicyResponse:
		((_tds__GetAccessPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetAccessPolicy:
		((_tds__GetAccessPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__RemoveIPAddressFilterResponse:
		((_tds__RemoveIPAddressFilterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__RemoveIPAddressFilter:
		((_tds__RemoveIPAddressFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__AddIPAddressFilterResponse:
		((_tds__AddIPAddressFilterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__AddIPAddressFilter:
		((_tds__AddIPAddressFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetIPAddressFilterResponse:
		((_tds__SetIPAddressFilterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetIPAddressFilter:
		((_tds__SetIPAddressFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetIPAddressFilterResponse:
		((_tds__GetIPAddressFilterResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetIPAddressFilter:
		((_tds__GetIPAddressFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetZeroConfigurationResponse:
		((_tds__SetZeroConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetZeroConfiguration:
		((_tds__SetZeroConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetZeroConfigurationResponse:
		((_tds__GetZeroConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetZeroConfiguration:
		((_tds__GetZeroConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse:
		((_tds__SetNetworkDefaultGatewayResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetNetworkDefaultGateway:
		((_tds__SetNetworkDefaultGateway *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse:
		((_tds__GetNetworkDefaultGatewayResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetNetworkDefaultGateway:
		((_tds__GetNetworkDefaultGateway *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetNetworkProtocolsResponse:
		((_tds__SetNetworkProtocolsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetNetworkProtocols:
		((_tds__SetNetworkProtocols *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetNetworkProtocolsResponse:
		((_tds__GetNetworkProtocolsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetNetworkProtocols:
		((_tds__GetNetworkProtocols *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetNetworkInterfacesResponse:
		((_tds__SetNetworkInterfacesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetNetworkInterfaces:
		((_tds__SetNetworkInterfaces *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetNetworkInterfacesResponse:
		((_tds__GetNetworkInterfacesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetNetworkInterfaces:
		((_tds__GetNetworkInterfaces *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetDynamicDNSResponse:
		((_tds__SetDynamicDNSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetDynamicDNS:
		((_tds__SetDynamicDNS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDynamicDNSResponse:
		((_tds__GetDynamicDNSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDynamicDNS:
		((_tds__GetDynamicDNS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetNTPResponse:
		((_tds__SetNTPResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetNTP:
		((_tds__SetNTP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetNTPResponse:
		((_tds__GetNTPResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetNTP:
		((_tds__GetNTP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetDNSResponse:
		((_tds__SetDNSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetDNS:
		((_tds__SetDNS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDNSResponse:
		((_tds__GetDNSResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDNS:
		((_tds__GetDNS *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetHostnameFromDHCPResponse:
		((_tds__SetHostnameFromDHCPResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetHostnameFromDHCP:
		((_tds__SetHostnameFromDHCP *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetHostnameResponse:
		((_tds__SetHostnameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetHostname:
		((_tds__SetHostname *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetHostnameResponse:
		((_tds__GetHostnameResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetHostname:
		((_tds__GetHostname *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetCapabilitiesResponse:
		((_tds__GetCapabilitiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetCapabilities:
		((_tds__GetCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse:
		((_tds__SetAuthFailureWarningConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetAuthFailureWarningConfiguration:
		((_tds__SetAuthFailureWarningConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse:
		((_tds__GetAuthFailureWarningConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningConfiguration:
		((_tds__GetAuthFailureWarningConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse:
		((_tds__GetAuthFailureWarningOptionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningOptions:
		((_tds__GetAuthFailureWarningOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse:
		((_tds__SetPasswordHistoryConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetPasswordHistoryConfiguration:
		((_tds__SetPasswordHistoryConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse:
		((_tds__GetPasswordHistoryConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetPasswordHistoryConfiguration:
		((_tds__GetPasswordHistoryConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse:
		((_tds__SetPasswordComplexityConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetPasswordComplexityConfiguration:
		((_tds__SetPasswordComplexityConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse:
		((_tds__GetPasswordComplexityConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityConfiguration:
		((_tds__GetPasswordComplexityConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse:
		((_tds__GetPasswordComplexityOptionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityOptions:
		((_tds__GetPasswordComplexityOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetWsdlUrlResponse:
		((_tds__GetWsdlUrlResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetWsdlUrl:
		((_tds__GetWsdlUrl *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetUserResponse:
		((_tds__SetUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetUser:
		((_tds__SetUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__DeleteUsersResponse:
		((_tds__DeleteUsersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__DeleteUsers:
		((_tds__DeleteUsers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__CreateUsersResponse:
		((_tds__CreateUsersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__CreateUsers:
		((_tds__CreateUsers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetUsersResponse:
		((_tds__GetUsersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetUsers:
		((_tds__GetUsers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetRemoteUserResponse:
		((_tds__SetRemoteUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetRemoteUser:
		((_tds__SetRemoteUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetRemoteUserResponse:
		((_tds__GetRemoteUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetRemoteUser:
		((_tds__GetRemoteUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetEndpointReferenceResponse:
		((_tds__GetEndpointReferenceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetEndpointReference:
		((_tds__GetEndpointReference *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetDPAddressesResponse:
		((_tds__SetDPAddressesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetDPAddresses:
		((_tds__SetDPAddresses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDPAddressesResponse:
		((_tds__GetDPAddressesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDPAddresses:
		((_tds__GetDPAddresses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse:
		((_tds__SetRemoteDiscoveryModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetRemoteDiscoveryMode:
		((_tds__SetRemoteDiscoveryMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse:
		((_tds__GetRemoteDiscoveryModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetRemoteDiscoveryMode:
		((_tds__GetRemoteDiscoveryMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetDiscoveryModeResponse:
		((_tds__SetDiscoveryModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetDiscoveryMode:
		((_tds__SetDiscoveryMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDiscoveryModeResponse:
		((_tds__GetDiscoveryModeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDiscoveryMode:
		((_tds__GetDiscoveryMode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__RemoveScopesResponse:
		((_tds__RemoveScopesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__RemoveScopes:
		((_tds__RemoveScopes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__AddScopesResponse:
		((_tds__AddScopesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__AddScopes:
		((_tds__AddScopes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetScopesResponse:
		((_tds__SetScopesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetScopes:
		((_tds__SetScopes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetScopesResponse:
		((_tds__GetScopesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetScopes:
		((_tds__GetScopes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetSystemLogResponse:
		((_tds__GetSystemLogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetSystemLog:
		((_tds__GetSystemLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetSystemSupportInformationResponse:
		((_tds__GetSystemSupportInformationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetSystemSupportInformation:
		((_tds__GetSystemSupportInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetSystemBackupResponse:
		((_tds__GetSystemBackupResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetSystemBackup:
		((_tds__GetSystemBackup *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__RestoreSystemResponse:
		((_tds__RestoreSystemResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__RestoreSystem:
		((_tds__RestoreSystem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SystemRebootResponse:
		((_tds__SystemRebootResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SystemReboot:
		((_tds__SystemReboot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__UpgradeSystemFirmwareResponse:
		((_tds__UpgradeSystemFirmwareResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__UpgradeSystemFirmware:
		((_tds__UpgradeSystemFirmware *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetSystemFactoryDefaultResponse:
		((_tds__SetSystemFactoryDefaultResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetSystemFactoryDefault:
		((_tds__SetSystemFactoryDefault *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetSystemDateAndTimeResponse:
		((_tds__GetSystemDateAndTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetSystemDateAndTime:
		((_tds__GetSystemDateAndTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetSystemDateAndTimeResponse:
		((_tds__SetSystemDateAndTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__SetSystemDateAndTime:
		((_tds__SetSystemDateAndTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDeviceInformationResponse:
		((_tds__GetDeviceInformationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetDeviceInformation:
		((_tds__GetDeviceInformation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetServiceCapabilitiesResponse:
		((_tds__GetServiceCapabilitiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetServiceCapabilities:
		((_tds__GetServiceCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetServicesResponse:
		((_tds__GetServicesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tds__GetServices:
		((_tds__GetServices *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tds__StorageConfiguration:
		((tds__StorageConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tds__StorageConfigurationData:
		((tds__StorageConfigurationData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tds__UserCredential:
		((tds__UserCredential *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tds__MiscCapabilities:
		((tds__MiscCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tds__SystemCapabilities:
		((tds__SystemCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tds__SecurityCapabilities:
		((tds__SecurityCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tds__NetworkCapabilities:
		((tds__NetworkCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tds__DeviceServiceCapabilities:
		((tds__DeviceServiceCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tds__Service:
		((tds__Service *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize__xml__lang(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_xsd__token(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_xsd__duration(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		soap_serialize_xsd__anySimpleType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_xsd__NCName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		((xsd__hexBinary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___tds__SetHashingAlgorithm:
		soap_serialize___tds__SetHashingAlgorithm(soap, (const struct __tds__SetHashingAlgorithm *)ptr);
		break;
	case SOAP_TYPE___tds__DeleteGeoLocation:
		soap_serialize___tds__DeleteGeoLocation(soap, (const struct __tds__DeleteGeoLocation *)ptr);
		break;
	case SOAP_TYPE___tds__SetGeoLocation:
		soap_serialize___tds__SetGeoLocation(soap, (const struct __tds__SetGeoLocation *)ptr);
		break;
	case SOAP_TYPE___tds__GetGeoLocation:
		soap_serialize___tds__GetGeoLocation(soap, (const struct __tds__GetGeoLocation *)ptr);
		break;
	case SOAP_TYPE___tds__DeleteStorageConfiguration:
		soap_serialize___tds__DeleteStorageConfiguration(soap, (const struct __tds__DeleteStorageConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__SetStorageConfiguration:
		soap_serialize___tds__SetStorageConfiguration(soap, (const struct __tds__SetStorageConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__GetStorageConfiguration:
		soap_serialize___tds__GetStorageConfiguration(soap, (const struct __tds__GetStorageConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__CreateStorageConfiguration:
		soap_serialize___tds__CreateStorageConfiguration(soap, (const struct __tds__CreateStorageConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__GetStorageConfigurations:
		soap_serialize___tds__GetStorageConfigurations(soap, (const struct __tds__GetStorageConfigurations *)ptr);
		break;
	case SOAP_TYPE___tds__StartSystemRestore:
		soap_serialize___tds__StartSystemRestore(soap, (const struct __tds__StartSystemRestore *)ptr);
		break;
	case SOAP_TYPE___tds__StartFirmwareUpgrade:
		soap_serialize___tds__StartFirmwareUpgrade(soap, (const struct __tds__StartFirmwareUpgrade *)ptr);
		break;
	case SOAP_TYPE___tds__GetSystemUris:
		soap_serialize___tds__GetSystemUris(soap, (const struct __tds__GetSystemUris *)ptr);
		break;
	case SOAP_TYPE___tds__ScanAvailableDot11Networks:
		soap_serialize___tds__ScanAvailableDot11Networks(soap, (const struct __tds__ScanAvailableDot11Networks *)ptr);
		break;
	case SOAP_TYPE___tds__GetDot11Status:
		soap_serialize___tds__GetDot11Status(soap, (const struct __tds__GetDot11Status *)ptr);
		break;
	case SOAP_TYPE___tds__GetDot11Capabilities:
		soap_serialize___tds__GetDot11Capabilities(soap, (const struct __tds__GetDot11Capabilities *)ptr);
		break;
	case SOAP_TYPE___tds__DeleteDot1XConfiguration:
		soap_serialize___tds__DeleteDot1XConfiguration(soap, (const struct __tds__DeleteDot1XConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__GetDot1XConfigurations:
		soap_serialize___tds__GetDot1XConfigurations(soap, (const struct __tds__GetDot1XConfigurations *)ptr);
		break;
	case SOAP_TYPE___tds__GetDot1XConfiguration:
		soap_serialize___tds__GetDot1XConfiguration(soap, (const struct __tds__GetDot1XConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__SetDot1XConfiguration:
		soap_serialize___tds__SetDot1XConfiguration(soap, (const struct __tds__SetDot1XConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__CreateDot1XConfiguration:
		soap_serialize___tds__CreateDot1XConfiguration(soap, (const struct __tds__CreateDot1XConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__LoadCACertificates:
		soap_serialize___tds__LoadCACertificates(soap, (const struct __tds__LoadCACertificates *)ptr);
		break;
	case SOAP_TYPE___tds__GetCertificateInformation:
		soap_serialize___tds__GetCertificateInformation(soap, (const struct __tds__GetCertificateInformation *)ptr);
		break;
	case SOAP_TYPE___tds__LoadCertificateWithPrivateKey:
		soap_serialize___tds__LoadCertificateWithPrivateKey(soap, (const struct __tds__LoadCertificateWithPrivateKey *)ptr);
		break;
	case SOAP_TYPE___tds__GetCACertificates:
		soap_serialize___tds__GetCACertificates(soap, (const struct __tds__GetCACertificates *)ptr);
		break;
	case SOAP_TYPE___tds__SendAuxiliaryCommand:
		soap_serialize___tds__SendAuxiliaryCommand(soap, (const struct __tds__SendAuxiliaryCommand *)ptr);
		break;
	case SOAP_TYPE___tds__SetRelayOutputState:
		soap_serialize___tds__SetRelayOutputState(soap, (const struct __tds__SetRelayOutputState *)ptr);
		break;
	case SOAP_TYPE___tds__SetRelayOutputSettings:
		soap_serialize___tds__SetRelayOutputSettings(soap, (const struct __tds__SetRelayOutputSettings *)ptr);
		break;
	case SOAP_TYPE___tds__GetRelayOutputs:
		soap_serialize___tds__GetRelayOutputs(soap, (const struct __tds__GetRelayOutputs *)ptr);
		break;
	case SOAP_TYPE___tds__SetClientCertificateMode:
		soap_serialize___tds__SetClientCertificateMode(soap, (const struct __tds__SetClientCertificateMode *)ptr);
		break;
	case SOAP_TYPE___tds__GetClientCertificateMode:
		soap_serialize___tds__GetClientCertificateMode(soap, (const struct __tds__GetClientCertificateMode *)ptr);
		break;
	case SOAP_TYPE___tds__LoadCertificates:
		soap_serialize___tds__LoadCertificates(soap, (const struct __tds__LoadCertificates *)ptr);
		break;
	case SOAP_TYPE___tds__GetPkcs10Request:
		soap_serialize___tds__GetPkcs10Request(soap, (const struct __tds__GetPkcs10Request *)ptr);
		break;
	case SOAP_TYPE___tds__DeleteCertificates:
		soap_serialize___tds__DeleteCertificates(soap, (const struct __tds__DeleteCertificates *)ptr);
		break;
	case SOAP_TYPE___tds__SetCertificatesStatus:
		soap_serialize___tds__SetCertificatesStatus(soap, (const struct __tds__SetCertificatesStatus *)ptr);
		break;
	case SOAP_TYPE___tds__GetCertificatesStatus:
		soap_serialize___tds__GetCertificatesStatus(soap, (const struct __tds__GetCertificatesStatus *)ptr);
		break;
	case SOAP_TYPE___tds__GetCertificates:
		soap_serialize___tds__GetCertificates(soap, (const struct __tds__GetCertificates *)ptr);
		break;
	case SOAP_TYPE___tds__CreateCertificate:
		soap_serialize___tds__CreateCertificate(soap, (const struct __tds__CreateCertificate *)ptr);
		break;
	case SOAP_TYPE___tds__SetAccessPolicy:
		soap_serialize___tds__SetAccessPolicy(soap, (const struct __tds__SetAccessPolicy *)ptr);
		break;
	case SOAP_TYPE___tds__GetAccessPolicy:
		soap_serialize___tds__GetAccessPolicy(soap, (const struct __tds__GetAccessPolicy *)ptr);
		break;
	case SOAP_TYPE___tds__RemoveIPAddressFilter:
		soap_serialize___tds__RemoveIPAddressFilter(soap, (const struct __tds__RemoveIPAddressFilter *)ptr);
		break;
	case SOAP_TYPE___tds__AddIPAddressFilter:
		soap_serialize___tds__AddIPAddressFilter(soap, (const struct __tds__AddIPAddressFilter *)ptr);
		break;
	case SOAP_TYPE___tds__SetIPAddressFilter:
		soap_serialize___tds__SetIPAddressFilter(soap, (const struct __tds__SetIPAddressFilter *)ptr);
		break;
	case SOAP_TYPE___tds__GetIPAddressFilter:
		soap_serialize___tds__GetIPAddressFilter(soap, (const struct __tds__GetIPAddressFilter *)ptr);
		break;
	case SOAP_TYPE___tds__SetZeroConfiguration:
		soap_serialize___tds__SetZeroConfiguration(soap, (const struct __tds__SetZeroConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__GetZeroConfiguration:
		soap_serialize___tds__GetZeroConfiguration(soap, (const struct __tds__GetZeroConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__SetNetworkDefaultGateway:
		soap_serialize___tds__SetNetworkDefaultGateway(soap, (const struct __tds__SetNetworkDefaultGateway *)ptr);
		break;
	case SOAP_TYPE___tds__GetNetworkDefaultGateway:
		soap_serialize___tds__GetNetworkDefaultGateway(soap, (const struct __tds__GetNetworkDefaultGateway *)ptr);
		break;
	case SOAP_TYPE___tds__SetNetworkProtocols:
		soap_serialize___tds__SetNetworkProtocols(soap, (const struct __tds__SetNetworkProtocols *)ptr);
		break;
	case SOAP_TYPE___tds__GetNetworkProtocols:
		soap_serialize___tds__GetNetworkProtocols(soap, (const struct __tds__GetNetworkProtocols *)ptr);
		break;
	case SOAP_TYPE___tds__SetNetworkInterfaces:
		soap_serialize___tds__SetNetworkInterfaces(soap, (const struct __tds__SetNetworkInterfaces *)ptr);
		break;
	case SOAP_TYPE___tds__GetNetworkInterfaces:
		soap_serialize___tds__GetNetworkInterfaces(soap, (const struct __tds__GetNetworkInterfaces *)ptr);
		break;
	case SOAP_TYPE___tds__SetDynamicDNS:
		soap_serialize___tds__SetDynamicDNS(soap, (const struct __tds__SetDynamicDNS *)ptr);
		break;
	case SOAP_TYPE___tds__GetDynamicDNS:
		soap_serialize___tds__GetDynamicDNS(soap, (const struct __tds__GetDynamicDNS *)ptr);
		break;
	case SOAP_TYPE___tds__SetNTP:
		soap_serialize___tds__SetNTP(soap, (const struct __tds__SetNTP *)ptr);
		break;
	case SOAP_TYPE___tds__GetNTP:
		soap_serialize___tds__GetNTP(soap, (const struct __tds__GetNTP *)ptr);
		break;
	case SOAP_TYPE___tds__SetDNS:
		soap_serialize___tds__SetDNS(soap, (const struct __tds__SetDNS *)ptr);
		break;
	case SOAP_TYPE___tds__GetDNS:
		soap_serialize___tds__GetDNS(soap, (const struct __tds__GetDNS *)ptr);
		break;
	case SOAP_TYPE___tds__SetHostnameFromDHCP:
		soap_serialize___tds__SetHostnameFromDHCP(soap, (const struct __tds__SetHostnameFromDHCP *)ptr);
		break;
	case SOAP_TYPE___tds__SetHostname:
		soap_serialize___tds__SetHostname(soap, (const struct __tds__SetHostname *)ptr);
		break;
	case SOAP_TYPE___tds__GetHostname:
		soap_serialize___tds__GetHostname(soap, (const struct __tds__GetHostname *)ptr);
		break;
	case SOAP_TYPE___tds__SetDPAddresses:
		soap_serialize___tds__SetDPAddresses(soap, (const struct __tds__SetDPAddresses *)ptr);
		break;
	case SOAP_TYPE___tds__GetCapabilities:
		soap_serialize___tds__GetCapabilities(soap, (const struct __tds__GetCapabilities *)ptr);
		break;
	case SOAP_TYPE___tds__SetAuthFailureWarningConfiguration:
		soap_serialize___tds__SetAuthFailureWarningConfiguration(soap, (const struct __tds__SetAuthFailureWarningConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__GetAuthFailureWarningConfiguration:
		soap_serialize___tds__GetAuthFailureWarningConfiguration(soap, (const struct __tds__GetAuthFailureWarningConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__GetAuthFailureWarningOptions:
		soap_serialize___tds__GetAuthFailureWarningOptions(soap, (const struct __tds__GetAuthFailureWarningOptions *)ptr);
		break;
	case SOAP_TYPE___tds__SetPasswordHistoryConfiguration:
		soap_serialize___tds__SetPasswordHistoryConfiguration(soap, (const struct __tds__SetPasswordHistoryConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__GetPasswordHistoryConfiguration:
		soap_serialize___tds__GetPasswordHistoryConfiguration(soap, (const struct __tds__GetPasswordHistoryConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__SetPasswordComplexityConfiguration:
		soap_serialize___tds__SetPasswordComplexityConfiguration(soap, (const struct __tds__SetPasswordComplexityConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__GetPasswordComplexityConfiguration:
		soap_serialize___tds__GetPasswordComplexityConfiguration(soap, (const struct __tds__GetPasswordComplexityConfiguration *)ptr);
		break;
	case SOAP_TYPE___tds__GetPasswordComplexityOptions:
		soap_serialize___tds__GetPasswordComplexityOptions(soap, (const struct __tds__GetPasswordComplexityOptions *)ptr);
		break;
	case SOAP_TYPE___tds__GetWsdlUrl:
		soap_serialize___tds__GetWsdlUrl(soap, (const struct __tds__GetWsdlUrl *)ptr);
		break;
	case SOAP_TYPE___tds__SetUser:
		soap_serialize___tds__SetUser(soap, (const struct __tds__SetUser *)ptr);
		break;
	case SOAP_TYPE___tds__DeleteUsers:
		soap_serialize___tds__DeleteUsers(soap, (const struct __tds__DeleteUsers *)ptr);
		break;
	case SOAP_TYPE___tds__CreateUsers:
		soap_serialize___tds__CreateUsers(soap, (const struct __tds__CreateUsers *)ptr);
		break;
	case SOAP_TYPE___tds__GetUsers:
		soap_serialize___tds__GetUsers(soap, (const struct __tds__GetUsers *)ptr);
		break;
	case SOAP_TYPE___tds__SetRemoteUser:
		soap_serialize___tds__SetRemoteUser(soap, (const struct __tds__SetRemoteUser *)ptr);
		break;
	case SOAP_TYPE___tds__GetRemoteUser:
		soap_serialize___tds__GetRemoteUser(soap, (const struct __tds__GetRemoteUser *)ptr);
		break;
	case SOAP_TYPE___tds__GetEndpointReference:
		soap_serialize___tds__GetEndpointReference(soap, (const struct __tds__GetEndpointReference *)ptr);
		break;
	case SOAP_TYPE___tds__GetDPAddresses:
		soap_serialize___tds__GetDPAddresses(soap, (const struct __tds__GetDPAddresses *)ptr);
		break;
	case SOAP_TYPE___tds__SetRemoteDiscoveryMode:
		soap_serialize___tds__SetRemoteDiscoveryMode(soap, (const struct __tds__SetRemoteDiscoveryMode *)ptr);
		break;
	case SOAP_TYPE___tds__GetRemoteDiscoveryMode:
		soap_serialize___tds__GetRemoteDiscoveryMode(soap, (const struct __tds__GetRemoteDiscoveryMode *)ptr);
		break;
	case SOAP_TYPE___tds__SetDiscoveryMode:
		soap_serialize___tds__SetDiscoveryMode(soap, (const struct __tds__SetDiscoveryMode *)ptr);
		break;
	case SOAP_TYPE___tds__GetDiscoveryMode:
		soap_serialize___tds__GetDiscoveryMode(soap, (const struct __tds__GetDiscoveryMode *)ptr);
		break;
	case SOAP_TYPE___tds__RemoveScopes:
		soap_serialize___tds__RemoveScopes(soap, (const struct __tds__RemoveScopes *)ptr);
		break;
	case SOAP_TYPE___tds__AddScopes:
		soap_serialize___tds__AddScopes(soap, (const struct __tds__AddScopes *)ptr);
		break;
	case SOAP_TYPE___tds__SetScopes:
		soap_serialize___tds__SetScopes(soap, (const struct __tds__SetScopes *)ptr);
		break;
	case SOAP_TYPE___tds__GetScopes:
		soap_serialize___tds__GetScopes(soap, (const struct __tds__GetScopes *)ptr);
		break;
	case SOAP_TYPE___tds__GetSystemSupportInformation:
		soap_serialize___tds__GetSystemSupportInformation(soap, (const struct __tds__GetSystemSupportInformation *)ptr);
		break;
	case SOAP_TYPE___tds__GetSystemLog:
		soap_serialize___tds__GetSystemLog(soap, (const struct __tds__GetSystemLog *)ptr);
		break;
	case SOAP_TYPE___tds__GetSystemBackup:
		soap_serialize___tds__GetSystemBackup(soap, (const struct __tds__GetSystemBackup *)ptr);
		break;
	case SOAP_TYPE___tds__RestoreSystem:
		soap_serialize___tds__RestoreSystem(soap, (const struct __tds__RestoreSystem *)ptr);
		break;
	case SOAP_TYPE___tds__SystemReboot:
		soap_serialize___tds__SystemReboot(soap, (const struct __tds__SystemReboot *)ptr);
		break;
	case SOAP_TYPE___tds__UpgradeSystemFirmware:
		soap_serialize___tds__UpgradeSystemFirmware(soap, (const struct __tds__UpgradeSystemFirmware *)ptr);
		break;
	case SOAP_TYPE___tds__SetSystemFactoryDefault:
		soap_serialize___tds__SetSystemFactoryDefault(soap, (const struct __tds__SetSystemFactoryDefault *)ptr);
		break;
	case SOAP_TYPE___tds__GetSystemDateAndTime:
		soap_serialize___tds__GetSystemDateAndTime(soap, (const struct __tds__GetSystemDateAndTime *)ptr);
		break;
	case SOAP_TYPE___tds__SetSystemDateAndTime:
		soap_serialize___tds__SetSystemDateAndTime(soap, (const struct __tds__SetSystemDateAndTime *)ptr);
		break;
	case SOAP_TYPE___tds__GetDeviceInformation:
		soap_serialize___tds__GetDeviceInformation(soap, (const struct __tds__GetDeviceInformation *)ptr);
		break;
	case SOAP_TYPE___tds__GetServiceCapabilities:
		soap_serialize___tds__GetServiceCapabilities(soap, (const struct __tds__GetServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE___tds__GetServices:
		soap_serialize___tds__GetServices(soap, (const struct __tds__GetServices *)ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope:
		soap_serialize_SOAP_ENV__Envelope(soap, (const struct SOAP_ENV__Envelope *)ptr);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		soap_serialize_chan__ChannelInstanceType(soap, (const struct chan__ChannelInstanceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__xop__Include:
		soap_serialize__xop__Include(soap, (const struct _xop__Include *)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetHashingAlgorithm:
		soap_serialize_PointerTo_tds__SetHashingAlgorithm(soap, (_tds__SetHashingAlgorithm *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__DeleteGeoLocation:
		soap_serialize_PointerTo_tds__DeleteGeoLocation(soap, (_tds__DeleteGeoLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetGeoLocation:
		soap_serialize_PointerTo_tds__SetGeoLocation(soap, (_tds__SetGeoLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetGeoLocation:
		soap_serialize_PointerTo_tds__GetGeoLocation(soap, (_tds__GetGeoLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__DeleteStorageConfiguration:
		soap_serialize_PointerTo_tds__DeleteStorageConfiguration(soap, (_tds__DeleteStorageConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetStorageConfiguration:
		soap_serialize_PointerTo_tds__SetStorageConfiguration(soap, (_tds__SetStorageConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetStorageConfiguration:
		soap_serialize_PointerTo_tds__GetStorageConfiguration(soap, (_tds__GetStorageConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__CreateStorageConfiguration:
		soap_serialize_PointerTo_tds__CreateStorageConfiguration(soap, (_tds__CreateStorageConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetStorageConfigurations:
		soap_serialize_PointerTo_tds__GetStorageConfigurations(soap, (_tds__GetStorageConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__StartSystemRestore:
		soap_serialize_PointerTo_tds__StartSystemRestore(soap, (_tds__StartSystemRestore *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__StartFirmwareUpgrade:
		soap_serialize_PointerTo_tds__StartFirmwareUpgrade(soap, (_tds__StartFirmwareUpgrade *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetSystemUris:
		soap_serialize_PointerTo_tds__GetSystemUris(soap, (_tds__GetSystemUris *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__ScanAvailableDot11Networks:
		soap_serialize_PointerTo_tds__ScanAvailableDot11Networks(soap, (_tds__ScanAvailableDot11Networks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDot11Status:
		soap_serialize_PointerTo_tds__GetDot11Status(soap, (_tds__GetDot11Status *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDot11Capabilities:
		soap_serialize_PointerTo_tds__GetDot11Capabilities(soap, (_tds__GetDot11Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__DeleteDot1XConfiguration:
		soap_serialize_PointerTo_tds__DeleteDot1XConfiguration(soap, (_tds__DeleteDot1XConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDot1XConfigurations:
		soap_serialize_PointerTo_tds__GetDot1XConfigurations(soap, (_tds__GetDot1XConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDot1XConfiguration:
		soap_serialize_PointerTo_tds__GetDot1XConfiguration(soap, (_tds__GetDot1XConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetDot1XConfiguration:
		soap_serialize_PointerTo_tds__SetDot1XConfiguration(soap, (_tds__SetDot1XConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__CreateDot1XConfiguration:
		soap_serialize_PointerTo_tds__CreateDot1XConfiguration(soap, (_tds__CreateDot1XConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__LoadCACertificates:
		soap_serialize_PointerTo_tds__LoadCACertificates(soap, (_tds__LoadCACertificates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetCertificateInformation:
		soap_serialize_PointerTo_tds__GetCertificateInformation(soap, (_tds__GetCertificateInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKey:
		soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKey(soap, (_tds__LoadCertificateWithPrivateKey *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetCACertificates:
		soap_serialize_PointerTo_tds__GetCACertificates(soap, (_tds__GetCACertificates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand:
		soap_serialize_PointerTo_tds__SendAuxiliaryCommand(soap, (_tds__SendAuxiliaryCommand *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetRelayOutputState:
		soap_serialize_PointerTo_tds__SetRelayOutputState(soap, (_tds__SetRelayOutputState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings:
		soap_serialize_PointerTo_tds__SetRelayOutputSettings(soap, (_tds__SetRelayOutputSettings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetRelayOutputs:
		soap_serialize_PointerTo_tds__GetRelayOutputs(soap, (_tds__GetRelayOutputs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetClientCertificateMode:
		soap_serialize_PointerTo_tds__SetClientCertificateMode(soap, (_tds__SetClientCertificateMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetClientCertificateMode:
		soap_serialize_PointerTo_tds__GetClientCertificateMode(soap, (_tds__GetClientCertificateMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__LoadCertificates:
		soap_serialize_PointerTo_tds__LoadCertificates(soap, (_tds__LoadCertificates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetPkcs10Request:
		soap_serialize_PointerTo_tds__GetPkcs10Request(soap, (_tds__GetPkcs10Request *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__DeleteCertificates:
		soap_serialize_PointerTo_tds__DeleteCertificates(soap, (_tds__DeleteCertificates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetCertificatesStatus:
		soap_serialize_PointerTo_tds__SetCertificatesStatus(soap, (_tds__SetCertificatesStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetCertificatesStatus:
		soap_serialize_PointerTo_tds__GetCertificatesStatus(soap, (_tds__GetCertificatesStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetCertificates:
		soap_serialize_PointerTo_tds__GetCertificates(soap, (_tds__GetCertificates *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__CreateCertificate:
		soap_serialize_PointerTo_tds__CreateCertificate(soap, (_tds__CreateCertificate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetAccessPolicy:
		soap_serialize_PointerTo_tds__SetAccessPolicy(soap, (_tds__SetAccessPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetAccessPolicy:
		soap_serialize_PointerTo_tds__GetAccessPolicy(soap, (_tds__GetAccessPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter:
		soap_serialize_PointerTo_tds__RemoveIPAddressFilter(soap, (_tds__RemoveIPAddressFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__AddIPAddressFilter:
		soap_serialize_PointerTo_tds__AddIPAddressFilter(soap, (_tds__AddIPAddressFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetIPAddressFilter:
		soap_serialize_PointerTo_tds__SetIPAddressFilter(soap, (_tds__SetIPAddressFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetIPAddressFilter:
		soap_serialize_PointerTo_tds__GetIPAddressFilter(soap, (_tds__GetIPAddressFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetZeroConfiguration:
		soap_serialize_PointerTo_tds__SetZeroConfiguration(soap, (_tds__SetZeroConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetZeroConfiguration:
		soap_serialize_PointerTo_tds__GetZeroConfiguration(soap, (_tds__GetZeroConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway:
		soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(soap, (_tds__SetNetworkDefaultGateway *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway:
		soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(soap, (_tds__GetNetworkDefaultGateway *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetNetworkProtocols:
		soap_serialize_PointerTo_tds__SetNetworkProtocols(soap, (_tds__SetNetworkProtocols *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetNetworkProtocols:
		soap_serialize_PointerTo_tds__GetNetworkProtocols(soap, (_tds__GetNetworkProtocols *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces:
		soap_serialize_PointerTo_tds__SetNetworkInterfaces(soap, (_tds__SetNetworkInterfaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces:
		soap_serialize_PointerTo_tds__GetNetworkInterfaces(soap, (_tds__GetNetworkInterfaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetDynamicDNS:
		soap_serialize_PointerTo_tds__SetDynamicDNS(soap, (_tds__SetDynamicDNS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDynamicDNS:
		soap_serialize_PointerTo_tds__GetDynamicDNS(soap, (_tds__GetDynamicDNS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetNTP:
		soap_serialize_PointerTo_tds__SetNTP(soap, (_tds__SetNTP *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetNTP:
		soap_serialize_PointerTo_tds__GetNTP(soap, (_tds__GetNTP *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetDNS:
		soap_serialize_PointerTo_tds__SetDNS(soap, (_tds__SetDNS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDNS:
		soap_serialize_PointerTo_tds__GetDNS(soap, (_tds__GetDNS *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP:
		soap_serialize_PointerTo_tds__SetHostnameFromDHCP(soap, (_tds__SetHostnameFromDHCP *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetHostname:
		soap_serialize_PointerTo_tds__SetHostname(soap, (_tds__SetHostname *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetHostname:
		soap_serialize_PointerTo_tds__GetHostname(soap, (_tds__GetHostname *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetDPAddresses:
		soap_serialize_PointerTo_tds__SetDPAddresses(soap, (_tds__SetDPAddresses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetCapabilities:
		soap_serialize_PointerTo_tds__GetCapabilities(soap, (_tds__GetCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetAuthFailureWarningConfiguration:
		soap_serialize_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, (_tds__SetAuthFailureWarningConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetAuthFailureWarningConfiguration:
		soap_serialize_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, (_tds__GetAuthFailureWarningConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetAuthFailureWarningOptions:
		soap_serialize_PointerTo_tds__GetAuthFailureWarningOptions(soap, (_tds__GetAuthFailureWarningOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetPasswordHistoryConfiguration:
		soap_serialize_PointerTo_tds__SetPasswordHistoryConfiguration(soap, (_tds__SetPasswordHistoryConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetPasswordHistoryConfiguration:
		soap_serialize_PointerTo_tds__GetPasswordHistoryConfiguration(soap, (_tds__GetPasswordHistoryConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetPasswordComplexityConfiguration:
		soap_serialize_PointerTo_tds__SetPasswordComplexityConfiguration(soap, (_tds__SetPasswordComplexityConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetPasswordComplexityConfiguration:
		soap_serialize_PointerTo_tds__GetPasswordComplexityConfiguration(soap, (_tds__GetPasswordComplexityConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetPasswordComplexityOptions:
		soap_serialize_PointerTo_tds__GetPasswordComplexityOptions(soap, (_tds__GetPasswordComplexityOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetWsdlUrl:
		soap_serialize_PointerTo_tds__GetWsdlUrl(soap, (_tds__GetWsdlUrl *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetUser:
		soap_serialize_PointerTo_tds__SetUser(soap, (_tds__SetUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__DeleteUsers:
		soap_serialize_PointerTo_tds__DeleteUsers(soap, (_tds__DeleteUsers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__CreateUsers:
		soap_serialize_PointerTo_tds__CreateUsers(soap, (_tds__CreateUsers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetUsers:
		soap_serialize_PointerTo_tds__GetUsers(soap, (_tds__GetUsers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetRemoteUser:
		soap_serialize_PointerTo_tds__SetRemoteUser(soap, (_tds__SetRemoteUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetRemoteUser:
		soap_serialize_PointerTo_tds__GetRemoteUser(soap, (_tds__GetRemoteUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetEndpointReference:
		soap_serialize_PointerTo_tds__GetEndpointReference(soap, (_tds__GetEndpointReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDPAddresses:
		soap_serialize_PointerTo_tds__GetDPAddresses(soap, (_tds__GetDPAddresses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryMode:
		soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(soap, (_tds__SetRemoteDiscoveryMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryMode:
		soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(soap, (_tds__GetRemoteDiscoveryMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetDiscoveryMode:
		soap_serialize_PointerTo_tds__SetDiscoveryMode(soap, (_tds__SetDiscoveryMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDiscoveryMode:
		soap_serialize_PointerTo_tds__GetDiscoveryMode(soap, (_tds__GetDiscoveryMode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__RemoveScopes:
		soap_serialize_PointerTo_tds__RemoveScopes(soap, (_tds__RemoveScopes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__AddScopes:
		soap_serialize_PointerTo_tds__AddScopes(soap, (_tds__AddScopes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetScopes:
		soap_serialize_PointerTo_tds__SetScopes(soap, (_tds__SetScopes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetScopes:
		soap_serialize_PointerTo_tds__GetScopes(soap, (_tds__GetScopes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetSystemSupportInformation:
		soap_serialize_PointerTo_tds__GetSystemSupportInformation(soap, (_tds__GetSystemSupportInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetSystemLog:
		soap_serialize_PointerTo_tds__GetSystemLog(soap, (_tds__GetSystemLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetSystemBackup:
		soap_serialize_PointerTo_tds__GetSystemBackup(soap, (_tds__GetSystemBackup *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__RestoreSystem:
		soap_serialize_PointerTo_tds__RestoreSystem(soap, (_tds__RestoreSystem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SystemReboot:
		soap_serialize_PointerTo_tds__SystemReboot(soap, (_tds__SystemReboot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmware:
		soap_serialize_PointerTo_tds__UpgradeSystemFirmware(soap, (_tds__UpgradeSystemFirmware *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault:
		soap_serialize_PointerTo_tds__SetSystemFactoryDefault(soap, (_tds__SetSystemFactoryDefault *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime:
		soap_serialize_PointerTo_tds__GetSystemDateAndTime(soap, (_tds__GetSystemDateAndTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime:
		soap_serialize_PointerTo_tds__SetSystemDateAndTime(soap, (_tds__SetSystemDateAndTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetDeviceInformation:
		soap_serialize_PointerTo_tds__GetDeviceInformation(soap, (_tds__GetDeviceInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetServiceCapabilities:
		soap_serialize_PointerTo_tds__GetServiceCapabilities(soap, (_tds__GetServiceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetServices:
		soap_serialize_PointerTo_tds__GetServices(soap, (_tds__GetServices *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceExtension:
		soap_serialize_PointerTott__NetworkInterfaceExtension(soap, (tt__NetworkInterfaceExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6NetworkInterface:
		soap_serialize_PointerTott__IPv6NetworkInterface(soap, (tt__IPv6NetworkInterface *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv4NetworkInterface:
		soap_serialize_PointerTott__IPv4NetworkInterface(soap, (tt__IPv4NetworkInterface *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceLink:
		soap_serialize_PointerTott__NetworkInterfaceLink(soap, (tt__NetworkInterfaceLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceInfo:
		soap_serialize_PointerTott__NetworkInterfaceInfo(soap, (tt__NetworkInterfaceInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__LocalOrientation:
		soap_serialize_PointerTott__LocalOrientation(soap, (tt__LocalOrientation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__LocalLocation:
		soap_serialize_PointerTott__LocalLocation(soap, (tt__LocalLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__GeoOrientation:
		soap_serialize_PointerTott__GeoOrientation(soap, (tt__GeoOrientation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__GeoLocation:
		soap_serialize_PointerTott__GeoLocation(soap, (tt__GeoLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EapMethodExtension:
		soap_serialize_PointerTott__EapMethodExtension(soap, (tt__EapMethodExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__TLSConfiguration:
		soap_serialize_PointerTott__TLSConfiguration(soap, (tt__TLSConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot1XConfigurationExtension:
		soap_serialize_PointerTott__Dot1XConfigurationExtension(soap, (tt__Dot1XConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EAPMethodConfiguration:
		soap_serialize_PointerTott__EAPMethodConfiguration(soap, (tt__EAPMethodConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__CertificateInformationExtension:
		soap_serialize_PointerTott__CertificateInformationExtension(soap, (tt__CertificateInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DateTimeRange:
		soap_serialize_PointerTott__DateTimeRange(soap, (tt__DateTimeRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__CertificateUsage:
		soap_serialize_PointerTott__CertificateUsage(soap, (tt__CertificateUsage *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__UserExtension:
		soap_serialize_PointerTott__UserExtension(soap, (tt__UserExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Date:
		soap_serialize_PointerTott__Date(soap, (tt__Date *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Time:
		soap_serialize_PointerTott__Time(soap, (tt__Time *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemDateTimeExtension:
		soap_serialize_PointerTott__SystemDateTimeExtension(soap, (tt__SystemDateTimeExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemLogUri:
		soap_serialize_PointerTott__SystemLogUri(soap, (tt__SystemLogUri *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AnalyticsDeviceExtension:
		soap_serialize_PointerTott__AnalyticsDeviceExtension(soap, (tt__AnalyticsDeviceExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemCapabilitiesExtension2:
		soap_serialize_PointerTott__SystemCapabilitiesExtension2(soap, (tt__SystemCapabilitiesExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemCapabilitiesExtension:
		soap_serialize_PointerTott__SystemCapabilitiesExtension(soap, (tt__SystemCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension2:
		soap_serialize_PointerTott__SecurityCapabilitiesExtension2(soap, (tt__SecurityCapabilitiesExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension:
		soap_serialize_PointerTott__SecurityCapabilitiesExtension(soap, (tt__SecurityCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension2:
		soap_serialize_PointerTott__NetworkCapabilitiesExtension2(soap, (tt__NetworkCapabilitiesExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension:
		soap_serialize_PointerTott__NetworkCapabilitiesExtension(soap, (tt__NetworkCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension:
		soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, (tt__RealTimeStreamingCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ProfileCapabilities:
		soap_serialize_PointerTott__ProfileCapabilities(soap, (tt__ProfileCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MediaCapabilitiesExtension:
		soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, (tt__MediaCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities:
		soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, (tt__RealTimeStreamingCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IOCapabilitiesExtension2:
		soap_serialize_PointerTott__IOCapabilitiesExtension2(soap, (tt__IOCapabilitiesExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IOCapabilitiesExtension:
		soap_serialize_PointerTott__IOCapabilitiesExtension(soap, (tt__IOCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension:
		soap_serialize_PointerTott__DeviceCapabilitiesExtension(soap, (tt__DeviceCapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SecurityCapabilities:
		soap_serialize_PointerTott__SecurityCapabilities(soap, (tt__SecurityCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IOCapabilities:
		soap_serialize_PointerTott__IOCapabilities(soap, (tt__IOCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemCapabilities:
		soap_serialize_PointerTott__SystemCapabilities(soap, (tt__SystemCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkCapabilities:
		soap_serialize_PointerTott__NetworkCapabilities(soap, (tt__NetworkCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__CapabilitiesExtension2:
		soap_serialize_PointerTott__CapabilitiesExtension2(soap, (tt__CapabilitiesExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AnalyticsDeviceCapabilities:
		soap_serialize_PointerTott__AnalyticsDeviceCapabilities(soap, (tt__AnalyticsDeviceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ReceiverCapabilities:
		soap_serialize_PointerTott__ReceiverCapabilities(soap, (tt__ReceiverCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ReplayCapabilities:
		soap_serialize_PointerTott__ReplayCapabilities(soap, (tt__ReplayCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SearchCapabilities:
		soap_serialize_PointerTott__SearchCapabilities(soap, (tt__SearchCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RecordingCapabilities:
		soap_serialize_PointerTott__RecordingCapabilities(soap, (tt__RecordingCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DisplayCapabilities:
		soap_serialize_PointerTott__DisplayCapabilities(soap, (tt__DisplayCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DeviceIOCapabilities:
		soap_serialize_PointerTott__DeviceIOCapabilities(soap, (tt__DeviceIOCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__CapabilitiesExtension:
		soap_serialize_PointerTott__CapabilitiesExtension(soap, (tt__CapabilitiesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZCapabilities:
		soap_serialize_PointerTott__PTZCapabilities(soap, (tt__PTZCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MediaCapabilities:
		soap_serialize_PointerTott__MediaCapabilities(soap, (tt__MediaCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ImagingCapabilities:
		soap_serialize_PointerTott__ImagingCapabilities(soap, (tt__ImagingCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EventCapabilities:
		soap_serialize_PointerTott__EventCapabilities(soap, (tt__EventCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DeviceCapabilities:
		soap_serialize_PointerTott__DeviceCapabilities(soap, (tt__DeviceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AnalyticsCapabilities:
		soap_serialize_PointerTott__AnalyticsCapabilities(soap, (tt__AnalyticsCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11AvailableNetworksExtension:
		soap_serialize_PointerTott__Dot11AvailableNetworksExtension(soap, (tt__Dot11AvailableNetworksExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11SignalStrength:
		soap_serialize_PointerTott__Dot11SignalStrength(soap, (enum tt__Dot11SignalStrength *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11PSKSetExtension:
		soap_serialize_PointerTott__Dot11PSKSetExtension(soap, (tt__Dot11PSKSetExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11PSKPassphrase:
		soap_serialize_PointerTott__Dot11PSKPassphrase(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11PSK:
		soap_serialize_PointerTott__Dot11PSK(soap, (xsd__hexBinary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11SecurityConfigurationExtension:
		soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(soap, (tt__Dot11SecurityConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ReferenceToken:
		soap_serialize_PointerTott__ReferenceToken(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11PSKSet:
		soap_serialize_PointerTott__Dot11PSKSet(soap, (tt__Dot11PSKSet *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11Cipher:
		soap_serialize_PointerTott__Dot11Cipher(soap, (enum tt__Dot11Cipher *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11SecurityConfiguration:
		soap_serialize_PointerTott__Dot11SecurityConfiguration(soap, (tt__Dot11SecurityConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPAddressFilterExtension:
		soap_serialize_PointerTott__IPAddressFilterExtension(soap, (tt__IPAddressFilterExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension2:
		soap_serialize_PointerTott__NetworkZeroConfigurationExtension2(soap, (tt__NetworkZeroConfigurationExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension:
		soap_serialize_PointerTott__NetworkZeroConfigurationExtension(soap, (tt__NetworkZeroConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6DHCPConfiguration:
		soap_serialize_PointerTott__IPv6DHCPConfiguration(soap, (enum tt__IPv6DHCPConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension2:
		soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, (tt__NetworkInterfaceSetConfigurationExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension:
		soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, (tt__NetworkInterfaceSetConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration:
		soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, (tt__IPv6NetworkInterfaceSetConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration:
		soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, (tt__IPv4NetworkInterfaceSetConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DynamicDNSInformationExtension:
		soap_serialize_PointerTott__DynamicDNSInformationExtension(soap, (tt__DynamicDNSInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NTPInformationExtension:
		soap_serialize_PointerTott__NTPInformationExtension(soap, (tt__NTPInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DNSInformationExtension:
		soap_serialize_PointerTott__DNSInformationExtension(soap, (tt__DNSInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__HostnameInformationExtension:
		soap_serialize_PointerTott__HostnameInformationExtension(soap, (tt__HostnameInformationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkHostExtension:
		soap_serialize_PointerTott__NetworkHostExtension(soap, (tt__NetworkHostExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6Address:
		soap_serialize_PointerTott__IPv6Address(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv4Address:
		soap_serialize_PointerTott__IPv4Address(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkProtocolExtension:
		soap_serialize_PointerTott__NetworkProtocolExtension(soap, (tt__NetworkProtocolExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6ConfigurationExtension:
		soap_serialize_PointerTott__IPv6ConfigurationExtension(soap, (tt__IPv6ConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PrefixedIPv6Address:
		soap_serialize_PointerTott__PrefixedIPv6Address(soap, (tt__PrefixedIPv6Address *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PrefixedIPv4Address:
		soap_serialize_PointerTott__PrefixedIPv4Address(soap, (tt__PrefixedIPv4Address *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv4Configuration:
		soap_serialize_PointerTott__IPv4Configuration(soap, (tt__IPv4Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPv6Configuration:
		soap_serialize_PointerTott__IPv6Configuration(soap, (tt__IPv6Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting:
		soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, (tt__NetworkInterfaceConnectionSetting *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceExtension2:
		soap_serialize_PointerTott__NetworkInterfaceExtension2(soap, (tt__NetworkInterfaceExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11Configuration:
		soap_serialize_PointerTott__Dot11Configuration(soap, (tt__Dot11Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot3Configuration:
		soap_serialize_PointerTott__Dot3Configuration(soap, (tt__Dot3Configuration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__LocationEntity:
		soap_serialize_PointerTott__LocationEntity(soap, (tt__LocationEntity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__StorageConfigurationData:
		soap_serialize_PointerTotds__StorageConfigurationData(soap, (tds__StorageConfigurationData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__StorageConfiguration:
		soap_serialize_PointerTotds__StorageConfiguration(soap, (tds__StorageConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse_Extension:
		soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(soap, (_tds__GetSystemUrisResponse_Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemLogUriList:
		soap_serialize_PointerTott__SystemLogUriList(soap, (tt__SystemLogUriList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11AvailableNetworks:
		soap_serialize_PointerTott__Dot11AvailableNetworks(soap, (tt__Dot11AvailableNetworks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11Status:
		soap_serialize_PointerTott__Dot11Status(soap, (tt__Dot11Status *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot11Capabilities:
		soap_serialize_PointerTott__Dot11Capabilities(soap, (tt__Dot11Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AuxiliaryData:
		soap_serialize_PointerTott__AuxiliaryData(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RelayOutputSettings:
		soap_serialize_PointerTott__RelayOutputSettings(soap, (tt__RelayOutputSettings *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RelayOutput:
		soap_serialize_PointerTott__RelayOutput(soap, (tt__RelayOutput *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Dot1XConfiguration:
		soap_serialize_PointerTott__Dot1XConfiguration(soap, (tt__Dot1XConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__CertificateInformation:
		soap_serialize_PointerTott__CertificateInformation(soap, (tt__CertificateInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__CertificateWithPrivateKey:
		soap_serialize_PointerTott__CertificateWithPrivateKey(soap, (tt__CertificateWithPrivateKey *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__CertificateStatus:
		soap_serialize_PointerTott__CertificateStatus(soap, (tt__CertificateStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Certificate:
		soap_serialize_PointerTott__Certificate(soap, (tt__Certificate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodateTime:
		soap_serialize_PointerTodateTime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__token:
		soap_serialize_PointerToxsd__token(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__BinaryData:
		soap_serialize_PointerTott__BinaryData(soap, (tt__BinaryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPAddressFilter:
		soap_serialize_PointerTott__IPAddressFilter(soap, (tt__IPAddressFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkZeroConfiguration:
		soap_serialize_PointerTott__NetworkZeroConfiguration(soap, (tt__NetworkZeroConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkGateway:
		soap_serialize_PointerTott__NetworkGateway(soap, (tt__NetworkGateway *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkProtocol:
		soap_serialize_PointerTott__NetworkProtocol(soap, (tt__NetworkProtocol *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterfaceSetConfiguration:
		soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(soap, (tt__NetworkInterfaceSetConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkInterface:
		soap_serialize_PointerTott__NetworkInterface(soap, (tt__NetworkInterface *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DNSName:
		soap_serialize_PointerTott__DNSName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DynamicDNSInformation:
		soap_serialize_PointerTott__DynamicDNSInformation(soap, (tt__DynamicDNSInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NTPInformation:
		soap_serialize_PointerTott__NTPInformation(soap, (tt__NTPInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IPAddress:
		soap_serialize_PointerTott__IPAddress(soap, (tt__IPAddress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DNSInformation:
		soap_serialize_PointerTott__DNSInformation(soap, (tt__DNSInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__HostnameInformation:
		soap_serialize_PointerTott__HostnameInformation(soap, (tt__HostnameInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Capabilities:
		soap_serialize_PointerTott__Capabilities(soap, (tt__Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntRange:
		soap_serialize_PointerTott__IntRange(soap, (tt__IntRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__User:
		soap_serialize_PointerTott__User(soap, (tt__User *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__RemoteUser:
		soap_serialize_PointerTott__RemoteUser(soap, (tt__RemoteUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__NetworkHost:
		soap_serialize_PointerTott__NetworkHost(soap, (tt__NetworkHost *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Scope:
		soap_serialize_PointerTott__Scope(soap, (tt__Scope *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemLog:
		soap_serialize_PointerTott__SystemLog(soap, (tt__SystemLog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SupportInformation:
		soap_serialize_PointerTott__SupportInformation(soap, (tt__SupportInformation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__BackupFile:
		soap_serialize_PointerTott__BackupFile(soap, (tt__BackupFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__AttachmentData:
		soap_serialize_PointerTott__AttachmentData(soap, (tt__AttachmentData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__SystemDateTime:
		soap_serialize_PointerTott__SystemDateTime(soap, (tt__SystemDateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DateTime:
		soap_serialize_PointerTott__DateTime(soap, (tt__DateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__TimeZone:
		soap_serialize_PointerTott__TimeZone(soap, (tt__TimeZone *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__DeviceServiceCapabilities:
		soap_serialize_PointerTotds__DeviceServiceCapabilities(soap, (tds__DeviceServiceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__Service:
		soap_serialize_PointerTotds__Service(soap, (tds__Service *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__StorageConfigurationData_Extension:
		soap_serialize_PointerTo_tds__StorageConfigurationData_Extension(soap, (_tds__StorageConfigurationData_Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__UserCredential:
		soap_serialize_PointerTotds__UserCredential(soap, (tds__UserCredential *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__UserCredential_Extension:
		soap_serialize_PointerTo_tds__UserCredential_Extension(soap, (_tds__UserCredential_Extension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__StringAttrList:
		soap_serialize_PointerTott__StringAttrList(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__StringList:
		soap_serialize_PointerTott__StringList(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntList:
		soap_serialize_PointerTott__IntList(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__MiscCapabilities:
		soap_serialize_PointerTotds__MiscCapabilities(soap, (tds__MiscCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__SystemCapabilities:
		soap_serialize_PointerTotds__SystemCapabilities(soap, (tds__SystemCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__SecurityCapabilities:
		soap_serialize_PointerTotds__SecurityCapabilities(soap, (tds__SecurityCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotds__NetworkCapabilities:
		soap_serialize_PointerTotds__NetworkCapabilities(soap, (tds__NetworkCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__OnvifVersion:
		soap_serialize_PointerTott__OnvifVersion(soap, (tt__OnvifVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tds__Service_Capabilities:
		soap_serialize_PointerTo_tds__Service_Capabilities(soap, (_tds__Service_Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		soap_serialize_PointerTochan__ChannelInstanceType(soap, (struct chan__ChannelInstanceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE__xop__Include:
		return (void*)soap_instantiate__xop__Include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return (void*)soap_instantiate_wsa5__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return (void*)soap_instantiate_wsa5__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__MetadataType:
		return (void*)soap_instantiate_wsa5__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return (void*)soap_instantiate_wsa5__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__RelatesToType:
		return (void*)soap_instantiate_wsa5__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_chan__ChannelInstanceType:
		return (void*)soap_instantiate_chan__ChannelInstanceType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Envelope:
		return (void*)soap_instantiate_SOAP_ENV__Envelope(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__hexBinary:
		return (void*)soap_instantiate_xsd__hexBinary(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__Service_Capabilities:
		return (void*)soap_instantiate__tds__Service_Capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tds__Service:
		return (void*)soap_instantiate_tds__Service(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tds__DeviceServiceCapabilities:
		return (void*)soap_instantiate_tds__DeviceServiceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tds__NetworkCapabilities:
		return (void*)soap_instantiate_tds__NetworkCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tds__SecurityCapabilities:
		return (void*)soap_instantiate_tds__SecurityCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tds__SystemCapabilities:
		return (void*)soap_instantiate_tds__SystemCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tds__MiscCapabilities:
		return (void*)soap_instantiate_tds__MiscCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__UserCredential_Extension:
		return (void*)soap_instantiate__tds__UserCredential_Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tds__UserCredential:
		return (void*)soap_instantiate_tds__UserCredential(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__StorageConfigurationData_Extension:
		return (void*)soap_instantiate__tds__StorageConfigurationData_Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tds__StorageConfigurationData:
		return (void*)soap_instantiate_tds__StorageConfigurationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetServices:
		return (void*)soap_instantiate__tds__GetServices(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetServicesResponse:
		return (void*)soap_instantiate__tds__GetServicesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetServiceCapabilities:
		return (void*)soap_instantiate__tds__GetServiceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetServiceCapabilitiesResponse:
		return (void*)soap_instantiate__tds__GetServiceCapabilitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDeviceInformation:
		return (void*)soap_instantiate__tds__GetDeviceInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDeviceInformationResponse:
		return (void*)soap_instantiate__tds__GetDeviceInformationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetSystemDateAndTime:
		return (void*)soap_instantiate__tds__SetSystemDateAndTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetSystemDateAndTimeResponse:
		return (void*)soap_instantiate__tds__SetSystemDateAndTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemDateAndTime:
		return (void*)soap_instantiate__tds__GetSystemDateAndTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemDateAndTimeResponse:
		return (void*)soap_instantiate__tds__GetSystemDateAndTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetSystemFactoryDefault:
		return (void*)soap_instantiate__tds__SetSystemFactoryDefault(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetSystemFactoryDefaultResponse:
		return (void*)soap_instantiate__tds__SetSystemFactoryDefaultResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__UpgradeSystemFirmware:
		return (void*)soap_instantiate__tds__UpgradeSystemFirmware(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__UpgradeSystemFirmwareResponse:
		return (void*)soap_instantiate__tds__UpgradeSystemFirmwareResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SystemReboot:
		return (void*)soap_instantiate__tds__SystemReboot(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SystemRebootResponse:
		return (void*)soap_instantiate__tds__SystemRebootResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__RestoreSystem:
		return (void*)soap_instantiate__tds__RestoreSystem(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__RestoreSystemResponse:
		return (void*)soap_instantiate__tds__RestoreSystemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemBackup:
		return (void*)soap_instantiate__tds__GetSystemBackup(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemBackupResponse:
		return (void*)soap_instantiate__tds__GetSystemBackupResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemSupportInformation:
		return (void*)soap_instantiate__tds__GetSystemSupportInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemSupportInformationResponse:
		return (void*)soap_instantiate__tds__GetSystemSupportInformationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemLog:
		return (void*)soap_instantiate__tds__GetSystemLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemLogResponse:
		return (void*)soap_instantiate__tds__GetSystemLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetScopes:
		return (void*)soap_instantiate__tds__GetScopes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetScopesResponse:
		return (void*)soap_instantiate__tds__GetScopesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetScopes:
		return (void*)soap_instantiate__tds__SetScopes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetScopesResponse:
		return (void*)soap_instantiate__tds__SetScopesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__AddScopes:
		return (void*)soap_instantiate__tds__AddScopes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__AddScopesResponse:
		return (void*)soap_instantiate__tds__AddScopesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__RemoveScopes:
		return (void*)soap_instantiate__tds__RemoveScopes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__RemoveScopesResponse:
		return (void*)soap_instantiate__tds__RemoveScopesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDiscoveryMode:
		return (void*)soap_instantiate__tds__GetDiscoveryMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDiscoveryModeResponse:
		return (void*)soap_instantiate__tds__GetDiscoveryModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetDiscoveryMode:
		return (void*)soap_instantiate__tds__SetDiscoveryMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetDiscoveryModeResponse:
		return (void*)soap_instantiate__tds__SetDiscoveryModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetRemoteDiscoveryMode:
		return (void*)soap_instantiate__tds__GetRemoteDiscoveryMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse:
		return (void*)soap_instantiate__tds__GetRemoteDiscoveryModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetRemoteDiscoveryMode:
		return (void*)soap_instantiate__tds__SetRemoteDiscoveryMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse:
		return (void*)soap_instantiate__tds__SetRemoteDiscoveryModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDPAddresses:
		return (void*)soap_instantiate__tds__GetDPAddresses(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDPAddressesResponse:
		return (void*)soap_instantiate__tds__GetDPAddressesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetDPAddresses:
		return (void*)soap_instantiate__tds__SetDPAddresses(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetDPAddressesResponse:
		return (void*)soap_instantiate__tds__SetDPAddressesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetEndpointReference:
		return (void*)soap_instantiate__tds__GetEndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetEndpointReferenceResponse:
		return (void*)soap_instantiate__tds__GetEndpointReferenceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetRemoteUser:
		return (void*)soap_instantiate__tds__GetRemoteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetRemoteUserResponse:
		return (void*)soap_instantiate__tds__GetRemoteUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetRemoteUser:
		return (void*)soap_instantiate__tds__SetRemoteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetRemoteUserResponse:
		return (void*)soap_instantiate__tds__SetRemoteUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetUsers:
		return (void*)soap_instantiate__tds__GetUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetUsersResponse:
		return (void*)soap_instantiate__tds__GetUsersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__CreateUsers:
		return (void*)soap_instantiate__tds__CreateUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__CreateUsersResponse:
		return (void*)soap_instantiate__tds__CreateUsersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__DeleteUsers:
		return (void*)soap_instantiate__tds__DeleteUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__DeleteUsersResponse:
		return (void*)soap_instantiate__tds__DeleteUsersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetUser:
		return (void*)soap_instantiate__tds__SetUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetUserResponse:
		return (void*)soap_instantiate__tds__SetUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetWsdlUrl:
		return (void*)soap_instantiate__tds__GetWsdlUrl(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetWsdlUrlResponse:
		return (void*)soap_instantiate__tds__GetWsdlUrlResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetPasswordComplexityOptions:
		return (void*)soap_instantiate__tds__GetPasswordComplexityOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse:
		return (void*)soap_instantiate__tds__GetPasswordComplexityOptionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetPasswordComplexityConfiguration:
		return (void*)soap_instantiate__tds__GetPasswordComplexityConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse:
		return (void*)soap_instantiate__tds__GetPasswordComplexityConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetPasswordComplexityConfiguration:
		return (void*)soap_instantiate__tds__SetPasswordComplexityConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse:
		return (void*)soap_instantiate__tds__SetPasswordComplexityConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetPasswordHistoryConfiguration:
		return (void*)soap_instantiate__tds__GetPasswordHistoryConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse:
		return (void*)soap_instantiate__tds__GetPasswordHistoryConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetPasswordHistoryConfiguration:
		return (void*)soap_instantiate__tds__SetPasswordHistoryConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse:
		return (void*)soap_instantiate__tds__SetPasswordHistoryConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetAuthFailureWarningOptions:
		return (void*)soap_instantiate__tds__GetAuthFailureWarningOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse:
		return (void*)soap_instantiate__tds__GetAuthFailureWarningOptionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetAuthFailureWarningConfiguration:
		return (void*)soap_instantiate__tds__GetAuthFailureWarningConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse:
		return (void*)soap_instantiate__tds__GetAuthFailureWarningConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetAuthFailureWarningConfiguration:
		return (void*)soap_instantiate__tds__SetAuthFailureWarningConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse:
		return (void*)soap_instantiate__tds__SetAuthFailureWarningConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetCapabilities:
		return (void*)soap_instantiate__tds__GetCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetCapabilitiesResponse:
		return (void*)soap_instantiate__tds__GetCapabilitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetHostname:
		return (void*)soap_instantiate__tds__GetHostname(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetHostnameResponse:
		return (void*)soap_instantiate__tds__GetHostnameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetHostname:
		return (void*)soap_instantiate__tds__SetHostname(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetHostnameResponse:
		return (void*)soap_instantiate__tds__SetHostnameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetHostnameFromDHCP:
		return (void*)soap_instantiate__tds__SetHostnameFromDHCP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetHostnameFromDHCPResponse:
		return (void*)soap_instantiate__tds__SetHostnameFromDHCPResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDNS:
		return (void*)soap_instantiate__tds__GetDNS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDNSResponse:
		return (void*)soap_instantiate__tds__GetDNSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetDNS:
		return (void*)soap_instantiate__tds__SetDNS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetDNSResponse:
		return (void*)soap_instantiate__tds__SetDNSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetNTP:
		return (void*)soap_instantiate__tds__GetNTP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetNTPResponse:
		return (void*)soap_instantiate__tds__GetNTPResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetNTP:
		return (void*)soap_instantiate__tds__SetNTP(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetNTPResponse:
		return (void*)soap_instantiate__tds__SetNTPResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDynamicDNS:
		return (void*)soap_instantiate__tds__GetDynamicDNS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDynamicDNSResponse:
		return (void*)soap_instantiate__tds__GetDynamicDNSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetDynamicDNS:
		return (void*)soap_instantiate__tds__SetDynamicDNS(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetDynamicDNSResponse:
		return (void*)soap_instantiate__tds__SetDynamicDNSResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetNetworkInterfaces:
		return (void*)soap_instantiate__tds__GetNetworkInterfaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetNetworkInterfacesResponse:
		return (void*)soap_instantiate__tds__GetNetworkInterfacesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetNetworkInterfaces:
		return (void*)soap_instantiate__tds__SetNetworkInterfaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetNetworkInterfacesResponse:
		return (void*)soap_instantiate__tds__SetNetworkInterfacesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetNetworkProtocols:
		return (void*)soap_instantiate__tds__GetNetworkProtocols(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetNetworkProtocolsResponse:
		return (void*)soap_instantiate__tds__GetNetworkProtocolsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetNetworkProtocols:
		return (void*)soap_instantiate__tds__SetNetworkProtocols(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetNetworkProtocolsResponse:
		return (void*)soap_instantiate__tds__SetNetworkProtocolsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetNetworkDefaultGateway:
		return (void*)soap_instantiate__tds__GetNetworkDefaultGateway(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse:
		return (void*)soap_instantiate__tds__GetNetworkDefaultGatewayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetNetworkDefaultGateway:
		return (void*)soap_instantiate__tds__SetNetworkDefaultGateway(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse:
		return (void*)soap_instantiate__tds__SetNetworkDefaultGatewayResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetZeroConfiguration:
		return (void*)soap_instantiate__tds__GetZeroConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetZeroConfigurationResponse:
		return (void*)soap_instantiate__tds__GetZeroConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetZeroConfiguration:
		return (void*)soap_instantiate__tds__SetZeroConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetZeroConfigurationResponse:
		return (void*)soap_instantiate__tds__SetZeroConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetIPAddressFilter:
		return (void*)soap_instantiate__tds__GetIPAddressFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetIPAddressFilterResponse:
		return (void*)soap_instantiate__tds__GetIPAddressFilterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetIPAddressFilter:
		return (void*)soap_instantiate__tds__SetIPAddressFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetIPAddressFilterResponse:
		return (void*)soap_instantiate__tds__SetIPAddressFilterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__AddIPAddressFilter:
		return (void*)soap_instantiate__tds__AddIPAddressFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__AddIPAddressFilterResponse:
		return (void*)soap_instantiate__tds__AddIPAddressFilterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__RemoveIPAddressFilter:
		return (void*)soap_instantiate__tds__RemoveIPAddressFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__RemoveIPAddressFilterResponse:
		return (void*)soap_instantiate__tds__RemoveIPAddressFilterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetAccessPolicy:
		return (void*)soap_instantiate__tds__GetAccessPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetAccessPolicyResponse:
		return (void*)soap_instantiate__tds__GetAccessPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetAccessPolicy:
		return (void*)soap_instantiate__tds__SetAccessPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetAccessPolicyResponse:
		return (void*)soap_instantiate__tds__SetAccessPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__CreateCertificate:
		return (void*)soap_instantiate__tds__CreateCertificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__CreateCertificateResponse:
		return (void*)soap_instantiate__tds__CreateCertificateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetCertificates:
		return (void*)soap_instantiate__tds__GetCertificates(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetCertificatesResponse:
		return (void*)soap_instantiate__tds__GetCertificatesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetCertificatesStatus:
		return (void*)soap_instantiate__tds__GetCertificatesStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetCertificatesStatusResponse:
		return (void*)soap_instantiate__tds__GetCertificatesStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetCertificatesStatus:
		return (void*)soap_instantiate__tds__SetCertificatesStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetCertificatesStatusResponse:
		return (void*)soap_instantiate__tds__SetCertificatesStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__DeleteCertificates:
		return (void*)soap_instantiate__tds__DeleteCertificates(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__DeleteCertificatesResponse:
		return (void*)soap_instantiate__tds__DeleteCertificatesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetPkcs10Request:
		return (void*)soap_instantiate__tds__GetPkcs10Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetPkcs10RequestResponse:
		return (void*)soap_instantiate__tds__GetPkcs10RequestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__LoadCertificates:
		return (void*)soap_instantiate__tds__LoadCertificates(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__LoadCertificatesResponse:
		return (void*)soap_instantiate__tds__LoadCertificatesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetClientCertificateMode:
		return (void*)soap_instantiate__tds__GetClientCertificateMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetClientCertificateModeResponse:
		return (void*)soap_instantiate__tds__GetClientCertificateModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetClientCertificateMode:
		return (void*)soap_instantiate__tds__SetClientCertificateMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetClientCertificateModeResponse:
		return (void*)soap_instantiate__tds__SetClientCertificateModeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetCACertificates:
		return (void*)soap_instantiate__tds__GetCACertificates(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetCACertificatesResponse:
		return (void*)soap_instantiate__tds__GetCACertificatesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__LoadCertificateWithPrivateKey:
		return (void*)soap_instantiate__tds__LoadCertificateWithPrivateKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse:
		return (void*)soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetCertificateInformation:
		return (void*)soap_instantiate__tds__GetCertificateInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetCertificateInformationResponse:
		return (void*)soap_instantiate__tds__GetCertificateInformationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__LoadCACertificates:
		return (void*)soap_instantiate__tds__LoadCACertificates(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__LoadCACertificatesResponse:
		return (void*)soap_instantiate__tds__LoadCACertificatesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__CreateDot1XConfiguration:
		return (void*)soap_instantiate__tds__CreateDot1XConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__CreateDot1XConfigurationResponse:
		return (void*)soap_instantiate__tds__CreateDot1XConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetDot1XConfiguration:
		return (void*)soap_instantiate__tds__SetDot1XConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetDot1XConfigurationResponse:
		return (void*)soap_instantiate__tds__SetDot1XConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDot1XConfiguration:
		return (void*)soap_instantiate__tds__GetDot1XConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDot1XConfigurationResponse:
		return (void*)soap_instantiate__tds__GetDot1XConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDot1XConfigurations:
		return (void*)soap_instantiate__tds__GetDot1XConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDot1XConfigurationsResponse:
		return (void*)soap_instantiate__tds__GetDot1XConfigurationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__DeleteDot1XConfiguration:
		return (void*)soap_instantiate__tds__DeleteDot1XConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__DeleteDot1XConfigurationResponse:
		return (void*)soap_instantiate__tds__DeleteDot1XConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetRelayOutputs:
		return (void*)soap_instantiate__tds__GetRelayOutputs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetRelayOutputsResponse:
		return (void*)soap_instantiate__tds__GetRelayOutputsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetRelayOutputSettings:
		return (void*)soap_instantiate__tds__SetRelayOutputSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetRelayOutputSettingsResponse:
		return (void*)soap_instantiate__tds__SetRelayOutputSettingsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetRelayOutputState:
		return (void*)soap_instantiate__tds__SetRelayOutputState(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetRelayOutputStateResponse:
		return (void*)soap_instantiate__tds__SetRelayOutputStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SendAuxiliaryCommand:
		return (void*)soap_instantiate__tds__SendAuxiliaryCommand(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SendAuxiliaryCommandResponse:
		return (void*)soap_instantiate__tds__SendAuxiliaryCommandResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDot11Capabilities:
		return (void*)soap_instantiate__tds__GetDot11Capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDot11CapabilitiesResponse:
		return (void*)soap_instantiate__tds__GetDot11CapabilitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDot11Status:
		return (void*)soap_instantiate__tds__GetDot11Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetDot11StatusResponse:
		return (void*)soap_instantiate__tds__GetDot11StatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__ScanAvailableDot11Networks:
		return (void*)soap_instantiate__tds__ScanAvailableDot11Networks(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse:
		return (void*)soap_instantiate__tds__ScanAvailableDot11NetworksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemUris:
		return (void*)soap_instantiate__tds__GetSystemUris(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemUrisResponse_Extension:
		return (void*)soap_instantiate__tds__GetSystemUrisResponse_Extension(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetSystemUrisResponse:
		return (void*)soap_instantiate__tds__GetSystemUrisResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__StartFirmwareUpgrade:
		return (void*)soap_instantiate__tds__StartFirmwareUpgrade(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__StartFirmwareUpgradeResponse:
		return (void*)soap_instantiate__tds__StartFirmwareUpgradeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__StartSystemRestore:
		return (void*)soap_instantiate__tds__StartSystemRestore(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__StartSystemRestoreResponse:
		return (void*)soap_instantiate__tds__StartSystemRestoreResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetHashingAlgorithm:
		return (void*)soap_instantiate__tds__SetHashingAlgorithm(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetHashingAlgorithmResponse:
		return (void*)soap_instantiate__tds__SetHashingAlgorithmResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetStorageConfigurations:
		return (void*)soap_instantiate__tds__GetStorageConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetStorageConfigurationsResponse:
		return (void*)soap_instantiate__tds__GetStorageConfigurationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__CreateStorageConfiguration:
		return (void*)soap_instantiate__tds__CreateStorageConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__CreateStorageConfigurationResponse:
		return (void*)soap_instantiate__tds__CreateStorageConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetStorageConfiguration:
		return (void*)soap_instantiate__tds__GetStorageConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetStorageConfigurationResponse:
		return (void*)soap_instantiate__tds__GetStorageConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetStorageConfiguration:
		return (void*)soap_instantiate__tds__SetStorageConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetStorageConfigurationResponse:
		return (void*)soap_instantiate__tds__SetStorageConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__DeleteStorageConfiguration:
		return (void*)soap_instantiate__tds__DeleteStorageConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__DeleteStorageConfigurationResponse:
		return (void*)soap_instantiate__tds__DeleteStorageConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetGeoLocation:
		return (void*)soap_instantiate__tds__GetGeoLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__GetGeoLocationResponse:
		return (void*)soap_instantiate__tds__GetGeoLocationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetGeoLocation:
		return (void*)soap_instantiate__tds__SetGeoLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__SetGeoLocationResponse:
		return (void*)soap_instantiate__tds__SetGeoLocationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__DeleteGeoLocation:
		return (void*)soap_instantiate__tds__DeleteGeoLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tds__DeleteGeoLocationResponse:
		return (void*)soap_instantiate__tds__DeleteGeoLocationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DeviceEntity:
		return (void*)soap_instantiate_tt__DeviceEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Scope:
		return (void*)soap_instantiate_tt__Scope(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		return (void*)soap_instantiate_tt__NetworkInterfaceExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot3Configuration:
		return (void*)soap_instantiate_tt__Dot3Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceExtension2:
		return (void*)soap_instantiate_tt__NetworkInterfaceExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		return (void*)soap_instantiate_tt__NetworkInterfaceLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		return (void*)soap_instantiate_tt__NetworkInterfaceConnectionSetting(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		return (void*)soap_instantiate_tt__NetworkInterfaceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		return (void*)soap_instantiate_tt__IPv6NetworkInterface(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		return (void*)soap_instantiate_tt__IPv4NetworkInterface(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv4Configuration:
		return (void*)soap_instantiate_tt__IPv4Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6Configuration:
		return (void*)soap_instantiate_tt__IPv6Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		return (void*)soap_instantiate_tt__IPv6ConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkProtocol:
		return (void*)soap_instantiate_tt__NetworkProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		return (void*)soap_instantiate_tt__NetworkProtocolExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkHost:
		return (void*)soap_instantiate_tt__NetworkHost(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkHostExtension:
		return (void*)soap_instantiate_tt__NetworkHostExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPAddress:
		return (void*)soap_instantiate_tt__IPAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		return (void*)soap_instantiate_tt__PrefixedIPv4Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		return (void*)soap_instantiate_tt__PrefixedIPv6Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__HostnameInformation:
		return (void*)soap_instantiate_tt__HostnameInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__HostnameInformationExtension:
		return (void*)soap_instantiate_tt__HostnameInformationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DNSInformation:
		return (void*)soap_instantiate_tt__DNSInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DNSInformationExtension:
		return (void*)soap_instantiate_tt__DNSInformationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NTPInformation:
		return (void*)soap_instantiate_tt__NTPInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NTPInformationExtension:
		return (void*)soap_instantiate_tt__NTPInformationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DynamicDNSInformation:
		return (void*)soap_instantiate_tt__DynamicDNSInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		return (void*)soap_instantiate_tt__DynamicDNSInformationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		return (void*)soap_instantiate_tt__NetworkInterfaceSetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		return (void*)soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		return (void*)soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		return (void*)soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkGateway:
		return (void*)soap_instantiate_tt__NetworkGateway(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		return (void*)soap_instantiate_tt__NetworkZeroConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		return (void*)soap_instantiate_tt__NetworkZeroConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension2:
		return (void*)soap_instantiate_tt__NetworkZeroConfigurationExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPAddressFilter:
		return (void*)soap_instantiate_tt__IPAddressFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		return (void*)soap_instantiate_tt__IPAddressFilterExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11Configuration:
		return (void*)soap_instantiate_tt__Dot11Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11SecurityConfiguration:
		return (void*)soap_instantiate_tt__Dot11SecurityConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11SecurityConfigurationExtension:
		return (void*)soap_instantiate_tt__Dot11SecurityConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11PSKSet:
		return (void*)soap_instantiate_tt__Dot11PSKSet(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11PSKSetExtension:
		return (void*)soap_instantiate_tt__Dot11PSKSetExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2:
		return (void*)soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11Capabilities:
		return (void*)soap_instantiate_tt__Dot11Capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11Status:
		return (void*)soap_instantiate_tt__Dot11Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11AvailableNetworks:
		return (void*)soap_instantiate_tt__Dot11AvailableNetworks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11AvailableNetworksExtension:
		return (void*)soap_instantiate_tt__Dot11AvailableNetworksExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Capabilities:
		return (void*)soap_instantiate_tt__Capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CapabilitiesExtension:
		return (void*)soap_instantiate_tt__CapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CapabilitiesExtension2:
		return (void*)soap_instantiate_tt__CapabilitiesExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		return (void*)soap_instantiate_tt__AnalyticsCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DeviceCapabilities:
		return (void*)soap_instantiate_tt__DeviceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		return (void*)soap_instantiate_tt__DeviceCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EventCapabilities:
		return (void*)soap_instantiate_tt__EventCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IOCapabilities:
		return (void*)soap_instantiate_tt__IOCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		return (void*)soap_instantiate_tt__IOCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IOCapabilitiesExtension2:
		return (void*)soap_instantiate_tt__IOCapabilitiesExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MediaCapabilities:
		return (void*)soap_instantiate_tt__MediaCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		return (void*)soap_instantiate_tt__MediaCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		return (void*)soap_instantiate_tt__RealTimeStreamingCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		return (void*)soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ProfileCapabilities:
		return (void*)soap_instantiate_tt__ProfileCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkCapabilities:
		return (void*)soap_instantiate_tt__NetworkCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		return (void*)soap_instantiate_tt__NetworkCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension2:
		return (void*)soap_instantiate_tt__NetworkCapabilitiesExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SecurityCapabilities:
		return (void*)soap_instantiate_tt__SecurityCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		return (void*)soap_instantiate_tt__SecurityCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension2:
		return (void*)soap_instantiate_tt__SecurityCapabilitiesExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemCapabilities:
		return (void*)soap_instantiate_tt__SystemCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		return (void*)soap_instantiate_tt__SystemCapabilitiesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemCapabilitiesExtension2:
		return (void*)soap_instantiate_tt__SystemCapabilitiesExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__OnvifVersion:
		return (void*)soap_instantiate_tt__OnvifVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ImagingCapabilities:
		return (void*)soap_instantiate_tt__ImagingCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZCapabilities:
		return (void*)soap_instantiate_tt__PTZCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DeviceIOCapabilities:
		return (void*)soap_instantiate_tt__DeviceIOCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DisplayCapabilities:
		return (void*)soap_instantiate_tt__DisplayCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RecordingCapabilities:
		return (void*)soap_instantiate_tt__RecordingCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SearchCapabilities:
		return (void*)soap_instantiate_tt__SearchCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ReplayCapabilities:
		return (void*)soap_instantiate_tt__ReplayCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ReceiverCapabilities:
		return (void*)soap_instantiate_tt__ReceiverCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AnalyticsDeviceCapabilities:
		return (void*)soap_instantiate_tt__AnalyticsDeviceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AnalyticsDeviceExtension:
		return (void*)soap_instantiate_tt__AnalyticsDeviceExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemLog:
		return (void*)soap_instantiate_tt__SystemLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SupportInformation:
		return (void*)soap_instantiate_tt__SupportInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BinaryData:
		return (void*)soap_instantiate_tt__BinaryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AttachmentData:
		return (void*)soap_instantiate_tt__AttachmentData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__BackupFile:
		return (void*)soap_instantiate_tt__BackupFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemLogUriList:
		return (void*)soap_instantiate_tt__SystemLogUriList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemLogUri:
		return (void*)soap_instantiate_tt__SystemLogUri(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemDateTime:
		return (void*)soap_instantiate_tt__SystemDateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		return (void*)soap_instantiate_tt__SystemDateTimeExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DateTime:
		return (void*)soap_instantiate_tt__DateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Date:
		return (void*)soap_instantiate_tt__Date(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Time:
		return (void*)soap_instantiate_tt__Time(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__TimeZone:
		return (void*)soap_instantiate_tt__TimeZone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RemoteUser:
		return (void*)soap_instantiate_tt__RemoteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__User:
		return (void*)soap_instantiate_tt__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__UserExtension:
		return (void*)soap_instantiate_tt__UserExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Certificate:
		return (void*)soap_instantiate_tt__Certificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CertificateStatus:
		return (void*)soap_instantiate_tt__CertificateStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CertificateWithPrivateKey:
		return (void*)soap_instantiate_tt__CertificateWithPrivateKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CertificateInformation:
		return (void*)soap_instantiate_tt__CertificateInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CertificateInformationExtension:
		return (void*)soap_instantiate_tt__CertificateInformationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot1XConfiguration:
		return (void*)soap_instantiate_tt__Dot1XConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot1XConfigurationExtension:
		return (void*)soap_instantiate_tt__Dot1XConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EAPMethodConfiguration:
		return (void*)soap_instantiate_tt__EAPMethodConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EapMethodExtension:
		return (void*)soap_instantiate_tt__EapMethodExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__TLSConfiguration:
		return (void*)soap_instantiate_tt__TLSConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RelayOutputSettings:
		return (void*)soap_instantiate_tt__RelayOutputSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DateTimeRange:
		return (void*)soap_instantiate_tt__DateTimeRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntRange:
		return (void*)soap_instantiate_tt__IntRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__GeoLocation:
		return (void*)soap_instantiate_tt__GeoLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__GeoOrientation:
		return (void*)soap_instantiate_tt__GeoOrientation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__LocalLocation:
		return (void*)soap_instantiate_tt__LocalLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__LocalOrientation:
		return (void*)soap_instantiate_tt__LocalOrientation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__LocationEntity:
		return (void*)soap_instantiate_tt__LocationEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tds__StorageConfiguration:
		return (void*)soap_instantiate_tds__StorageConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterface:
		return (void*)soap_instantiate_tt__NetworkInterface(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__CertificateUsage:
		return (void*)soap_instantiate_tt__CertificateUsage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__RelayOutput:
		return (void*)soap_instantiate_tt__RelayOutput(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetServices:
		return (void*)soap_instantiate___tds__GetServices(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetServiceCapabilities:
		return (void*)soap_instantiate___tds__GetServiceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetDeviceInformation:
		return (void*)soap_instantiate___tds__GetDeviceInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetSystemDateAndTime:
		return (void*)soap_instantiate___tds__SetSystemDateAndTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetSystemDateAndTime:
		return (void*)soap_instantiate___tds__GetSystemDateAndTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetSystemFactoryDefault:
		return (void*)soap_instantiate___tds__SetSystemFactoryDefault(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__UpgradeSystemFirmware:
		return (void*)soap_instantiate___tds__UpgradeSystemFirmware(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SystemReboot:
		return (void*)soap_instantiate___tds__SystemReboot(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__RestoreSystem:
		return (void*)soap_instantiate___tds__RestoreSystem(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetSystemBackup:
		return (void*)soap_instantiate___tds__GetSystemBackup(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetSystemLog:
		return (void*)soap_instantiate___tds__GetSystemLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetSystemSupportInformation:
		return (void*)soap_instantiate___tds__GetSystemSupportInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetScopes:
		return (void*)soap_instantiate___tds__GetScopes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetScopes:
		return (void*)soap_instantiate___tds__SetScopes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__AddScopes:
		return (void*)soap_instantiate___tds__AddScopes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__RemoveScopes:
		return (void*)soap_instantiate___tds__RemoveScopes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetDiscoveryMode:
		return (void*)soap_instantiate___tds__GetDiscoveryMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetDiscoveryMode:
		return (void*)soap_instantiate___tds__SetDiscoveryMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetRemoteDiscoveryMode:
		return (void*)soap_instantiate___tds__GetRemoteDiscoveryMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetRemoteDiscoveryMode:
		return (void*)soap_instantiate___tds__SetRemoteDiscoveryMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetDPAddresses:
		return (void*)soap_instantiate___tds__GetDPAddresses(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetEndpointReference:
		return (void*)soap_instantiate___tds__GetEndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetRemoteUser:
		return (void*)soap_instantiate___tds__GetRemoteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetRemoteUser:
		return (void*)soap_instantiate___tds__SetRemoteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetUsers:
		return (void*)soap_instantiate___tds__GetUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__CreateUsers:
		return (void*)soap_instantiate___tds__CreateUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__DeleteUsers:
		return (void*)soap_instantiate___tds__DeleteUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetUser:
		return (void*)soap_instantiate___tds__SetUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetWsdlUrl:
		return (void*)soap_instantiate___tds__GetWsdlUrl(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetPasswordComplexityOptions:
		return (void*)soap_instantiate___tds__GetPasswordComplexityOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetPasswordComplexityConfiguration:
		return (void*)soap_instantiate___tds__GetPasswordComplexityConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetPasswordComplexityConfiguration:
		return (void*)soap_instantiate___tds__SetPasswordComplexityConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetPasswordHistoryConfiguration:
		return (void*)soap_instantiate___tds__GetPasswordHistoryConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetPasswordHistoryConfiguration:
		return (void*)soap_instantiate___tds__SetPasswordHistoryConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetAuthFailureWarningOptions:
		return (void*)soap_instantiate___tds__GetAuthFailureWarningOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetAuthFailureWarningConfiguration:
		return (void*)soap_instantiate___tds__GetAuthFailureWarningConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetAuthFailureWarningConfiguration:
		return (void*)soap_instantiate___tds__SetAuthFailureWarningConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetCapabilities:
		return (void*)soap_instantiate___tds__GetCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetDPAddresses:
		return (void*)soap_instantiate___tds__SetDPAddresses(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetHostname:
		return (void*)soap_instantiate___tds__GetHostname(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetHostname:
		return (void*)soap_instantiate___tds__SetHostname(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetHostnameFromDHCP:
		return (void*)soap_instantiate___tds__SetHostnameFromDHCP(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetDNS:
		return (void*)soap_instantiate___tds__GetDNS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetDNS:
		return (void*)soap_instantiate___tds__SetDNS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetNTP:
		return (void*)soap_instantiate___tds__GetNTP(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetNTP:
		return (void*)soap_instantiate___tds__SetNTP(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetDynamicDNS:
		return (void*)soap_instantiate___tds__GetDynamicDNS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetDynamicDNS:
		return (void*)soap_instantiate___tds__SetDynamicDNS(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetNetworkInterfaces:
		return (void*)soap_instantiate___tds__GetNetworkInterfaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetNetworkInterfaces:
		return (void*)soap_instantiate___tds__SetNetworkInterfaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetNetworkProtocols:
		return (void*)soap_instantiate___tds__GetNetworkProtocols(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetNetworkProtocols:
		return (void*)soap_instantiate___tds__SetNetworkProtocols(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetNetworkDefaultGateway:
		return (void*)soap_instantiate___tds__GetNetworkDefaultGateway(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetNetworkDefaultGateway:
		return (void*)soap_instantiate___tds__SetNetworkDefaultGateway(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetZeroConfiguration:
		return (void*)soap_instantiate___tds__GetZeroConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetZeroConfiguration:
		return (void*)soap_instantiate___tds__SetZeroConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetIPAddressFilter:
		return (void*)soap_instantiate___tds__GetIPAddressFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetIPAddressFilter:
		return (void*)soap_instantiate___tds__SetIPAddressFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__AddIPAddressFilter:
		return (void*)soap_instantiate___tds__AddIPAddressFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__RemoveIPAddressFilter:
		return (void*)soap_instantiate___tds__RemoveIPAddressFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetAccessPolicy:
		return (void*)soap_instantiate___tds__GetAccessPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetAccessPolicy:
		return (void*)soap_instantiate___tds__SetAccessPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__CreateCertificate:
		return (void*)soap_instantiate___tds__CreateCertificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetCertificates:
		return (void*)soap_instantiate___tds__GetCertificates(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetCertificatesStatus:
		return (void*)soap_instantiate___tds__GetCertificatesStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetCertificatesStatus:
		return (void*)soap_instantiate___tds__SetCertificatesStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__DeleteCertificates:
		return (void*)soap_instantiate___tds__DeleteCertificates(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetPkcs10Request:
		return (void*)soap_instantiate___tds__GetPkcs10Request(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__LoadCertificates:
		return (void*)soap_instantiate___tds__LoadCertificates(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetClientCertificateMode:
		return (void*)soap_instantiate___tds__GetClientCertificateMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetClientCertificateMode:
		return (void*)soap_instantiate___tds__SetClientCertificateMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetRelayOutputs:
		return (void*)soap_instantiate___tds__GetRelayOutputs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetRelayOutputSettings:
		return (void*)soap_instantiate___tds__SetRelayOutputSettings(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetRelayOutputState:
		return (void*)soap_instantiate___tds__SetRelayOutputState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SendAuxiliaryCommand:
		return (void*)soap_instantiate___tds__SendAuxiliaryCommand(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetCACertificates:
		return (void*)soap_instantiate___tds__GetCACertificates(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__LoadCertificateWithPrivateKey:
		return (void*)soap_instantiate___tds__LoadCertificateWithPrivateKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetCertificateInformation:
		return (void*)soap_instantiate___tds__GetCertificateInformation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__LoadCACertificates:
		return (void*)soap_instantiate___tds__LoadCACertificates(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__CreateDot1XConfiguration:
		return (void*)soap_instantiate___tds__CreateDot1XConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetDot1XConfiguration:
		return (void*)soap_instantiate___tds__SetDot1XConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetDot1XConfiguration:
		return (void*)soap_instantiate___tds__GetDot1XConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetDot1XConfigurations:
		return (void*)soap_instantiate___tds__GetDot1XConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__DeleteDot1XConfiguration:
		return (void*)soap_instantiate___tds__DeleteDot1XConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetDot11Capabilities:
		return (void*)soap_instantiate___tds__GetDot11Capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetDot11Status:
		return (void*)soap_instantiate___tds__GetDot11Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__ScanAvailableDot11Networks:
		return (void*)soap_instantiate___tds__ScanAvailableDot11Networks(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetSystemUris:
		return (void*)soap_instantiate___tds__GetSystemUris(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__StartFirmwareUpgrade:
		return (void*)soap_instantiate___tds__StartFirmwareUpgrade(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__StartSystemRestore:
		return (void*)soap_instantiate___tds__StartSystemRestore(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetStorageConfigurations:
		return (void*)soap_instantiate___tds__GetStorageConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__CreateStorageConfiguration:
		return (void*)soap_instantiate___tds__CreateStorageConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetStorageConfiguration:
		return (void*)soap_instantiate___tds__GetStorageConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetStorageConfiguration:
		return (void*)soap_instantiate___tds__SetStorageConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__DeleteStorageConfiguration:
		return (void*)soap_instantiate___tds__DeleteStorageConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__GetGeoLocation:
		return (void*)soap_instantiate___tds__GetGeoLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetGeoLocation:
		return (void*)soap_instantiate___tds__SetGeoLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__DeleteGeoLocation:
		return (void*)soap_instantiate___tds__DeleteGeoLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tds__SetHashingAlgorithm:
		return (void*)soap_instantiate___tds__SetHashingAlgorithm(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__EndpointReference:
		return (void*)soap_instantiate__wsa5__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return (void*)soap_instantiate__wsa5__ReferenceParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__Metadata:
		return (void*)soap_instantiate__wsa5__Metadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__RelatesTo:
		return (void*)soap_instantiate__wsa5__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReplyTo:
		return (void*)soap_instantiate__wsa5__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__From:
		return (void*)soap_instantiate__wsa5__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__FaultTo:
		return (void*)soap_instantiate__wsa5__FaultTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ProblemAction:
		return (void*)soap_instantiate__wsa5__ProblemAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName:
		return (void*)soap_instantiate_xsd__NCName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anySimpleType:
		return (void*)soap_instantiate_xsd__anySimpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration:
		return (void*)soap_instantiate_xsd__duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token:
		return (void*)soap_instantiate_xsd__token(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xml__lang:
		return (void*)soap_instantiate__xml__lang(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntList:
		return (void*)soap_instantiate_tt__IntList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__StringAttrList:
		return (void*)soap_instantiate_tt__StringAttrList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__StringList:
		return (void*)soap_instantiate_tt__StringList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Name:
		return (void*)soap_instantiate_tt__Name(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__NetworkInterfaceConfigPriority:
		return (void*)soap_instantiate_tt__NetworkInterfaceConfigPriority(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv4Address:
		return (void*)soap_instantiate_tt__IPv4Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IPv6Address:
		return (void*)soap_instantiate_tt__IPv6Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__HwAddress:
		return (void*)soap_instantiate_tt__HwAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DNSName:
		return (void*)soap_instantiate_tt__DNSName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11SSIDType:
		return (void*)soap_instantiate_tt__Dot11SSIDType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11PSK:
		return (void*)soap_instantiate_tt__Dot11PSK(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Dot11PSKPassphrase:
		return (void*)soap_instantiate_tt__Dot11PSKPassphrase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AuxiliaryData:
		return (void*)soap_instantiate_tt__AuxiliaryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ReferenceToken:
		return (void*)soap_instantiate_tt__ReferenceToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__SystemLogUri(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData:
		return (void*)soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher:
		return (void*)soap_instantiate_std__vectorTemplateOftt__Dot11Cipher(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite:
		return (void*)soap_instantiate_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__LocationEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__RelayOutput(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken:
		return (void*)soap_instantiate_std__vectorTemplateOftt__ReferenceToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__CertificateStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Certificate(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__IPv6Address:
		return (void*)soap_instantiate_std__vectorTemplateOftt__IPv6Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__IPv4Address:
		return (void*)soap_instantiate_std__vectorTemplateOftt__IPv4Address(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__NetworkInterface(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__token:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__token(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory:
		return (void*)soap_instantiate_std__vectorTemplateOftt__CapabilityCategory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__User:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__User(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Scope(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__BackupFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTotds__Service(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE__xop__Include:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _xop__Include*>(p->ptr), struct _xop__Include);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _xop__Include*>(p->ptr), struct _xop__Include);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__anyType*>(p->ptr), xsd__anyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__anyType*>(p->ptr), xsd__anyType);
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Envelope*>(p->ptr), struct SOAP_ENV__Envelope);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Envelope*>(p->ptr), struct SOAP_ENV__Envelope);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__hexBinary*>(p->ptr), xsd__hexBinary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__hexBinary*>(p->ptr), xsd__hexBinary);
		break;
	case SOAP_TYPE__tds__Service_Capabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__Service_Capabilities*>(p->ptr), _tds__Service_Capabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__Service_Capabilities*>(p->ptr), _tds__Service_Capabilities);
		break;
	case SOAP_TYPE_tds__Service:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tds__Service*>(p->ptr), tds__Service);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tds__Service*>(p->ptr), tds__Service);
		break;
	case SOAP_TYPE_tds__DeviceServiceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tds__DeviceServiceCapabilities*>(p->ptr), tds__DeviceServiceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tds__DeviceServiceCapabilities*>(p->ptr), tds__DeviceServiceCapabilities);
		break;
	case SOAP_TYPE_tds__NetworkCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tds__NetworkCapabilities*>(p->ptr), tds__NetworkCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tds__NetworkCapabilities*>(p->ptr), tds__NetworkCapabilities);
		break;
	case SOAP_TYPE_tds__SecurityCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tds__SecurityCapabilities*>(p->ptr), tds__SecurityCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tds__SecurityCapabilities*>(p->ptr), tds__SecurityCapabilities);
		break;
	case SOAP_TYPE_tds__SystemCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tds__SystemCapabilities*>(p->ptr), tds__SystemCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tds__SystemCapabilities*>(p->ptr), tds__SystemCapabilities);
		break;
	case SOAP_TYPE_tds__MiscCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tds__MiscCapabilities*>(p->ptr), tds__MiscCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tds__MiscCapabilities*>(p->ptr), tds__MiscCapabilities);
		break;
	case SOAP_TYPE__tds__UserCredential_Extension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__UserCredential_Extension*>(p->ptr), _tds__UserCredential_Extension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__UserCredential_Extension*>(p->ptr), _tds__UserCredential_Extension);
		break;
	case SOAP_TYPE_tds__UserCredential:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tds__UserCredential*>(p->ptr), tds__UserCredential);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tds__UserCredential*>(p->ptr), tds__UserCredential);
		break;
	case SOAP_TYPE__tds__StorageConfigurationData_Extension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__StorageConfigurationData_Extension*>(p->ptr), _tds__StorageConfigurationData_Extension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__StorageConfigurationData_Extension*>(p->ptr), _tds__StorageConfigurationData_Extension);
		break;
	case SOAP_TYPE_tds__StorageConfigurationData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tds__StorageConfigurationData*>(p->ptr), tds__StorageConfigurationData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tds__StorageConfigurationData*>(p->ptr), tds__StorageConfigurationData);
		break;
	case SOAP_TYPE__tds__GetServices:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetServices*>(p->ptr), _tds__GetServices);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetServices*>(p->ptr), _tds__GetServices);
		break;
	case SOAP_TYPE__tds__GetServicesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetServicesResponse*>(p->ptr), _tds__GetServicesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetServicesResponse*>(p->ptr), _tds__GetServicesResponse);
		break;
	case SOAP_TYPE__tds__GetServiceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetServiceCapabilities*>(p->ptr), _tds__GetServiceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetServiceCapabilities*>(p->ptr), _tds__GetServiceCapabilities);
		break;
	case SOAP_TYPE__tds__GetServiceCapabilitiesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetServiceCapabilitiesResponse*>(p->ptr), _tds__GetServiceCapabilitiesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetServiceCapabilitiesResponse*>(p->ptr), _tds__GetServiceCapabilitiesResponse);
		break;
	case SOAP_TYPE__tds__GetDeviceInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDeviceInformation*>(p->ptr), _tds__GetDeviceInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDeviceInformation*>(p->ptr), _tds__GetDeviceInformation);
		break;
	case SOAP_TYPE__tds__GetDeviceInformationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDeviceInformationResponse*>(p->ptr), _tds__GetDeviceInformationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDeviceInformationResponse*>(p->ptr), _tds__GetDeviceInformationResponse);
		break;
	case SOAP_TYPE__tds__SetSystemDateAndTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetSystemDateAndTime*>(p->ptr), _tds__SetSystemDateAndTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetSystemDateAndTime*>(p->ptr), _tds__SetSystemDateAndTime);
		break;
	case SOAP_TYPE__tds__SetSystemDateAndTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetSystemDateAndTimeResponse*>(p->ptr), _tds__SetSystemDateAndTimeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetSystemDateAndTimeResponse*>(p->ptr), _tds__SetSystemDateAndTimeResponse);
		break;
	case SOAP_TYPE__tds__GetSystemDateAndTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemDateAndTime*>(p->ptr), _tds__GetSystemDateAndTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemDateAndTime*>(p->ptr), _tds__GetSystemDateAndTime);
		break;
	case SOAP_TYPE__tds__GetSystemDateAndTimeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemDateAndTimeResponse*>(p->ptr), _tds__GetSystemDateAndTimeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemDateAndTimeResponse*>(p->ptr), _tds__GetSystemDateAndTimeResponse);
		break;
	case SOAP_TYPE__tds__SetSystemFactoryDefault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetSystemFactoryDefault*>(p->ptr), _tds__SetSystemFactoryDefault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetSystemFactoryDefault*>(p->ptr), _tds__SetSystemFactoryDefault);
		break;
	case SOAP_TYPE__tds__SetSystemFactoryDefaultResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetSystemFactoryDefaultResponse*>(p->ptr), _tds__SetSystemFactoryDefaultResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetSystemFactoryDefaultResponse*>(p->ptr), _tds__SetSystemFactoryDefaultResponse);
		break;
	case SOAP_TYPE__tds__UpgradeSystemFirmware:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__UpgradeSystemFirmware*>(p->ptr), _tds__UpgradeSystemFirmware);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__UpgradeSystemFirmware*>(p->ptr), _tds__UpgradeSystemFirmware);
		break;
	case SOAP_TYPE__tds__UpgradeSystemFirmwareResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__UpgradeSystemFirmwareResponse*>(p->ptr), _tds__UpgradeSystemFirmwareResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__UpgradeSystemFirmwareResponse*>(p->ptr), _tds__UpgradeSystemFirmwareResponse);
		break;
	case SOAP_TYPE__tds__SystemReboot:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SystemReboot*>(p->ptr), _tds__SystemReboot);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SystemReboot*>(p->ptr), _tds__SystemReboot);
		break;
	case SOAP_TYPE__tds__SystemRebootResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SystemRebootResponse*>(p->ptr), _tds__SystemRebootResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SystemRebootResponse*>(p->ptr), _tds__SystemRebootResponse);
		break;
	case SOAP_TYPE__tds__RestoreSystem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__RestoreSystem*>(p->ptr), _tds__RestoreSystem);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__RestoreSystem*>(p->ptr), _tds__RestoreSystem);
		break;
	case SOAP_TYPE__tds__RestoreSystemResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__RestoreSystemResponse*>(p->ptr), _tds__RestoreSystemResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__RestoreSystemResponse*>(p->ptr), _tds__RestoreSystemResponse);
		break;
	case SOAP_TYPE__tds__GetSystemBackup:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemBackup*>(p->ptr), _tds__GetSystemBackup);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemBackup*>(p->ptr), _tds__GetSystemBackup);
		break;
	case SOAP_TYPE__tds__GetSystemBackupResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemBackupResponse*>(p->ptr), _tds__GetSystemBackupResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemBackupResponse*>(p->ptr), _tds__GetSystemBackupResponse);
		break;
	case SOAP_TYPE__tds__GetSystemSupportInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemSupportInformation*>(p->ptr), _tds__GetSystemSupportInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemSupportInformation*>(p->ptr), _tds__GetSystemSupportInformation);
		break;
	case SOAP_TYPE__tds__GetSystemSupportInformationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemSupportInformationResponse*>(p->ptr), _tds__GetSystemSupportInformationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemSupportInformationResponse*>(p->ptr), _tds__GetSystemSupportInformationResponse);
		break;
	case SOAP_TYPE__tds__GetSystemLog:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemLog*>(p->ptr), _tds__GetSystemLog);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemLog*>(p->ptr), _tds__GetSystemLog);
		break;
	case SOAP_TYPE__tds__GetSystemLogResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemLogResponse*>(p->ptr), _tds__GetSystemLogResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemLogResponse*>(p->ptr), _tds__GetSystemLogResponse);
		break;
	case SOAP_TYPE__tds__GetScopes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetScopes*>(p->ptr), _tds__GetScopes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetScopes*>(p->ptr), _tds__GetScopes);
		break;
	case SOAP_TYPE__tds__GetScopesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetScopesResponse*>(p->ptr), _tds__GetScopesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetScopesResponse*>(p->ptr), _tds__GetScopesResponse);
		break;
	case SOAP_TYPE__tds__SetScopes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetScopes*>(p->ptr), _tds__SetScopes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetScopes*>(p->ptr), _tds__SetScopes);
		break;
	case SOAP_TYPE__tds__SetScopesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetScopesResponse*>(p->ptr), _tds__SetScopesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetScopesResponse*>(p->ptr), _tds__SetScopesResponse);
		break;
	case SOAP_TYPE__tds__AddScopes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__AddScopes*>(p->ptr), _tds__AddScopes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__AddScopes*>(p->ptr), _tds__AddScopes);
		break;
	case SOAP_TYPE__tds__AddScopesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__AddScopesResponse*>(p->ptr), _tds__AddScopesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__AddScopesResponse*>(p->ptr), _tds__AddScopesResponse);
		break;
	case SOAP_TYPE__tds__RemoveScopes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__RemoveScopes*>(p->ptr), _tds__RemoveScopes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__RemoveScopes*>(p->ptr), _tds__RemoveScopes);
		break;
	case SOAP_TYPE__tds__RemoveScopesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__RemoveScopesResponse*>(p->ptr), _tds__RemoveScopesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__RemoveScopesResponse*>(p->ptr), _tds__RemoveScopesResponse);
		break;
	case SOAP_TYPE__tds__GetDiscoveryMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDiscoveryMode*>(p->ptr), _tds__GetDiscoveryMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDiscoveryMode*>(p->ptr), _tds__GetDiscoveryMode);
		break;
	case SOAP_TYPE__tds__GetDiscoveryModeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDiscoveryModeResponse*>(p->ptr), _tds__GetDiscoveryModeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDiscoveryModeResponse*>(p->ptr), _tds__GetDiscoveryModeResponse);
		break;
	case SOAP_TYPE__tds__SetDiscoveryMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetDiscoveryMode*>(p->ptr), _tds__SetDiscoveryMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetDiscoveryMode*>(p->ptr), _tds__SetDiscoveryMode);
		break;
	case SOAP_TYPE__tds__SetDiscoveryModeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetDiscoveryModeResponse*>(p->ptr), _tds__SetDiscoveryModeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetDiscoveryModeResponse*>(p->ptr), _tds__SetDiscoveryModeResponse);
		break;
	case SOAP_TYPE__tds__GetRemoteDiscoveryMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetRemoteDiscoveryMode*>(p->ptr), _tds__GetRemoteDiscoveryMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetRemoteDiscoveryMode*>(p->ptr), _tds__GetRemoteDiscoveryMode);
		break;
	case SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetRemoteDiscoveryModeResponse*>(p->ptr), _tds__GetRemoteDiscoveryModeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetRemoteDiscoveryModeResponse*>(p->ptr), _tds__GetRemoteDiscoveryModeResponse);
		break;
	case SOAP_TYPE__tds__SetRemoteDiscoveryMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetRemoteDiscoveryMode*>(p->ptr), _tds__SetRemoteDiscoveryMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetRemoteDiscoveryMode*>(p->ptr), _tds__SetRemoteDiscoveryMode);
		break;
	case SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetRemoteDiscoveryModeResponse*>(p->ptr), _tds__SetRemoteDiscoveryModeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetRemoteDiscoveryModeResponse*>(p->ptr), _tds__SetRemoteDiscoveryModeResponse);
		break;
	case SOAP_TYPE__tds__GetDPAddresses:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDPAddresses*>(p->ptr), _tds__GetDPAddresses);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDPAddresses*>(p->ptr), _tds__GetDPAddresses);
		break;
	case SOAP_TYPE__tds__GetDPAddressesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDPAddressesResponse*>(p->ptr), _tds__GetDPAddressesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDPAddressesResponse*>(p->ptr), _tds__GetDPAddressesResponse);
		break;
	case SOAP_TYPE__tds__SetDPAddresses:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetDPAddresses*>(p->ptr), _tds__SetDPAddresses);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetDPAddresses*>(p->ptr), _tds__SetDPAddresses);
		break;
	case SOAP_TYPE__tds__SetDPAddressesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetDPAddressesResponse*>(p->ptr), _tds__SetDPAddressesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetDPAddressesResponse*>(p->ptr), _tds__SetDPAddressesResponse);
		break;
	case SOAP_TYPE__tds__GetEndpointReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetEndpointReference*>(p->ptr), _tds__GetEndpointReference);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetEndpointReference*>(p->ptr), _tds__GetEndpointReference);
		break;
	case SOAP_TYPE__tds__GetEndpointReferenceResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetEndpointReferenceResponse*>(p->ptr), _tds__GetEndpointReferenceResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetEndpointReferenceResponse*>(p->ptr), _tds__GetEndpointReferenceResponse);
		break;
	case SOAP_TYPE__tds__GetRemoteUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetRemoteUser*>(p->ptr), _tds__GetRemoteUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetRemoteUser*>(p->ptr), _tds__GetRemoteUser);
		break;
	case SOAP_TYPE__tds__GetRemoteUserResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetRemoteUserResponse*>(p->ptr), _tds__GetRemoteUserResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetRemoteUserResponse*>(p->ptr), _tds__GetRemoteUserResponse);
		break;
	case SOAP_TYPE__tds__SetRemoteUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetRemoteUser*>(p->ptr), _tds__SetRemoteUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetRemoteUser*>(p->ptr), _tds__SetRemoteUser);
		break;
	case SOAP_TYPE__tds__SetRemoteUserResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetRemoteUserResponse*>(p->ptr), _tds__SetRemoteUserResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetRemoteUserResponse*>(p->ptr), _tds__SetRemoteUserResponse);
		break;
	case SOAP_TYPE__tds__GetUsers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetUsers*>(p->ptr), _tds__GetUsers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetUsers*>(p->ptr), _tds__GetUsers);
		break;
	case SOAP_TYPE__tds__GetUsersResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetUsersResponse*>(p->ptr), _tds__GetUsersResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetUsersResponse*>(p->ptr), _tds__GetUsersResponse);
		break;
	case SOAP_TYPE__tds__CreateUsers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__CreateUsers*>(p->ptr), _tds__CreateUsers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__CreateUsers*>(p->ptr), _tds__CreateUsers);
		break;
	case SOAP_TYPE__tds__CreateUsersResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__CreateUsersResponse*>(p->ptr), _tds__CreateUsersResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__CreateUsersResponse*>(p->ptr), _tds__CreateUsersResponse);
		break;
	case SOAP_TYPE__tds__DeleteUsers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__DeleteUsers*>(p->ptr), _tds__DeleteUsers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__DeleteUsers*>(p->ptr), _tds__DeleteUsers);
		break;
	case SOAP_TYPE__tds__DeleteUsersResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__DeleteUsersResponse*>(p->ptr), _tds__DeleteUsersResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__DeleteUsersResponse*>(p->ptr), _tds__DeleteUsersResponse);
		break;
	case SOAP_TYPE__tds__SetUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetUser*>(p->ptr), _tds__SetUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetUser*>(p->ptr), _tds__SetUser);
		break;
	case SOAP_TYPE__tds__SetUserResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetUserResponse*>(p->ptr), _tds__SetUserResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetUserResponse*>(p->ptr), _tds__SetUserResponse);
		break;
	case SOAP_TYPE__tds__GetWsdlUrl:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetWsdlUrl*>(p->ptr), _tds__GetWsdlUrl);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetWsdlUrl*>(p->ptr), _tds__GetWsdlUrl);
		break;
	case SOAP_TYPE__tds__GetWsdlUrlResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetWsdlUrlResponse*>(p->ptr), _tds__GetWsdlUrlResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetWsdlUrlResponse*>(p->ptr), _tds__GetWsdlUrlResponse);
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetPasswordComplexityOptions*>(p->ptr), _tds__GetPasswordComplexityOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetPasswordComplexityOptions*>(p->ptr), _tds__GetPasswordComplexityOptions);
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetPasswordComplexityOptionsResponse*>(p->ptr), _tds__GetPasswordComplexityOptionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetPasswordComplexityOptionsResponse*>(p->ptr), _tds__GetPasswordComplexityOptionsResponse);
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetPasswordComplexityConfiguration*>(p->ptr), _tds__GetPasswordComplexityConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetPasswordComplexityConfiguration*>(p->ptr), _tds__GetPasswordComplexityConfiguration);
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetPasswordComplexityConfigurationResponse*>(p->ptr), _tds__GetPasswordComplexityConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetPasswordComplexityConfigurationResponse*>(p->ptr), _tds__GetPasswordComplexityConfigurationResponse);
		break;
	case SOAP_TYPE__tds__SetPasswordComplexityConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetPasswordComplexityConfiguration*>(p->ptr), _tds__SetPasswordComplexityConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetPasswordComplexityConfiguration*>(p->ptr), _tds__SetPasswordComplexityConfiguration);
		break;
	case SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetPasswordComplexityConfigurationResponse*>(p->ptr), _tds__SetPasswordComplexityConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetPasswordComplexityConfigurationResponse*>(p->ptr), _tds__SetPasswordComplexityConfigurationResponse);
		break;
	case SOAP_TYPE__tds__GetPasswordHistoryConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetPasswordHistoryConfiguration*>(p->ptr), _tds__GetPasswordHistoryConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetPasswordHistoryConfiguration*>(p->ptr), _tds__GetPasswordHistoryConfiguration);
		break;
	case SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetPasswordHistoryConfigurationResponse*>(p->ptr), _tds__GetPasswordHistoryConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetPasswordHistoryConfigurationResponse*>(p->ptr), _tds__GetPasswordHistoryConfigurationResponse);
		break;
	case SOAP_TYPE__tds__SetPasswordHistoryConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetPasswordHistoryConfiguration*>(p->ptr), _tds__SetPasswordHistoryConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetPasswordHistoryConfiguration*>(p->ptr), _tds__SetPasswordHistoryConfiguration);
		break;
	case SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetPasswordHistoryConfigurationResponse*>(p->ptr), _tds__SetPasswordHistoryConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetPasswordHistoryConfigurationResponse*>(p->ptr), _tds__SetPasswordHistoryConfigurationResponse);
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetAuthFailureWarningOptions*>(p->ptr), _tds__GetAuthFailureWarningOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetAuthFailureWarningOptions*>(p->ptr), _tds__GetAuthFailureWarningOptions);
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetAuthFailureWarningOptionsResponse*>(p->ptr), _tds__GetAuthFailureWarningOptionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetAuthFailureWarningOptionsResponse*>(p->ptr), _tds__GetAuthFailureWarningOptionsResponse);
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetAuthFailureWarningConfiguration*>(p->ptr), _tds__GetAuthFailureWarningConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetAuthFailureWarningConfiguration*>(p->ptr), _tds__GetAuthFailureWarningConfiguration);
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetAuthFailureWarningConfigurationResponse*>(p->ptr), _tds__GetAuthFailureWarningConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetAuthFailureWarningConfigurationResponse*>(p->ptr), _tds__GetAuthFailureWarningConfigurationResponse);
		break;
	case SOAP_TYPE__tds__SetAuthFailureWarningConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetAuthFailureWarningConfiguration*>(p->ptr), _tds__SetAuthFailureWarningConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetAuthFailureWarningConfiguration*>(p->ptr), _tds__SetAuthFailureWarningConfiguration);
		break;
	case SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetAuthFailureWarningConfigurationResponse*>(p->ptr), _tds__SetAuthFailureWarningConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetAuthFailureWarningConfigurationResponse*>(p->ptr), _tds__SetAuthFailureWarningConfigurationResponse);
		break;
	case SOAP_TYPE__tds__GetCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetCapabilities*>(p->ptr), _tds__GetCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetCapabilities*>(p->ptr), _tds__GetCapabilities);
		break;
	case SOAP_TYPE__tds__GetCapabilitiesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetCapabilitiesResponse*>(p->ptr), _tds__GetCapabilitiesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetCapabilitiesResponse*>(p->ptr), _tds__GetCapabilitiesResponse);
		break;
	case SOAP_TYPE__tds__GetHostname:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetHostname*>(p->ptr), _tds__GetHostname);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetHostname*>(p->ptr), _tds__GetHostname);
		break;
	case SOAP_TYPE__tds__GetHostnameResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetHostnameResponse*>(p->ptr), _tds__GetHostnameResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetHostnameResponse*>(p->ptr), _tds__GetHostnameResponse);
		break;
	case SOAP_TYPE__tds__SetHostname:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetHostname*>(p->ptr), _tds__SetHostname);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetHostname*>(p->ptr), _tds__SetHostname);
		break;
	case SOAP_TYPE__tds__SetHostnameResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetHostnameResponse*>(p->ptr), _tds__SetHostnameResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetHostnameResponse*>(p->ptr), _tds__SetHostnameResponse);
		break;
	case SOAP_TYPE__tds__SetHostnameFromDHCP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetHostnameFromDHCP*>(p->ptr), _tds__SetHostnameFromDHCP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetHostnameFromDHCP*>(p->ptr), _tds__SetHostnameFromDHCP);
		break;
	case SOAP_TYPE__tds__SetHostnameFromDHCPResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetHostnameFromDHCPResponse*>(p->ptr), _tds__SetHostnameFromDHCPResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetHostnameFromDHCPResponse*>(p->ptr), _tds__SetHostnameFromDHCPResponse);
		break;
	case SOAP_TYPE__tds__GetDNS:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDNS*>(p->ptr), _tds__GetDNS);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDNS*>(p->ptr), _tds__GetDNS);
		break;
	case SOAP_TYPE__tds__GetDNSResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDNSResponse*>(p->ptr), _tds__GetDNSResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDNSResponse*>(p->ptr), _tds__GetDNSResponse);
		break;
	case SOAP_TYPE__tds__SetDNS:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetDNS*>(p->ptr), _tds__SetDNS);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetDNS*>(p->ptr), _tds__SetDNS);
		break;
	case SOAP_TYPE__tds__SetDNSResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetDNSResponse*>(p->ptr), _tds__SetDNSResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetDNSResponse*>(p->ptr), _tds__SetDNSResponse);
		break;
	case SOAP_TYPE__tds__GetNTP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetNTP*>(p->ptr), _tds__GetNTP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetNTP*>(p->ptr), _tds__GetNTP);
		break;
	case SOAP_TYPE__tds__GetNTPResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetNTPResponse*>(p->ptr), _tds__GetNTPResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetNTPResponse*>(p->ptr), _tds__GetNTPResponse);
		break;
	case SOAP_TYPE__tds__SetNTP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetNTP*>(p->ptr), _tds__SetNTP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetNTP*>(p->ptr), _tds__SetNTP);
		break;
	case SOAP_TYPE__tds__SetNTPResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetNTPResponse*>(p->ptr), _tds__SetNTPResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetNTPResponse*>(p->ptr), _tds__SetNTPResponse);
		break;
	case SOAP_TYPE__tds__GetDynamicDNS:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDynamicDNS*>(p->ptr), _tds__GetDynamicDNS);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDynamicDNS*>(p->ptr), _tds__GetDynamicDNS);
		break;
	case SOAP_TYPE__tds__GetDynamicDNSResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDynamicDNSResponse*>(p->ptr), _tds__GetDynamicDNSResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDynamicDNSResponse*>(p->ptr), _tds__GetDynamicDNSResponse);
		break;
	case SOAP_TYPE__tds__SetDynamicDNS:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetDynamicDNS*>(p->ptr), _tds__SetDynamicDNS);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetDynamicDNS*>(p->ptr), _tds__SetDynamicDNS);
		break;
	case SOAP_TYPE__tds__SetDynamicDNSResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetDynamicDNSResponse*>(p->ptr), _tds__SetDynamicDNSResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetDynamicDNSResponse*>(p->ptr), _tds__SetDynamicDNSResponse);
		break;
	case SOAP_TYPE__tds__GetNetworkInterfaces:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetNetworkInterfaces*>(p->ptr), _tds__GetNetworkInterfaces);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetNetworkInterfaces*>(p->ptr), _tds__GetNetworkInterfaces);
		break;
	case SOAP_TYPE__tds__GetNetworkInterfacesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetNetworkInterfacesResponse*>(p->ptr), _tds__GetNetworkInterfacesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetNetworkInterfacesResponse*>(p->ptr), _tds__GetNetworkInterfacesResponse);
		break;
	case SOAP_TYPE__tds__SetNetworkInterfaces:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetNetworkInterfaces*>(p->ptr), _tds__SetNetworkInterfaces);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetNetworkInterfaces*>(p->ptr), _tds__SetNetworkInterfaces);
		break;
	case SOAP_TYPE__tds__SetNetworkInterfacesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetNetworkInterfacesResponse*>(p->ptr), _tds__SetNetworkInterfacesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetNetworkInterfacesResponse*>(p->ptr), _tds__SetNetworkInterfacesResponse);
		break;
	case SOAP_TYPE__tds__GetNetworkProtocols:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetNetworkProtocols*>(p->ptr), _tds__GetNetworkProtocols);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetNetworkProtocols*>(p->ptr), _tds__GetNetworkProtocols);
		break;
	case SOAP_TYPE__tds__GetNetworkProtocolsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetNetworkProtocolsResponse*>(p->ptr), _tds__GetNetworkProtocolsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetNetworkProtocolsResponse*>(p->ptr), _tds__GetNetworkProtocolsResponse);
		break;
	case SOAP_TYPE__tds__SetNetworkProtocols:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetNetworkProtocols*>(p->ptr), _tds__SetNetworkProtocols);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetNetworkProtocols*>(p->ptr), _tds__SetNetworkProtocols);
		break;
	case SOAP_TYPE__tds__SetNetworkProtocolsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetNetworkProtocolsResponse*>(p->ptr), _tds__SetNetworkProtocolsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetNetworkProtocolsResponse*>(p->ptr), _tds__SetNetworkProtocolsResponse);
		break;
	case SOAP_TYPE__tds__GetNetworkDefaultGateway:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetNetworkDefaultGateway*>(p->ptr), _tds__GetNetworkDefaultGateway);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetNetworkDefaultGateway*>(p->ptr), _tds__GetNetworkDefaultGateway);
		break;
	case SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetNetworkDefaultGatewayResponse*>(p->ptr), _tds__GetNetworkDefaultGatewayResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetNetworkDefaultGatewayResponse*>(p->ptr), _tds__GetNetworkDefaultGatewayResponse);
		break;
	case SOAP_TYPE__tds__SetNetworkDefaultGateway:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetNetworkDefaultGateway*>(p->ptr), _tds__SetNetworkDefaultGateway);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetNetworkDefaultGateway*>(p->ptr), _tds__SetNetworkDefaultGateway);
		break;
	case SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetNetworkDefaultGatewayResponse*>(p->ptr), _tds__SetNetworkDefaultGatewayResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetNetworkDefaultGatewayResponse*>(p->ptr), _tds__SetNetworkDefaultGatewayResponse);
		break;
	case SOAP_TYPE__tds__GetZeroConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetZeroConfiguration*>(p->ptr), _tds__GetZeroConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetZeroConfiguration*>(p->ptr), _tds__GetZeroConfiguration);
		break;
	case SOAP_TYPE__tds__GetZeroConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetZeroConfigurationResponse*>(p->ptr), _tds__GetZeroConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetZeroConfigurationResponse*>(p->ptr), _tds__GetZeroConfigurationResponse);
		break;
	case SOAP_TYPE__tds__SetZeroConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetZeroConfiguration*>(p->ptr), _tds__SetZeroConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetZeroConfiguration*>(p->ptr), _tds__SetZeroConfiguration);
		break;
	case SOAP_TYPE__tds__SetZeroConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetZeroConfigurationResponse*>(p->ptr), _tds__SetZeroConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetZeroConfigurationResponse*>(p->ptr), _tds__SetZeroConfigurationResponse);
		break;
	case SOAP_TYPE__tds__GetIPAddressFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetIPAddressFilter*>(p->ptr), _tds__GetIPAddressFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetIPAddressFilter*>(p->ptr), _tds__GetIPAddressFilter);
		break;
	case SOAP_TYPE__tds__GetIPAddressFilterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetIPAddressFilterResponse*>(p->ptr), _tds__GetIPAddressFilterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetIPAddressFilterResponse*>(p->ptr), _tds__GetIPAddressFilterResponse);
		break;
	case SOAP_TYPE__tds__SetIPAddressFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetIPAddressFilter*>(p->ptr), _tds__SetIPAddressFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetIPAddressFilter*>(p->ptr), _tds__SetIPAddressFilter);
		break;
	case SOAP_TYPE__tds__SetIPAddressFilterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetIPAddressFilterResponse*>(p->ptr), _tds__SetIPAddressFilterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetIPAddressFilterResponse*>(p->ptr), _tds__SetIPAddressFilterResponse);
		break;
	case SOAP_TYPE__tds__AddIPAddressFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__AddIPAddressFilter*>(p->ptr), _tds__AddIPAddressFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__AddIPAddressFilter*>(p->ptr), _tds__AddIPAddressFilter);
		break;
	case SOAP_TYPE__tds__AddIPAddressFilterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__AddIPAddressFilterResponse*>(p->ptr), _tds__AddIPAddressFilterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__AddIPAddressFilterResponse*>(p->ptr), _tds__AddIPAddressFilterResponse);
		break;
	case SOAP_TYPE__tds__RemoveIPAddressFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__RemoveIPAddressFilter*>(p->ptr), _tds__RemoveIPAddressFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__RemoveIPAddressFilter*>(p->ptr), _tds__RemoveIPAddressFilter);
		break;
	case SOAP_TYPE__tds__RemoveIPAddressFilterResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__RemoveIPAddressFilterResponse*>(p->ptr), _tds__RemoveIPAddressFilterResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__RemoveIPAddressFilterResponse*>(p->ptr), _tds__RemoveIPAddressFilterResponse);
		break;
	case SOAP_TYPE__tds__GetAccessPolicy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetAccessPolicy*>(p->ptr), _tds__GetAccessPolicy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetAccessPolicy*>(p->ptr), _tds__GetAccessPolicy);
		break;
	case SOAP_TYPE__tds__GetAccessPolicyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetAccessPolicyResponse*>(p->ptr), _tds__GetAccessPolicyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetAccessPolicyResponse*>(p->ptr), _tds__GetAccessPolicyResponse);
		break;
	case SOAP_TYPE__tds__SetAccessPolicy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetAccessPolicy*>(p->ptr), _tds__SetAccessPolicy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetAccessPolicy*>(p->ptr), _tds__SetAccessPolicy);
		break;
	case SOAP_TYPE__tds__SetAccessPolicyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetAccessPolicyResponse*>(p->ptr), _tds__SetAccessPolicyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetAccessPolicyResponse*>(p->ptr), _tds__SetAccessPolicyResponse);
		break;
	case SOAP_TYPE__tds__CreateCertificate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__CreateCertificate*>(p->ptr), _tds__CreateCertificate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__CreateCertificate*>(p->ptr), _tds__CreateCertificate);
		break;
	case SOAP_TYPE__tds__CreateCertificateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__CreateCertificateResponse*>(p->ptr), _tds__CreateCertificateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__CreateCertificateResponse*>(p->ptr), _tds__CreateCertificateResponse);
		break;
	case SOAP_TYPE__tds__GetCertificates:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetCertificates*>(p->ptr), _tds__GetCertificates);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetCertificates*>(p->ptr), _tds__GetCertificates);
		break;
	case SOAP_TYPE__tds__GetCertificatesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetCertificatesResponse*>(p->ptr), _tds__GetCertificatesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetCertificatesResponse*>(p->ptr), _tds__GetCertificatesResponse);
		break;
	case SOAP_TYPE__tds__GetCertificatesStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetCertificatesStatus*>(p->ptr), _tds__GetCertificatesStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetCertificatesStatus*>(p->ptr), _tds__GetCertificatesStatus);
		break;
	case SOAP_TYPE__tds__GetCertificatesStatusResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetCertificatesStatusResponse*>(p->ptr), _tds__GetCertificatesStatusResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetCertificatesStatusResponse*>(p->ptr), _tds__GetCertificatesStatusResponse);
		break;
	case SOAP_TYPE__tds__SetCertificatesStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetCertificatesStatus*>(p->ptr), _tds__SetCertificatesStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetCertificatesStatus*>(p->ptr), _tds__SetCertificatesStatus);
		break;
	case SOAP_TYPE__tds__SetCertificatesStatusResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetCertificatesStatusResponse*>(p->ptr), _tds__SetCertificatesStatusResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetCertificatesStatusResponse*>(p->ptr), _tds__SetCertificatesStatusResponse);
		break;
	case SOAP_TYPE__tds__DeleteCertificates:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__DeleteCertificates*>(p->ptr), _tds__DeleteCertificates);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__DeleteCertificates*>(p->ptr), _tds__DeleteCertificates);
		break;
	case SOAP_TYPE__tds__DeleteCertificatesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__DeleteCertificatesResponse*>(p->ptr), _tds__DeleteCertificatesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__DeleteCertificatesResponse*>(p->ptr), _tds__DeleteCertificatesResponse);
		break;
	case SOAP_TYPE__tds__GetPkcs10Request:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetPkcs10Request*>(p->ptr), _tds__GetPkcs10Request);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetPkcs10Request*>(p->ptr), _tds__GetPkcs10Request);
		break;
	case SOAP_TYPE__tds__GetPkcs10RequestResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetPkcs10RequestResponse*>(p->ptr), _tds__GetPkcs10RequestResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetPkcs10RequestResponse*>(p->ptr), _tds__GetPkcs10RequestResponse);
		break;
	case SOAP_TYPE__tds__LoadCertificates:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__LoadCertificates*>(p->ptr), _tds__LoadCertificates);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__LoadCertificates*>(p->ptr), _tds__LoadCertificates);
		break;
	case SOAP_TYPE__tds__LoadCertificatesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__LoadCertificatesResponse*>(p->ptr), _tds__LoadCertificatesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__LoadCertificatesResponse*>(p->ptr), _tds__LoadCertificatesResponse);
		break;
	case SOAP_TYPE__tds__GetClientCertificateMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetClientCertificateMode*>(p->ptr), _tds__GetClientCertificateMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetClientCertificateMode*>(p->ptr), _tds__GetClientCertificateMode);
		break;
	case SOAP_TYPE__tds__GetClientCertificateModeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetClientCertificateModeResponse*>(p->ptr), _tds__GetClientCertificateModeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetClientCertificateModeResponse*>(p->ptr), _tds__GetClientCertificateModeResponse);
		break;
	case SOAP_TYPE__tds__SetClientCertificateMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetClientCertificateMode*>(p->ptr), _tds__SetClientCertificateMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetClientCertificateMode*>(p->ptr), _tds__SetClientCertificateMode);
		break;
	case SOAP_TYPE__tds__SetClientCertificateModeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetClientCertificateModeResponse*>(p->ptr), _tds__SetClientCertificateModeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetClientCertificateModeResponse*>(p->ptr), _tds__SetClientCertificateModeResponse);
		break;
	case SOAP_TYPE__tds__GetCACertificates:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetCACertificates*>(p->ptr), _tds__GetCACertificates);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetCACertificates*>(p->ptr), _tds__GetCACertificates);
		break;
	case SOAP_TYPE__tds__GetCACertificatesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetCACertificatesResponse*>(p->ptr), _tds__GetCACertificatesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetCACertificatesResponse*>(p->ptr), _tds__GetCACertificatesResponse);
		break;
	case SOAP_TYPE__tds__LoadCertificateWithPrivateKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__LoadCertificateWithPrivateKey*>(p->ptr), _tds__LoadCertificateWithPrivateKey);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__LoadCertificateWithPrivateKey*>(p->ptr), _tds__LoadCertificateWithPrivateKey);
		break;
	case SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__LoadCertificateWithPrivateKeyResponse*>(p->ptr), _tds__LoadCertificateWithPrivateKeyResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__LoadCertificateWithPrivateKeyResponse*>(p->ptr), _tds__LoadCertificateWithPrivateKeyResponse);
		break;
	case SOAP_TYPE__tds__GetCertificateInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetCertificateInformation*>(p->ptr), _tds__GetCertificateInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetCertificateInformation*>(p->ptr), _tds__GetCertificateInformation);
		break;
	case SOAP_TYPE__tds__GetCertificateInformationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetCertificateInformationResponse*>(p->ptr), _tds__GetCertificateInformationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetCertificateInformationResponse*>(p->ptr), _tds__GetCertificateInformationResponse);
		break;
	case SOAP_TYPE__tds__LoadCACertificates:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__LoadCACertificates*>(p->ptr), _tds__LoadCACertificates);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__LoadCACertificates*>(p->ptr), _tds__LoadCACertificates);
		break;
	case SOAP_TYPE__tds__LoadCACertificatesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__LoadCACertificatesResponse*>(p->ptr), _tds__LoadCACertificatesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__LoadCACertificatesResponse*>(p->ptr), _tds__LoadCACertificatesResponse);
		break;
	case SOAP_TYPE__tds__CreateDot1XConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__CreateDot1XConfiguration*>(p->ptr), _tds__CreateDot1XConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__CreateDot1XConfiguration*>(p->ptr), _tds__CreateDot1XConfiguration);
		break;
	case SOAP_TYPE__tds__CreateDot1XConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__CreateDot1XConfigurationResponse*>(p->ptr), _tds__CreateDot1XConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__CreateDot1XConfigurationResponse*>(p->ptr), _tds__CreateDot1XConfigurationResponse);
		break;
	case SOAP_TYPE__tds__SetDot1XConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetDot1XConfiguration*>(p->ptr), _tds__SetDot1XConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetDot1XConfiguration*>(p->ptr), _tds__SetDot1XConfiguration);
		break;
	case SOAP_TYPE__tds__SetDot1XConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetDot1XConfigurationResponse*>(p->ptr), _tds__SetDot1XConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetDot1XConfigurationResponse*>(p->ptr), _tds__SetDot1XConfigurationResponse);
		break;
	case SOAP_TYPE__tds__GetDot1XConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDot1XConfiguration*>(p->ptr), _tds__GetDot1XConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDot1XConfiguration*>(p->ptr), _tds__GetDot1XConfiguration);
		break;
	case SOAP_TYPE__tds__GetDot1XConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDot1XConfigurationResponse*>(p->ptr), _tds__GetDot1XConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDot1XConfigurationResponse*>(p->ptr), _tds__GetDot1XConfigurationResponse);
		break;
	case SOAP_TYPE__tds__GetDot1XConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDot1XConfigurations*>(p->ptr), _tds__GetDot1XConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDot1XConfigurations*>(p->ptr), _tds__GetDot1XConfigurations);
		break;
	case SOAP_TYPE__tds__GetDot1XConfigurationsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDot1XConfigurationsResponse*>(p->ptr), _tds__GetDot1XConfigurationsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDot1XConfigurationsResponse*>(p->ptr), _tds__GetDot1XConfigurationsResponse);
		break;
	case SOAP_TYPE__tds__DeleteDot1XConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__DeleteDot1XConfiguration*>(p->ptr), _tds__DeleteDot1XConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__DeleteDot1XConfiguration*>(p->ptr), _tds__DeleteDot1XConfiguration);
		break;
	case SOAP_TYPE__tds__DeleteDot1XConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__DeleteDot1XConfigurationResponse*>(p->ptr), _tds__DeleteDot1XConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__DeleteDot1XConfigurationResponse*>(p->ptr), _tds__DeleteDot1XConfigurationResponse);
		break;
	case SOAP_TYPE__tds__GetRelayOutputs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetRelayOutputs*>(p->ptr), _tds__GetRelayOutputs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetRelayOutputs*>(p->ptr), _tds__GetRelayOutputs);
		break;
	case SOAP_TYPE__tds__GetRelayOutputsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetRelayOutputsResponse*>(p->ptr), _tds__GetRelayOutputsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetRelayOutputsResponse*>(p->ptr), _tds__GetRelayOutputsResponse);
		break;
	case SOAP_TYPE__tds__SetRelayOutputSettings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetRelayOutputSettings*>(p->ptr), _tds__SetRelayOutputSettings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetRelayOutputSettings*>(p->ptr), _tds__SetRelayOutputSettings);
		break;
	case SOAP_TYPE__tds__SetRelayOutputSettingsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetRelayOutputSettingsResponse*>(p->ptr), _tds__SetRelayOutputSettingsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetRelayOutputSettingsResponse*>(p->ptr), _tds__SetRelayOutputSettingsResponse);
		break;
	case SOAP_TYPE__tds__SetRelayOutputState:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetRelayOutputState*>(p->ptr), _tds__SetRelayOutputState);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetRelayOutputState*>(p->ptr), _tds__SetRelayOutputState);
		break;
	case SOAP_TYPE__tds__SetRelayOutputStateResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetRelayOutputStateResponse*>(p->ptr), _tds__SetRelayOutputStateResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetRelayOutputStateResponse*>(p->ptr), _tds__SetRelayOutputStateResponse);
		break;
	case SOAP_TYPE__tds__SendAuxiliaryCommand:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SendAuxiliaryCommand*>(p->ptr), _tds__SendAuxiliaryCommand);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SendAuxiliaryCommand*>(p->ptr), _tds__SendAuxiliaryCommand);
		break;
	case SOAP_TYPE__tds__SendAuxiliaryCommandResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SendAuxiliaryCommandResponse*>(p->ptr), _tds__SendAuxiliaryCommandResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SendAuxiliaryCommandResponse*>(p->ptr), _tds__SendAuxiliaryCommandResponse);
		break;
	case SOAP_TYPE__tds__GetDot11Capabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDot11Capabilities*>(p->ptr), _tds__GetDot11Capabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDot11Capabilities*>(p->ptr), _tds__GetDot11Capabilities);
		break;
	case SOAP_TYPE__tds__GetDot11CapabilitiesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDot11CapabilitiesResponse*>(p->ptr), _tds__GetDot11CapabilitiesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDot11CapabilitiesResponse*>(p->ptr), _tds__GetDot11CapabilitiesResponse);
		break;
	case SOAP_TYPE__tds__GetDot11Status:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDot11Status*>(p->ptr), _tds__GetDot11Status);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDot11Status*>(p->ptr), _tds__GetDot11Status);
		break;
	case SOAP_TYPE__tds__GetDot11StatusResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetDot11StatusResponse*>(p->ptr), _tds__GetDot11StatusResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetDot11StatusResponse*>(p->ptr), _tds__GetDot11StatusResponse);
		break;
	case SOAP_TYPE__tds__ScanAvailableDot11Networks:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__ScanAvailableDot11Networks*>(p->ptr), _tds__ScanAvailableDot11Networks);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__ScanAvailableDot11Networks*>(p->ptr), _tds__ScanAvailableDot11Networks);
		break;
	case SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__ScanAvailableDot11NetworksResponse*>(p->ptr), _tds__ScanAvailableDot11NetworksResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__ScanAvailableDot11NetworksResponse*>(p->ptr), _tds__ScanAvailableDot11NetworksResponse);
		break;
	case SOAP_TYPE__tds__GetSystemUris:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemUris*>(p->ptr), _tds__GetSystemUris);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemUris*>(p->ptr), _tds__GetSystemUris);
		break;
	case SOAP_TYPE__tds__GetSystemUrisResponse_Extension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemUrisResponse_Extension*>(p->ptr), _tds__GetSystemUrisResponse_Extension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemUrisResponse_Extension*>(p->ptr), _tds__GetSystemUrisResponse_Extension);
		break;
	case SOAP_TYPE__tds__GetSystemUrisResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetSystemUrisResponse*>(p->ptr), _tds__GetSystemUrisResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetSystemUrisResponse*>(p->ptr), _tds__GetSystemUrisResponse);
		break;
	case SOAP_TYPE__tds__StartFirmwareUpgrade:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__StartFirmwareUpgrade*>(p->ptr), _tds__StartFirmwareUpgrade);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__StartFirmwareUpgrade*>(p->ptr), _tds__StartFirmwareUpgrade);
		break;
	case SOAP_TYPE__tds__StartFirmwareUpgradeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__StartFirmwareUpgradeResponse*>(p->ptr), _tds__StartFirmwareUpgradeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__StartFirmwareUpgradeResponse*>(p->ptr), _tds__StartFirmwareUpgradeResponse);
		break;
	case SOAP_TYPE__tds__StartSystemRestore:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__StartSystemRestore*>(p->ptr), _tds__StartSystemRestore);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__StartSystemRestore*>(p->ptr), _tds__StartSystemRestore);
		break;
	case SOAP_TYPE__tds__StartSystemRestoreResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__StartSystemRestoreResponse*>(p->ptr), _tds__StartSystemRestoreResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__StartSystemRestoreResponse*>(p->ptr), _tds__StartSystemRestoreResponse);
		break;
	case SOAP_TYPE__tds__SetHashingAlgorithm:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetHashingAlgorithm*>(p->ptr), _tds__SetHashingAlgorithm);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetHashingAlgorithm*>(p->ptr), _tds__SetHashingAlgorithm);
		break;
	case SOAP_TYPE__tds__SetHashingAlgorithmResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetHashingAlgorithmResponse*>(p->ptr), _tds__SetHashingAlgorithmResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetHashingAlgorithmResponse*>(p->ptr), _tds__SetHashingAlgorithmResponse);
		break;
	case SOAP_TYPE__tds__GetStorageConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetStorageConfigurations*>(p->ptr), _tds__GetStorageConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetStorageConfigurations*>(p->ptr), _tds__GetStorageConfigurations);
		break;
	case SOAP_TYPE__tds__GetStorageConfigurationsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetStorageConfigurationsResponse*>(p->ptr), _tds__GetStorageConfigurationsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetStorageConfigurationsResponse*>(p->ptr), _tds__GetStorageConfigurationsResponse);
		break;
	case SOAP_TYPE__tds__CreateStorageConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__CreateStorageConfiguration*>(p->ptr), _tds__CreateStorageConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__CreateStorageConfiguration*>(p->ptr), _tds__CreateStorageConfiguration);
		break;
	case SOAP_TYPE__tds__CreateStorageConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__CreateStorageConfigurationResponse*>(p->ptr), _tds__CreateStorageConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__CreateStorageConfigurationResponse*>(p->ptr), _tds__CreateStorageConfigurationResponse);
		break;
	case SOAP_TYPE__tds__GetStorageConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetStorageConfiguration*>(p->ptr), _tds__GetStorageConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetStorageConfiguration*>(p->ptr), _tds__GetStorageConfiguration);
		break;
	case SOAP_TYPE__tds__GetStorageConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetStorageConfigurationResponse*>(p->ptr), _tds__GetStorageConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetStorageConfigurationResponse*>(p->ptr), _tds__GetStorageConfigurationResponse);
		break;
	case SOAP_TYPE__tds__SetStorageConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetStorageConfiguration*>(p->ptr), _tds__SetStorageConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetStorageConfiguration*>(p->ptr), _tds__SetStorageConfiguration);
		break;
	case SOAP_TYPE__tds__SetStorageConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetStorageConfigurationResponse*>(p->ptr), _tds__SetStorageConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetStorageConfigurationResponse*>(p->ptr), _tds__SetStorageConfigurationResponse);
		break;
	case SOAP_TYPE__tds__DeleteStorageConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__DeleteStorageConfiguration*>(p->ptr), _tds__DeleteStorageConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__DeleteStorageConfiguration*>(p->ptr), _tds__DeleteStorageConfiguration);
		break;
	case SOAP_TYPE__tds__DeleteStorageConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__DeleteStorageConfigurationResponse*>(p->ptr), _tds__DeleteStorageConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__DeleteStorageConfigurationResponse*>(p->ptr), _tds__DeleteStorageConfigurationResponse);
		break;
	case SOAP_TYPE__tds__GetGeoLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetGeoLocation*>(p->ptr), _tds__GetGeoLocation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetGeoLocation*>(p->ptr), _tds__GetGeoLocation);
		break;
	case SOAP_TYPE__tds__GetGeoLocationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__GetGeoLocationResponse*>(p->ptr), _tds__GetGeoLocationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__GetGeoLocationResponse*>(p->ptr), _tds__GetGeoLocationResponse);
		break;
	case SOAP_TYPE__tds__SetGeoLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetGeoLocation*>(p->ptr), _tds__SetGeoLocation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetGeoLocation*>(p->ptr), _tds__SetGeoLocation);
		break;
	case SOAP_TYPE__tds__SetGeoLocationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__SetGeoLocationResponse*>(p->ptr), _tds__SetGeoLocationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__SetGeoLocationResponse*>(p->ptr), _tds__SetGeoLocationResponse);
		break;
	case SOAP_TYPE__tds__DeleteGeoLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__DeleteGeoLocation*>(p->ptr), _tds__DeleteGeoLocation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__DeleteGeoLocation*>(p->ptr), _tds__DeleteGeoLocation);
		break;
	case SOAP_TYPE__tds__DeleteGeoLocationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tds__DeleteGeoLocationResponse*>(p->ptr), _tds__DeleteGeoLocationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tds__DeleteGeoLocationResponse*>(p->ptr), _tds__DeleteGeoLocationResponse);
		break;
	case SOAP_TYPE_tt__DeviceEntity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DeviceEntity*>(p->ptr), tt__DeviceEntity);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DeviceEntity*>(p->ptr), tt__DeviceEntity);
		break;
	case SOAP_TYPE_tt__Scope:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Scope*>(p->ptr), tt__Scope);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Scope*>(p->ptr), tt__Scope);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkInterfaceExtension*>(p->ptr), tt__NetworkInterfaceExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkInterfaceExtension*>(p->ptr), tt__NetworkInterfaceExtension);
		break;
	case SOAP_TYPE_tt__Dot3Configuration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot3Configuration*>(p->ptr), tt__Dot3Configuration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot3Configuration*>(p->ptr), tt__Dot3Configuration);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkInterfaceExtension2*>(p->ptr), tt__NetworkInterfaceExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkInterfaceExtension2*>(p->ptr), tt__NetworkInterfaceExtension2);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkInterfaceLink*>(p->ptr), tt__NetworkInterfaceLink);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkInterfaceLink*>(p->ptr), tt__NetworkInterfaceLink);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkInterfaceConnectionSetting*>(p->ptr), tt__NetworkInterfaceConnectionSetting);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkInterfaceConnectionSetting*>(p->ptr), tt__NetworkInterfaceConnectionSetting);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkInterfaceInfo*>(p->ptr), tt__NetworkInterfaceInfo);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkInterfaceInfo*>(p->ptr), tt__NetworkInterfaceInfo);
		break;
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPv6NetworkInterface*>(p->ptr), tt__IPv6NetworkInterface);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPv6NetworkInterface*>(p->ptr), tt__IPv6NetworkInterface);
		break;
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPv4NetworkInterface*>(p->ptr), tt__IPv4NetworkInterface);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPv4NetworkInterface*>(p->ptr), tt__IPv4NetworkInterface);
		break;
	case SOAP_TYPE_tt__IPv4Configuration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPv4Configuration*>(p->ptr), tt__IPv4Configuration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPv4Configuration*>(p->ptr), tt__IPv4Configuration);
		break;
	case SOAP_TYPE_tt__IPv6Configuration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPv6Configuration*>(p->ptr), tt__IPv6Configuration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPv6Configuration*>(p->ptr), tt__IPv6Configuration);
		break;
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPv6ConfigurationExtension*>(p->ptr), tt__IPv6ConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPv6ConfigurationExtension*>(p->ptr), tt__IPv6ConfigurationExtension);
		break;
	case SOAP_TYPE_tt__NetworkProtocol:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkProtocol*>(p->ptr), tt__NetworkProtocol);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkProtocol*>(p->ptr), tt__NetworkProtocol);
		break;
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkProtocolExtension*>(p->ptr), tt__NetworkProtocolExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkProtocolExtension*>(p->ptr), tt__NetworkProtocolExtension);
		break;
	case SOAP_TYPE_tt__NetworkHost:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkHost*>(p->ptr), tt__NetworkHost);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkHost*>(p->ptr), tt__NetworkHost);
		break;
	case SOAP_TYPE_tt__NetworkHostExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkHostExtension*>(p->ptr), tt__NetworkHostExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkHostExtension*>(p->ptr), tt__NetworkHostExtension);
		break;
	case SOAP_TYPE_tt__IPAddress:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPAddress*>(p->ptr), tt__IPAddress);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPAddress*>(p->ptr), tt__IPAddress);
		break;
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PrefixedIPv4Address*>(p->ptr), tt__PrefixedIPv4Address);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PrefixedIPv4Address*>(p->ptr), tt__PrefixedIPv4Address);
		break;
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PrefixedIPv6Address*>(p->ptr), tt__PrefixedIPv6Address);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PrefixedIPv6Address*>(p->ptr), tt__PrefixedIPv6Address);
		break;
	case SOAP_TYPE_tt__HostnameInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__HostnameInformation*>(p->ptr), tt__HostnameInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__HostnameInformation*>(p->ptr), tt__HostnameInformation);
		break;
	case SOAP_TYPE_tt__HostnameInformationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__HostnameInformationExtension*>(p->ptr), tt__HostnameInformationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__HostnameInformationExtension*>(p->ptr), tt__HostnameInformationExtension);
		break;
	case SOAP_TYPE_tt__DNSInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DNSInformation*>(p->ptr), tt__DNSInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DNSInformation*>(p->ptr), tt__DNSInformation);
		break;
	case SOAP_TYPE_tt__DNSInformationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DNSInformationExtension*>(p->ptr), tt__DNSInformationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DNSInformationExtension*>(p->ptr), tt__DNSInformationExtension);
		break;
	case SOAP_TYPE_tt__NTPInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NTPInformation*>(p->ptr), tt__NTPInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NTPInformation*>(p->ptr), tt__NTPInformation);
		break;
	case SOAP_TYPE_tt__NTPInformationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NTPInformationExtension*>(p->ptr), tt__NTPInformationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NTPInformationExtension*>(p->ptr), tt__NTPInformationExtension);
		break;
	case SOAP_TYPE_tt__DynamicDNSInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DynamicDNSInformation*>(p->ptr), tt__DynamicDNSInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DynamicDNSInformation*>(p->ptr), tt__DynamicDNSInformation);
		break;
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DynamicDNSInformationExtension*>(p->ptr), tt__DynamicDNSInformationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DynamicDNSInformationExtension*>(p->ptr), tt__DynamicDNSInformationExtension);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkInterfaceSetConfiguration*>(p->ptr), tt__NetworkInterfaceSetConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkInterfaceSetConfiguration*>(p->ptr), tt__NetworkInterfaceSetConfiguration);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkInterfaceSetConfigurationExtension*>(p->ptr), tt__NetworkInterfaceSetConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkInterfaceSetConfigurationExtension*>(p->ptr), tt__NetworkInterfaceSetConfigurationExtension);
		break;
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPv6NetworkInterfaceSetConfiguration*>(p->ptr), tt__IPv6NetworkInterfaceSetConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPv6NetworkInterfaceSetConfiguration*>(p->ptr), tt__IPv6NetworkInterfaceSetConfiguration);
		break;
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPv4NetworkInterfaceSetConfiguration*>(p->ptr), tt__IPv4NetworkInterfaceSetConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPv4NetworkInterfaceSetConfiguration*>(p->ptr), tt__IPv4NetworkInterfaceSetConfiguration);
		break;
	case SOAP_TYPE_tt__NetworkGateway:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkGateway*>(p->ptr), tt__NetworkGateway);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkGateway*>(p->ptr), tt__NetworkGateway);
		break;
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkZeroConfiguration*>(p->ptr), tt__NetworkZeroConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkZeroConfiguration*>(p->ptr), tt__NetworkZeroConfiguration);
		break;
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkZeroConfigurationExtension*>(p->ptr), tt__NetworkZeroConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkZeroConfigurationExtension*>(p->ptr), tt__NetworkZeroConfigurationExtension);
		break;
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkZeroConfigurationExtension2*>(p->ptr), tt__NetworkZeroConfigurationExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkZeroConfigurationExtension2*>(p->ptr), tt__NetworkZeroConfigurationExtension2);
		break;
	case SOAP_TYPE_tt__IPAddressFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPAddressFilter*>(p->ptr), tt__IPAddressFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPAddressFilter*>(p->ptr), tt__IPAddressFilter);
		break;
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IPAddressFilterExtension*>(p->ptr), tt__IPAddressFilterExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IPAddressFilterExtension*>(p->ptr), tt__IPAddressFilterExtension);
		break;
	case SOAP_TYPE_tt__Dot11Configuration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot11Configuration*>(p->ptr), tt__Dot11Configuration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot11Configuration*>(p->ptr), tt__Dot11Configuration);
		break;
	case SOAP_TYPE_tt__Dot11SecurityConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot11SecurityConfiguration*>(p->ptr), tt__Dot11SecurityConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot11SecurityConfiguration*>(p->ptr), tt__Dot11SecurityConfiguration);
		break;
	case SOAP_TYPE_tt__Dot11SecurityConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot11SecurityConfigurationExtension*>(p->ptr), tt__Dot11SecurityConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot11SecurityConfigurationExtension*>(p->ptr), tt__Dot11SecurityConfigurationExtension);
		break;
	case SOAP_TYPE_tt__Dot11PSKSet:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot11PSKSet*>(p->ptr), tt__Dot11PSKSet);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot11PSKSet*>(p->ptr), tt__Dot11PSKSet);
		break;
	case SOAP_TYPE_tt__Dot11PSKSetExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot11PSKSetExtension*>(p->ptr), tt__Dot11PSKSetExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot11PSKSetExtension*>(p->ptr), tt__Dot11PSKSetExtension);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkInterfaceSetConfigurationExtension2*>(p->ptr), tt__NetworkInterfaceSetConfigurationExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkInterfaceSetConfigurationExtension2*>(p->ptr), tt__NetworkInterfaceSetConfigurationExtension2);
		break;
	case SOAP_TYPE_tt__Dot11Capabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot11Capabilities*>(p->ptr), tt__Dot11Capabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot11Capabilities*>(p->ptr), tt__Dot11Capabilities);
		break;
	case SOAP_TYPE_tt__Dot11Status:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot11Status*>(p->ptr), tt__Dot11Status);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot11Status*>(p->ptr), tt__Dot11Status);
		break;
	case SOAP_TYPE_tt__Dot11AvailableNetworks:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot11AvailableNetworks*>(p->ptr), tt__Dot11AvailableNetworks);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot11AvailableNetworks*>(p->ptr), tt__Dot11AvailableNetworks);
		break;
	case SOAP_TYPE_tt__Dot11AvailableNetworksExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot11AvailableNetworksExtension*>(p->ptr), tt__Dot11AvailableNetworksExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot11AvailableNetworksExtension*>(p->ptr), tt__Dot11AvailableNetworksExtension);
		break;
	case SOAP_TYPE_tt__Capabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Capabilities*>(p->ptr), tt__Capabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Capabilities*>(p->ptr), tt__Capabilities);
		break;
	case SOAP_TYPE_tt__CapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__CapabilitiesExtension*>(p->ptr), tt__CapabilitiesExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__CapabilitiesExtension*>(p->ptr), tt__CapabilitiesExtension);
		break;
	case SOAP_TYPE_tt__CapabilitiesExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__CapabilitiesExtension2*>(p->ptr), tt__CapabilitiesExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__CapabilitiesExtension2*>(p->ptr), tt__CapabilitiesExtension2);
		break;
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AnalyticsCapabilities*>(p->ptr), tt__AnalyticsCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AnalyticsCapabilities*>(p->ptr), tt__AnalyticsCapabilities);
		break;
	case SOAP_TYPE_tt__DeviceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DeviceCapabilities*>(p->ptr), tt__DeviceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DeviceCapabilities*>(p->ptr), tt__DeviceCapabilities);
		break;
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DeviceCapabilitiesExtension*>(p->ptr), tt__DeviceCapabilitiesExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DeviceCapabilitiesExtension*>(p->ptr), tt__DeviceCapabilitiesExtension);
		break;
	case SOAP_TYPE_tt__EventCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__EventCapabilities*>(p->ptr), tt__EventCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__EventCapabilities*>(p->ptr), tt__EventCapabilities);
		break;
	case SOAP_TYPE_tt__IOCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IOCapabilities*>(p->ptr), tt__IOCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IOCapabilities*>(p->ptr), tt__IOCapabilities);
		break;
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IOCapabilitiesExtension*>(p->ptr), tt__IOCapabilitiesExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IOCapabilitiesExtension*>(p->ptr), tt__IOCapabilitiesExtension);
		break;
	case SOAP_TYPE_tt__IOCapabilitiesExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IOCapabilitiesExtension2*>(p->ptr), tt__IOCapabilitiesExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IOCapabilitiesExtension2*>(p->ptr), tt__IOCapabilitiesExtension2);
		break;
	case SOAP_TYPE_tt__MediaCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__MediaCapabilities*>(p->ptr), tt__MediaCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__MediaCapabilities*>(p->ptr), tt__MediaCapabilities);
		break;
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__MediaCapabilitiesExtension*>(p->ptr), tt__MediaCapabilitiesExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__MediaCapabilitiesExtension*>(p->ptr), tt__MediaCapabilitiesExtension);
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RealTimeStreamingCapabilities*>(p->ptr), tt__RealTimeStreamingCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RealTimeStreamingCapabilities*>(p->ptr), tt__RealTimeStreamingCapabilities);
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RealTimeStreamingCapabilitiesExtension*>(p->ptr), tt__RealTimeStreamingCapabilitiesExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RealTimeStreamingCapabilitiesExtension*>(p->ptr), tt__RealTimeStreamingCapabilitiesExtension);
		break;
	case SOAP_TYPE_tt__ProfileCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ProfileCapabilities*>(p->ptr), tt__ProfileCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ProfileCapabilities*>(p->ptr), tt__ProfileCapabilities);
		break;
	case SOAP_TYPE_tt__NetworkCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkCapabilities*>(p->ptr), tt__NetworkCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkCapabilities*>(p->ptr), tt__NetworkCapabilities);
		break;
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkCapabilitiesExtension*>(p->ptr), tt__NetworkCapabilitiesExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkCapabilitiesExtension*>(p->ptr), tt__NetworkCapabilitiesExtension);
		break;
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkCapabilitiesExtension2*>(p->ptr), tt__NetworkCapabilitiesExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkCapabilitiesExtension2*>(p->ptr), tt__NetworkCapabilitiesExtension2);
		break;
	case SOAP_TYPE_tt__SecurityCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SecurityCapabilities*>(p->ptr), tt__SecurityCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SecurityCapabilities*>(p->ptr), tt__SecurityCapabilities);
		break;
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SecurityCapabilitiesExtension*>(p->ptr), tt__SecurityCapabilitiesExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SecurityCapabilitiesExtension*>(p->ptr), tt__SecurityCapabilitiesExtension);
		break;
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SecurityCapabilitiesExtension2*>(p->ptr), tt__SecurityCapabilitiesExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SecurityCapabilitiesExtension2*>(p->ptr), tt__SecurityCapabilitiesExtension2);
		break;
	case SOAP_TYPE_tt__SystemCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SystemCapabilities*>(p->ptr), tt__SystemCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SystemCapabilities*>(p->ptr), tt__SystemCapabilities);
		break;
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SystemCapabilitiesExtension*>(p->ptr), tt__SystemCapabilitiesExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SystemCapabilitiesExtension*>(p->ptr), tt__SystemCapabilitiesExtension);
		break;
	case SOAP_TYPE_tt__SystemCapabilitiesExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SystemCapabilitiesExtension2*>(p->ptr), tt__SystemCapabilitiesExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SystemCapabilitiesExtension2*>(p->ptr), tt__SystemCapabilitiesExtension2);
		break;
	case SOAP_TYPE_tt__OnvifVersion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__OnvifVersion*>(p->ptr), tt__OnvifVersion);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__OnvifVersion*>(p->ptr), tt__OnvifVersion);
		break;
	case SOAP_TYPE_tt__ImagingCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ImagingCapabilities*>(p->ptr), tt__ImagingCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ImagingCapabilities*>(p->ptr), tt__ImagingCapabilities);
		break;
	case SOAP_TYPE_tt__PTZCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZCapabilities*>(p->ptr), tt__PTZCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZCapabilities*>(p->ptr), tt__PTZCapabilities);
		break;
	case SOAP_TYPE_tt__DeviceIOCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DeviceIOCapabilities*>(p->ptr), tt__DeviceIOCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DeviceIOCapabilities*>(p->ptr), tt__DeviceIOCapabilities);
		break;
	case SOAP_TYPE_tt__DisplayCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DisplayCapabilities*>(p->ptr), tt__DisplayCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DisplayCapabilities*>(p->ptr), tt__DisplayCapabilities);
		break;
	case SOAP_TYPE_tt__RecordingCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RecordingCapabilities*>(p->ptr), tt__RecordingCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RecordingCapabilities*>(p->ptr), tt__RecordingCapabilities);
		break;
	case SOAP_TYPE_tt__SearchCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SearchCapabilities*>(p->ptr), tt__SearchCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SearchCapabilities*>(p->ptr), tt__SearchCapabilities);
		break;
	case SOAP_TYPE_tt__ReplayCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ReplayCapabilities*>(p->ptr), tt__ReplayCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ReplayCapabilities*>(p->ptr), tt__ReplayCapabilities);
		break;
	case SOAP_TYPE_tt__ReceiverCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ReceiverCapabilities*>(p->ptr), tt__ReceiverCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ReceiverCapabilities*>(p->ptr), tt__ReceiverCapabilities);
		break;
	case SOAP_TYPE_tt__AnalyticsDeviceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AnalyticsDeviceCapabilities*>(p->ptr), tt__AnalyticsDeviceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AnalyticsDeviceCapabilities*>(p->ptr), tt__AnalyticsDeviceCapabilities);
		break;
	case SOAP_TYPE_tt__AnalyticsDeviceExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AnalyticsDeviceExtension*>(p->ptr), tt__AnalyticsDeviceExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AnalyticsDeviceExtension*>(p->ptr), tt__AnalyticsDeviceExtension);
		break;
	case SOAP_TYPE_tt__SystemLog:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SystemLog*>(p->ptr), tt__SystemLog);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SystemLog*>(p->ptr), tt__SystemLog);
		break;
	case SOAP_TYPE_tt__SupportInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SupportInformation*>(p->ptr), tt__SupportInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SupportInformation*>(p->ptr), tt__SupportInformation);
		break;
	case SOAP_TYPE_tt__BinaryData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__BinaryData*>(p->ptr), tt__BinaryData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__BinaryData*>(p->ptr), tt__BinaryData);
		break;
	case SOAP_TYPE_tt__AttachmentData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__AttachmentData*>(p->ptr), tt__AttachmentData);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__AttachmentData*>(p->ptr), tt__AttachmentData);
		break;
	case SOAP_TYPE_tt__BackupFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__BackupFile*>(p->ptr), tt__BackupFile);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__BackupFile*>(p->ptr), tt__BackupFile);
		break;
	case SOAP_TYPE_tt__SystemLogUriList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SystemLogUriList*>(p->ptr), tt__SystemLogUriList);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SystemLogUriList*>(p->ptr), tt__SystemLogUriList);
		break;
	case SOAP_TYPE_tt__SystemLogUri:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SystemLogUri*>(p->ptr), tt__SystemLogUri);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SystemLogUri*>(p->ptr), tt__SystemLogUri);
		break;
	case SOAP_TYPE_tt__SystemDateTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SystemDateTime*>(p->ptr), tt__SystemDateTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SystemDateTime*>(p->ptr), tt__SystemDateTime);
		break;
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__SystemDateTimeExtension*>(p->ptr), tt__SystemDateTimeExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__SystemDateTimeExtension*>(p->ptr), tt__SystemDateTimeExtension);
		break;
	case SOAP_TYPE_tt__DateTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DateTime*>(p->ptr), tt__DateTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DateTime*>(p->ptr), tt__DateTime);
		break;
	case SOAP_TYPE_tt__Date:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Date*>(p->ptr), tt__Date);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Date*>(p->ptr), tt__Date);
		break;
	case SOAP_TYPE_tt__Time:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Time*>(p->ptr), tt__Time);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Time*>(p->ptr), tt__Time);
		break;
	case SOAP_TYPE_tt__TimeZone:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__TimeZone*>(p->ptr), tt__TimeZone);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__TimeZone*>(p->ptr), tt__TimeZone);
		break;
	case SOAP_TYPE_tt__RemoteUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RemoteUser*>(p->ptr), tt__RemoteUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RemoteUser*>(p->ptr), tt__RemoteUser);
		break;
	case SOAP_TYPE_tt__User:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__User*>(p->ptr), tt__User);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__User*>(p->ptr), tt__User);
		break;
	case SOAP_TYPE_tt__UserExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__UserExtension*>(p->ptr), tt__UserExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__UserExtension*>(p->ptr), tt__UserExtension);
		break;
	case SOAP_TYPE_tt__Certificate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Certificate*>(p->ptr), tt__Certificate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Certificate*>(p->ptr), tt__Certificate);
		break;
	case SOAP_TYPE_tt__CertificateStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__CertificateStatus*>(p->ptr), tt__CertificateStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__CertificateStatus*>(p->ptr), tt__CertificateStatus);
		break;
	case SOAP_TYPE_tt__CertificateWithPrivateKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__CertificateWithPrivateKey*>(p->ptr), tt__CertificateWithPrivateKey);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__CertificateWithPrivateKey*>(p->ptr), tt__CertificateWithPrivateKey);
		break;
	case SOAP_TYPE_tt__CertificateInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__CertificateInformation*>(p->ptr), tt__CertificateInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__CertificateInformation*>(p->ptr), tt__CertificateInformation);
		break;
	case SOAP_TYPE_tt__CertificateInformationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__CertificateInformationExtension*>(p->ptr), tt__CertificateInformationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__CertificateInformationExtension*>(p->ptr), tt__CertificateInformationExtension);
		break;
	case SOAP_TYPE_tt__Dot1XConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot1XConfiguration*>(p->ptr), tt__Dot1XConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot1XConfiguration*>(p->ptr), tt__Dot1XConfiguration);
		break;
	case SOAP_TYPE_tt__Dot1XConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Dot1XConfigurationExtension*>(p->ptr), tt__Dot1XConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Dot1XConfigurationExtension*>(p->ptr), tt__Dot1XConfigurationExtension);
		break;
	case SOAP_TYPE_tt__EAPMethodConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__EAPMethodConfiguration*>(p->ptr), tt__EAPMethodConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__EAPMethodConfiguration*>(p->ptr), tt__EAPMethodConfiguration);
		break;
	case SOAP_TYPE_tt__EapMethodExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__EapMethodExtension*>(p->ptr), tt__EapMethodExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__EapMethodExtension*>(p->ptr), tt__EapMethodExtension);
		break;
	case SOAP_TYPE_tt__TLSConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__TLSConfiguration*>(p->ptr), tt__TLSConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__TLSConfiguration*>(p->ptr), tt__TLSConfiguration);
		break;
	case SOAP_TYPE_tt__RelayOutputSettings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RelayOutputSettings*>(p->ptr), tt__RelayOutputSettings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RelayOutputSettings*>(p->ptr), tt__RelayOutputSettings);
		break;
	case SOAP_TYPE_tt__DateTimeRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DateTimeRange*>(p->ptr), tt__DateTimeRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DateTimeRange*>(p->ptr), tt__DateTimeRange);
		break;
	case SOAP_TYPE_tt__IntRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IntRange*>(p->ptr), tt__IntRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IntRange*>(p->ptr), tt__IntRange);
		break;
	case SOAP_TYPE_tt__GeoLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__GeoLocation*>(p->ptr), tt__GeoLocation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__GeoLocation*>(p->ptr), tt__GeoLocation);
		break;
	case SOAP_TYPE_tt__GeoOrientation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__GeoOrientation*>(p->ptr), tt__GeoOrientation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__GeoOrientation*>(p->ptr), tt__GeoOrientation);
		break;
	case SOAP_TYPE_tt__LocalLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__LocalLocation*>(p->ptr), tt__LocalLocation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__LocalLocation*>(p->ptr), tt__LocalLocation);
		break;
	case SOAP_TYPE_tt__LocalOrientation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__LocalOrientation*>(p->ptr), tt__LocalOrientation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__LocalOrientation*>(p->ptr), tt__LocalOrientation);
		break;
	case SOAP_TYPE_tt__LocationEntity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__LocationEntity*>(p->ptr), tt__LocationEntity);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__LocationEntity*>(p->ptr), tt__LocationEntity);
		break;
	case SOAP_TYPE_tds__StorageConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tds__StorageConfiguration*>(p->ptr), tds__StorageConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tds__StorageConfiguration*>(p->ptr), tds__StorageConfiguration);
		break;
	case SOAP_TYPE_tt__NetworkInterface:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__NetworkInterface*>(p->ptr), tt__NetworkInterface);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__NetworkInterface*>(p->ptr), tt__NetworkInterface);
		break;
	case SOAP_TYPE_tt__CertificateUsage:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__CertificateUsage*>(p->ptr), tt__CertificateUsage);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__CertificateUsage*>(p->ptr), tt__CertificateUsage);
		break;
	case SOAP_TYPE_tt__RelayOutput:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__RelayOutput*>(p->ptr), tt__RelayOutput);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__RelayOutput*>(p->ptr), tt__RelayOutput);
		break;
	case SOAP_TYPE___tds__GetServices:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetServices*>(p->ptr), struct __tds__GetServices);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetServices*>(p->ptr), struct __tds__GetServices);
		break;
	case SOAP_TYPE___tds__GetServiceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetServiceCapabilities*>(p->ptr), struct __tds__GetServiceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetServiceCapabilities*>(p->ptr), struct __tds__GetServiceCapabilities);
		break;
	case SOAP_TYPE___tds__GetDeviceInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetDeviceInformation*>(p->ptr), struct __tds__GetDeviceInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetDeviceInformation*>(p->ptr), struct __tds__GetDeviceInformation);
		break;
	case SOAP_TYPE___tds__SetSystemDateAndTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetSystemDateAndTime*>(p->ptr), struct __tds__SetSystemDateAndTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetSystemDateAndTime*>(p->ptr), struct __tds__SetSystemDateAndTime);
		break;
	case SOAP_TYPE___tds__GetSystemDateAndTime:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetSystemDateAndTime*>(p->ptr), struct __tds__GetSystemDateAndTime);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetSystemDateAndTime*>(p->ptr), struct __tds__GetSystemDateAndTime);
		break;
	case SOAP_TYPE___tds__SetSystemFactoryDefault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetSystemFactoryDefault*>(p->ptr), struct __tds__SetSystemFactoryDefault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetSystemFactoryDefault*>(p->ptr), struct __tds__SetSystemFactoryDefault);
		break;
	case SOAP_TYPE___tds__UpgradeSystemFirmware:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__UpgradeSystemFirmware*>(p->ptr), struct __tds__UpgradeSystemFirmware);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__UpgradeSystemFirmware*>(p->ptr), struct __tds__UpgradeSystemFirmware);
		break;
	case SOAP_TYPE___tds__SystemReboot:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SystemReboot*>(p->ptr), struct __tds__SystemReboot);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SystemReboot*>(p->ptr), struct __tds__SystemReboot);
		break;
	case SOAP_TYPE___tds__RestoreSystem:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__RestoreSystem*>(p->ptr), struct __tds__RestoreSystem);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__RestoreSystem*>(p->ptr), struct __tds__RestoreSystem);
		break;
	case SOAP_TYPE___tds__GetSystemBackup:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetSystemBackup*>(p->ptr), struct __tds__GetSystemBackup);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetSystemBackup*>(p->ptr), struct __tds__GetSystemBackup);
		break;
	case SOAP_TYPE___tds__GetSystemLog:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetSystemLog*>(p->ptr), struct __tds__GetSystemLog);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetSystemLog*>(p->ptr), struct __tds__GetSystemLog);
		break;
	case SOAP_TYPE___tds__GetSystemSupportInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetSystemSupportInformation*>(p->ptr), struct __tds__GetSystemSupportInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetSystemSupportInformation*>(p->ptr), struct __tds__GetSystemSupportInformation);
		break;
	case SOAP_TYPE___tds__GetScopes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetScopes*>(p->ptr), struct __tds__GetScopes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetScopes*>(p->ptr), struct __tds__GetScopes);
		break;
	case SOAP_TYPE___tds__SetScopes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetScopes*>(p->ptr), struct __tds__SetScopes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetScopes*>(p->ptr), struct __tds__SetScopes);
		break;
	case SOAP_TYPE___tds__AddScopes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__AddScopes*>(p->ptr), struct __tds__AddScopes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__AddScopes*>(p->ptr), struct __tds__AddScopes);
		break;
	case SOAP_TYPE___tds__RemoveScopes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__RemoveScopes*>(p->ptr), struct __tds__RemoveScopes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__RemoveScopes*>(p->ptr), struct __tds__RemoveScopes);
		break;
	case SOAP_TYPE___tds__GetDiscoveryMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetDiscoveryMode*>(p->ptr), struct __tds__GetDiscoveryMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetDiscoveryMode*>(p->ptr), struct __tds__GetDiscoveryMode);
		break;
	case SOAP_TYPE___tds__SetDiscoveryMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetDiscoveryMode*>(p->ptr), struct __tds__SetDiscoveryMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetDiscoveryMode*>(p->ptr), struct __tds__SetDiscoveryMode);
		break;
	case SOAP_TYPE___tds__GetRemoteDiscoveryMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetRemoteDiscoveryMode*>(p->ptr), struct __tds__GetRemoteDiscoveryMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetRemoteDiscoveryMode*>(p->ptr), struct __tds__GetRemoteDiscoveryMode);
		break;
	case SOAP_TYPE___tds__SetRemoteDiscoveryMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetRemoteDiscoveryMode*>(p->ptr), struct __tds__SetRemoteDiscoveryMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetRemoteDiscoveryMode*>(p->ptr), struct __tds__SetRemoteDiscoveryMode);
		break;
	case SOAP_TYPE___tds__GetDPAddresses:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetDPAddresses*>(p->ptr), struct __tds__GetDPAddresses);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetDPAddresses*>(p->ptr), struct __tds__GetDPAddresses);
		break;
	case SOAP_TYPE___tds__GetEndpointReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetEndpointReference*>(p->ptr), struct __tds__GetEndpointReference);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetEndpointReference*>(p->ptr), struct __tds__GetEndpointReference);
		break;
	case SOAP_TYPE___tds__GetRemoteUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetRemoteUser*>(p->ptr), struct __tds__GetRemoteUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetRemoteUser*>(p->ptr), struct __tds__GetRemoteUser);
		break;
	case SOAP_TYPE___tds__SetRemoteUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetRemoteUser*>(p->ptr), struct __tds__SetRemoteUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetRemoteUser*>(p->ptr), struct __tds__SetRemoteUser);
		break;
	case SOAP_TYPE___tds__GetUsers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetUsers*>(p->ptr), struct __tds__GetUsers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetUsers*>(p->ptr), struct __tds__GetUsers);
		break;
	case SOAP_TYPE___tds__CreateUsers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__CreateUsers*>(p->ptr), struct __tds__CreateUsers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__CreateUsers*>(p->ptr), struct __tds__CreateUsers);
		break;
	case SOAP_TYPE___tds__DeleteUsers:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__DeleteUsers*>(p->ptr), struct __tds__DeleteUsers);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__DeleteUsers*>(p->ptr), struct __tds__DeleteUsers);
		break;
	case SOAP_TYPE___tds__SetUser:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetUser*>(p->ptr), struct __tds__SetUser);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetUser*>(p->ptr), struct __tds__SetUser);
		break;
	case SOAP_TYPE___tds__GetWsdlUrl:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetWsdlUrl*>(p->ptr), struct __tds__GetWsdlUrl);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetWsdlUrl*>(p->ptr), struct __tds__GetWsdlUrl);
		break;
	case SOAP_TYPE___tds__GetPasswordComplexityOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetPasswordComplexityOptions*>(p->ptr), struct __tds__GetPasswordComplexityOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetPasswordComplexityOptions*>(p->ptr), struct __tds__GetPasswordComplexityOptions);
		break;
	case SOAP_TYPE___tds__GetPasswordComplexityConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetPasswordComplexityConfiguration*>(p->ptr), struct __tds__GetPasswordComplexityConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetPasswordComplexityConfiguration*>(p->ptr), struct __tds__GetPasswordComplexityConfiguration);
		break;
	case SOAP_TYPE___tds__SetPasswordComplexityConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetPasswordComplexityConfiguration*>(p->ptr), struct __tds__SetPasswordComplexityConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetPasswordComplexityConfiguration*>(p->ptr), struct __tds__SetPasswordComplexityConfiguration);
		break;
	case SOAP_TYPE___tds__GetPasswordHistoryConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetPasswordHistoryConfiguration*>(p->ptr), struct __tds__GetPasswordHistoryConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetPasswordHistoryConfiguration*>(p->ptr), struct __tds__GetPasswordHistoryConfiguration);
		break;
	case SOAP_TYPE___tds__SetPasswordHistoryConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetPasswordHistoryConfiguration*>(p->ptr), struct __tds__SetPasswordHistoryConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetPasswordHistoryConfiguration*>(p->ptr), struct __tds__SetPasswordHistoryConfiguration);
		break;
	case SOAP_TYPE___tds__GetAuthFailureWarningOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetAuthFailureWarningOptions*>(p->ptr), struct __tds__GetAuthFailureWarningOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetAuthFailureWarningOptions*>(p->ptr), struct __tds__GetAuthFailureWarningOptions);
		break;
	case SOAP_TYPE___tds__GetAuthFailureWarningConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetAuthFailureWarningConfiguration*>(p->ptr), struct __tds__GetAuthFailureWarningConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetAuthFailureWarningConfiguration*>(p->ptr), struct __tds__GetAuthFailureWarningConfiguration);
		break;
	case SOAP_TYPE___tds__SetAuthFailureWarningConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetAuthFailureWarningConfiguration*>(p->ptr), struct __tds__SetAuthFailureWarningConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetAuthFailureWarningConfiguration*>(p->ptr), struct __tds__SetAuthFailureWarningConfiguration);
		break;
	case SOAP_TYPE___tds__GetCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetCapabilities*>(p->ptr), struct __tds__GetCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetCapabilities*>(p->ptr), struct __tds__GetCapabilities);
		break;
	case SOAP_TYPE___tds__SetDPAddresses:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetDPAddresses*>(p->ptr), struct __tds__SetDPAddresses);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetDPAddresses*>(p->ptr), struct __tds__SetDPAddresses);
		break;
	case SOAP_TYPE___tds__GetHostname:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetHostname*>(p->ptr), struct __tds__GetHostname);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetHostname*>(p->ptr), struct __tds__GetHostname);
		break;
	case SOAP_TYPE___tds__SetHostname:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetHostname*>(p->ptr), struct __tds__SetHostname);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetHostname*>(p->ptr), struct __tds__SetHostname);
		break;
	case SOAP_TYPE___tds__SetHostnameFromDHCP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetHostnameFromDHCP*>(p->ptr), struct __tds__SetHostnameFromDHCP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetHostnameFromDHCP*>(p->ptr), struct __tds__SetHostnameFromDHCP);
		break;
	case SOAP_TYPE___tds__GetDNS:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetDNS*>(p->ptr), struct __tds__GetDNS);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetDNS*>(p->ptr), struct __tds__GetDNS);
		break;
	case SOAP_TYPE___tds__SetDNS:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetDNS*>(p->ptr), struct __tds__SetDNS);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetDNS*>(p->ptr), struct __tds__SetDNS);
		break;
	case SOAP_TYPE___tds__GetNTP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetNTP*>(p->ptr), struct __tds__GetNTP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetNTP*>(p->ptr), struct __tds__GetNTP);
		break;
	case SOAP_TYPE___tds__SetNTP:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetNTP*>(p->ptr), struct __tds__SetNTP);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetNTP*>(p->ptr), struct __tds__SetNTP);
		break;
	case SOAP_TYPE___tds__GetDynamicDNS:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetDynamicDNS*>(p->ptr), struct __tds__GetDynamicDNS);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetDynamicDNS*>(p->ptr), struct __tds__GetDynamicDNS);
		break;
	case SOAP_TYPE___tds__SetDynamicDNS:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetDynamicDNS*>(p->ptr), struct __tds__SetDynamicDNS);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetDynamicDNS*>(p->ptr), struct __tds__SetDynamicDNS);
		break;
	case SOAP_TYPE___tds__GetNetworkInterfaces:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetNetworkInterfaces*>(p->ptr), struct __tds__GetNetworkInterfaces);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetNetworkInterfaces*>(p->ptr), struct __tds__GetNetworkInterfaces);
		break;
	case SOAP_TYPE___tds__SetNetworkInterfaces:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetNetworkInterfaces*>(p->ptr), struct __tds__SetNetworkInterfaces);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetNetworkInterfaces*>(p->ptr), struct __tds__SetNetworkInterfaces);
		break;
	case SOAP_TYPE___tds__GetNetworkProtocols:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetNetworkProtocols*>(p->ptr), struct __tds__GetNetworkProtocols);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetNetworkProtocols*>(p->ptr), struct __tds__GetNetworkProtocols);
		break;
	case SOAP_TYPE___tds__SetNetworkProtocols:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetNetworkProtocols*>(p->ptr), struct __tds__SetNetworkProtocols);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetNetworkProtocols*>(p->ptr), struct __tds__SetNetworkProtocols);
		break;
	case SOAP_TYPE___tds__GetNetworkDefaultGateway:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetNetworkDefaultGateway*>(p->ptr), struct __tds__GetNetworkDefaultGateway);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetNetworkDefaultGateway*>(p->ptr), struct __tds__GetNetworkDefaultGateway);
		break;
	case SOAP_TYPE___tds__SetNetworkDefaultGateway:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetNetworkDefaultGateway*>(p->ptr), struct __tds__SetNetworkDefaultGateway);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetNetworkDefaultGateway*>(p->ptr), struct __tds__SetNetworkDefaultGateway);
		break;
	case SOAP_TYPE___tds__GetZeroConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetZeroConfiguration*>(p->ptr), struct __tds__GetZeroConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetZeroConfiguration*>(p->ptr), struct __tds__GetZeroConfiguration);
		break;
	case SOAP_TYPE___tds__SetZeroConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetZeroConfiguration*>(p->ptr), struct __tds__SetZeroConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetZeroConfiguration*>(p->ptr), struct __tds__SetZeroConfiguration);
		break;
	case SOAP_TYPE___tds__GetIPAddressFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetIPAddressFilter*>(p->ptr), struct __tds__GetIPAddressFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetIPAddressFilter*>(p->ptr), struct __tds__GetIPAddressFilter);
		break;
	case SOAP_TYPE___tds__SetIPAddressFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetIPAddressFilter*>(p->ptr), struct __tds__SetIPAddressFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetIPAddressFilter*>(p->ptr), struct __tds__SetIPAddressFilter);
		break;
	case SOAP_TYPE___tds__AddIPAddressFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__AddIPAddressFilter*>(p->ptr), struct __tds__AddIPAddressFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__AddIPAddressFilter*>(p->ptr), struct __tds__AddIPAddressFilter);
		break;
	case SOAP_TYPE___tds__RemoveIPAddressFilter:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__RemoveIPAddressFilter*>(p->ptr), struct __tds__RemoveIPAddressFilter);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__RemoveIPAddressFilter*>(p->ptr), struct __tds__RemoveIPAddressFilter);
		break;
	case SOAP_TYPE___tds__GetAccessPolicy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetAccessPolicy*>(p->ptr), struct __tds__GetAccessPolicy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetAccessPolicy*>(p->ptr), struct __tds__GetAccessPolicy);
		break;
	case SOAP_TYPE___tds__SetAccessPolicy:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetAccessPolicy*>(p->ptr), struct __tds__SetAccessPolicy);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetAccessPolicy*>(p->ptr), struct __tds__SetAccessPolicy);
		break;
	case SOAP_TYPE___tds__CreateCertificate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__CreateCertificate*>(p->ptr), struct __tds__CreateCertificate);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__CreateCertificate*>(p->ptr), struct __tds__CreateCertificate);
		break;
	case SOAP_TYPE___tds__GetCertificates:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetCertificates*>(p->ptr), struct __tds__GetCertificates);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetCertificates*>(p->ptr), struct __tds__GetCertificates);
		break;
	case SOAP_TYPE___tds__GetCertificatesStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetCertificatesStatus*>(p->ptr), struct __tds__GetCertificatesStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetCertificatesStatus*>(p->ptr), struct __tds__GetCertificatesStatus);
		break;
	case SOAP_TYPE___tds__SetCertificatesStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetCertificatesStatus*>(p->ptr), struct __tds__SetCertificatesStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetCertificatesStatus*>(p->ptr), struct __tds__SetCertificatesStatus);
		break;
	case SOAP_TYPE___tds__DeleteCertificates:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__DeleteCertificates*>(p->ptr), struct __tds__DeleteCertificates);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__DeleteCertificates*>(p->ptr), struct __tds__DeleteCertificates);
		break;
	case SOAP_TYPE___tds__GetPkcs10Request:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetPkcs10Request*>(p->ptr), struct __tds__GetPkcs10Request);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetPkcs10Request*>(p->ptr), struct __tds__GetPkcs10Request);
		break;
	case SOAP_TYPE___tds__LoadCertificates:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__LoadCertificates*>(p->ptr), struct __tds__LoadCertificates);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__LoadCertificates*>(p->ptr), struct __tds__LoadCertificates);
		break;
	case SOAP_TYPE___tds__GetClientCertificateMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetClientCertificateMode*>(p->ptr), struct __tds__GetClientCertificateMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetClientCertificateMode*>(p->ptr), struct __tds__GetClientCertificateMode);
		break;
	case SOAP_TYPE___tds__SetClientCertificateMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetClientCertificateMode*>(p->ptr), struct __tds__SetClientCertificateMode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetClientCertificateMode*>(p->ptr), struct __tds__SetClientCertificateMode);
		break;
	case SOAP_TYPE___tds__GetRelayOutputs:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetRelayOutputs*>(p->ptr), struct __tds__GetRelayOutputs);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetRelayOutputs*>(p->ptr), struct __tds__GetRelayOutputs);
		break;
	case SOAP_TYPE___tds__SetRelayOutputSettings:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetRelayOutputSettings*>(p->ptr), struct __tds__SetRelayOutputSettings);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetRelayOutputSettings*>(p->ptr), struct __tds__SetRelayOutputSettings);
		break;
	case SOAP_TYPE___tds__SetRelayOutputState:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetRelayOutputState*>(p->ptr), struct __tds__SetRelayOutputState);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetRelayOutputState*>(p->ptr), struct __tds__SetRelayOutputState);
		break;
	case SOAP_TYPE___tds__SendAuxiliaryCommand:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SendAuxiliaryCommand*>(p->ptr), struct __tds__SendAuxiliaryCommand);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SendAuxiliaryCommand*>(p->ptr), struct __tds__SendAuxiliaryCommand);
		break;
	case SOAP_TYPE___tds__GetCACertificates:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetCACertificates*>(p->ptr), struct __tds__GetCACertificates);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetCACertificates*>(p->ptr), struct __tds__GetCACertificates);
		break;
	case SOAP_TYPE___tds__LoadCertificateWithPrivateKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__LoadCertificateWithPrivateKey*>(p->ptr), struct __tds__LoadCertificateWithPrivateKey);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__LoadCertificateWithPrivateKey*>(p->ptr), struct __tds__LoadCertificateWithPrivateKey);
		break;
	case SOAP_TYPE___tds__GetCertificateInformation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetCertificateInformation*>(p->ptr), struct __tds__GetCertificateInformation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetCertificateInformation*>(p->ptr), struct __tds__GetCertificateInformation);
		break;
	case SOAP_TYPE___tds__LoadCACertificates:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__LoadCACertificates*>(p->ptr), struct __tds__LoadCACertificates);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__LoadCACertificates*>(p->ptr), struct __tds__LoadCACertificates);
		break;
	case SOAP_TYPE___tds__CreateDot1XConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__CreateDot1XConfiguration*>(p->ptr), struct __tds__CreateDot1XConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__CreateDot1XConfiguration*>(p->ptr), struct __tds__CreateDot1XConfiguration);
		break;
	case SOAP_TYPE___tds__SetDot1XConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetDot1XConfiguration*>(p->ptr), struct __tds__SetDot1XConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetDot1XConfiguration*>(p->ptr), struct __tds__SetDot1XConfiguration);
		break;
	case SOAP_TYPE___tds__GetDot1XConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetDot1XConfiguration*>(p->ptr), struct __tds__GetDot1XConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetDot1XConfiguration*>(p->ptr), struct __tds__GetDot1XConfiguration);
		break;
	case SOAP_TYPE___tds__GetDot1XConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetDot1XConfigurations*>(p->ptr), struct __tds__GetDot1XConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetDot1XConfigurations*>(p->ptr), struct __tds__GetDot1XConfigurations);
		break;
	case SOAP_TYPE___tds__DeleteDot1XConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__DeleteDot1XConfiguration*>(p->ptr), struct __tds__DeleteDot1XConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__DeleteDot1XConfiguration*>(p->ptr), struct __tds__DeleteDot1XConfiguration);
		break;
	case SOAP_TYPE___tds__GetDot11Capabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetDot11Capabilities*>(p->ptr), struct __tds__GetDot11Capabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetDot11Capabilities*>(p->ptr), struct __tds__GetDot11Capabilities);
		break;
	case SOAP_TYPE___tds__GetDot11Status:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetDot11Status*>(p->ptr), struct __tds__GetDot11Status);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetDot11Status*>(p->ptr), struct __tds__GetDot11Status);
		break;
	case SOAP_TYPE___tds__ScanAvailableDot11Networks:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__ScanAvailableDot11Networks*>(p->ptr), struct __tds__ScanAvailableDot11Networks);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__ScanAvailableDot11Networks*>(p->ptr), struct __tds__ScanAvailableDot11Networks);
		break;
	case SOAP_TYPE___tds__GetSystemUris:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetSystemUris*>(p->ptr), struct __tds__GetSystemUris);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetSystemUris*>(p->ptr), struct __tds__GetSystemUris);
		break;
	case SOAP_TYPE___tds__StartFirmwareUpgrade:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__StartFirmwareUpgrade*>(p->ptr), struct __tds__StartFirmwareUpgrade);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__StartFirmwareUpgrade*>(p->ptr), struct __tds__StartFirmwareUpgrade);
		break;
	case SOAP_TYPE___tds__StartSystemRestore:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__StartSystemRestore*>(p->ptr), struct __tds__StartSystemRestore);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__StartSystemRestore*>(p->ptr), struct __tds__StartSystemRestore);
		break;
	case SOAP_TYPE___tds__GetStorageConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetStorageConfigurations*>(p->ptr), struct __tds__GetStorageConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetStorageConfigurations*>(p->ptr), struct __tds__GetStorageConfigurations);
		break;
	case SOAP_TYPE___tds__CreateStorageConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__CreateStorageConfiguration*>(p->ptr), struct __tds__CreateStorageConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__CreateStorageConfiguration*>(p->ptr), struct __tds__CreateStorageConfiguration);
		break;
	case SOAP_TYPE___tds__GetStorageConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetStorageConfiguration*>(p->ptr), struct __tds__GetStorageConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetStorageConfiguration*>(p->ptr), struct __tds__GetStorageConfiguration);
		break;
	case SOAP_TYPE___tds__SetStorageConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetStorageConfiguration*>(p->ptr), struct __tds__SetStorageConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetStorageConfiguration*>(p->ptr), struct __tds__SetStorageConfiguration);
		break;
	case SOAP_TYPE___tds__DeleteStorageConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__DeleteStorageConfiguration*>(p->ptr), struct __tds__DeleteStorageConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__DeleteStorageConfiguration*>(p->ptr), struct __tds__DeleteStorageConfiguration);
		break;
	case SOAP_TYPE___tds__GetGeoLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__GetGeoLocation*>(p->ptr), struct __tds__GetGeoLocation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__GetGeoLocation*>(p->ptr), struct __tds__GetGeoLocation);
		break;
	case SOAP_TYPE___tds__SetGeoLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetGeoLocation*>(p->ptr), struct __tds__SetGeoLocation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetGeoLocation*>(p->ptr), struct __tds__SetGeoLocation);
		break;
	case SOAP_TYPE___tds__DeleteGeoLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__DeleteGeoLocation*>(p->ptr), struct __tds__DeleteGeoLocation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__DeleteGeoLocation*>(p->ptr), struct __tds__DeleteGeoLocation);
		break;
	case SOAP_TYPE___tds__SetHashingAlgorithm:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tds__SetHashingAlgorithm*>(p->ptr), struct __tds__SetHashingAlgorithm);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tds__SetHashingAlgorithm*>(p->ptr), struct __tds__SetHashingAlgorithm);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__From:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__NCName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__duration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__token:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__xml__lang:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__IntList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__StringAttrList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__StringList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__Name:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__NetworkInterfaceConfigPriority:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__IPv4Address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__IPv6Address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__HwAddress:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__DNSName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__Dot11SSIDType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__hexBinary*>(p->ptr), xsd__hexBinary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__hexBinary*>(p->ptr), xsd__hexBinary);
		break;
	case SOAP_TYPE_tt__Dot11PSK:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__hexBinary*>(p->ptr), xsd__hexBinary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__hexBinary*>(p->ptr), xsd__hexBinary);
		break;
	case SOAP_TYPE_tt__Dot11PSKPassphrase:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__AuxiliaryData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__SystemLogUri *> *>(p->ptr), std::vector<tt__SystemLogUri *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__SystemLogUri *> *>(p->ptr), std::vector<tt__SystemLogUri *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__OnvifVersion *> *>(p->ptr), std::vector<tt__OnvifVersion *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__OnvifVersion *> *>(p->ptr), std::vector<tt__OnvifVersion *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__Dot11Cipher> *>(p->ptr), std::vector<enum tt__Dot11Cipher> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__Dot11Cipher> *>(p->ptr), std::vector<enum tt__Dot11Cipher> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__Dot11AuthAndMangementSuite> *>(p->ptr), std::vector<enum tt__Dot11AuthAndMangementSuite> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__Dot11AuthAndMangementSuite> *>(p->ptr), std::vector<enum tt__Dot11AuthAndMangementSuite> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__NetworkZeroConfiguration *> *>(p->ptr), std::vector<tt__NetworkZeroConfiguration *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__NetworkZeroConfiguration *> *>(p->ptr), std::vector<tt__NetworkZeroConfiguration *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<int> *>(p->ptr), std::vector<int> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<int> *>(p->ptr), std::vector<int> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__PrefixedIPv6Address *> *>(p->ptr), std::vector<tt__PrefixedIPv6Address *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__PrefixedIPv6Address *> *>(p->ptr), std::vector<tt__PrefixedIPv6Address *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__PrefixedIPv4Address *> *>(p->ptr), std::vector<tt__PrefixedIPv4Address *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__PrefixedIPv4Address *> *>(p->ptr), std::vector<tt__PrefixedIPv4Address *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__Dot11Configuration *> *>(p->ptr), std::vector<tt__Dot11Configuration *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__Dot11Configuration *> *>(p->ptr), std::vector<tt__Dot11Configuration *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__Dot3Configuration *> *>(p->ptr), std::vector<tt__Dot3Configuration *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__Dot3Configuration *> *>(p->ptr), std::vector<tt__Dot3Configuration *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__LocationEntity *> *>(p->ptr), std::vector<tt__LocationEntity *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__LocationEntity *> *>(p->ptr), std::vector<tt__LocationEntity *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tds__StorageConfiguration *> *>(p->ptr), std::vector<tds__StorageConfiguration *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tds__StorageConfiguration *> *>(p->ptr), std::vector<tds__StorageConfiguration *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__Dot11AvailableNetworks *> *>(p->ptr), std::vector<tt__Dot11AvailableNetworks *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__Dot11AvailableNetworks *> *>(p->ptr), std::vector<tt__Dot11AvailableNetworks *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__RelayOutput *> *>(p->ptr), std::vector<tt__RelayOutput *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__RelayOutput *> *>(p->ptr), std::vector<tt__RelayOutput *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__Dot1XConfiguration *> *>(p->ptr), std::vector<tt__Dot1XConfiguration *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__Dot1XConfiguration *> *>(p->ptr), std::vector<tt__Dot1XConfiguration *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__CertificateWithPrivateKey *> *>(p->ptr), std::vector<tt__CertificateWithPrivateKey *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__CertificateWithPrivateKey *> *>(p->ptr), std::vector<tt__CertificateWithPrivateKey *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__CertificateStatus *> *>(p->ptr), std::vector<tt__CertificateStatus *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__CertificateStatus *> *>(p->ptr), std::vector<tt__CertificateStatus *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__Certificate *> *>(p->ptr), std::vector<tt__Certificate *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__Certificate *> *>(p->ptr), std::vector<tt__Certificate *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IPv6Address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IPv4Address:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__NetworkProtocol *> *>(p->ptr), std::vector<tt__NetworkProtocol *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__NetworkProtocol *> *>(p->ptr), std::vector<tt__NetworkProtocol *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__NetworkInterface *> *>(p->ptr), std::vector<tt__NetworkInterface *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__NetworkInterface *> *>(p->ptr), std::vector<tt__NetworkInterface *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__IPAddress *> *>(p->ptr), std::vector<tt__IPAddress *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__IPAddress *> *>(p->ptr), std::vector<tt__IPAddress *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__token:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__CapabilityCategory> *>(p->ptr), std::vector<enum tt__CapabilityCategory> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__CapabilityCategory> *>(p->ptr), std::vector<enum tt__CapabilityCategory> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__User:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__User *> *>(p->ptr), std::vector<tt__User *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__User *> *>(p->ptr), std::vector<tt__User *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__NetworkHost *> *>(p->ptr), std::vector<tt__NetworkHost *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__NetworkHost *> *>(p->ptr), std::vector<tt__NetworkHost *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__Scope *> *>(p->ptr), std::vector<tt__Scope *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__Scope *> *>(p->ptr), std::vector<tt__Scope *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__BackupFile *> *>(p->ptr), std::vector<tt__BackupFile *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__BackupFile *> *>(p->ptr), std::vector<tt__BackupFile *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tds__Service *> *>(p->ptr), std::vector<tds__Service *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tds__Service *> *>(p->ptr), std::vector<tds__Service *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_tds__StorageConfiguration: t = SOAP_TYPE_tt__DeviceEntity; break;
		case SOAP_TYPE_tt__NetworkInterface: t = SOAP_TYPE_tt__DeviceEntity; break;
		case SOAP_TYPE_tt__RelayOutput: t = SOAP_TYPE_tt__DeviceEntity; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri:
		if (t == SOAP_TYPE_tt__SystemLogUri || soap_fbase(t, SOAP_TYPE_tt__SystemLogUri))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__SystemLogUri *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__SystemLogUri *> *)p)[index] = *(tt__SystemLogUri **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion:
		if (t == SOAP_TYPE_tt__OnvifVersion || soap_fbase(t, SOAP_TYPE_tt__OnvifVersion))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__OnvifVersion *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__OnvifVersion *> *)p)[index] = *(tt__OnvifVersion **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData:
		if (t == SOAP_TYPE_tt__AuxiliaryData)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher:
		if (t == SOAP_TYPE_tt__Dot11Cipher)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__Dot11Cipher>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__Dot11Cipher> *)p)[index] = *(enum tt__Dot11Cipher *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite:
		if (t == SOAP_TYPE_tt__Dot11AuthAndMangementSuite)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__Dot11AuthAndMangementSuite>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__Dot11AuthAndMangementSuite> *)p)[index] = *(enum tt__Dot11AuthAndMangementSuite *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration:
		if (t == SOAP_TYPE_tt__NetworkZeroConfiguration || soap_fbase(t, SOAP_TYPE_tt__NetworkZeroConfiguration))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__NetworkZeroConfiguration *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__NetworkZeroConfiguration *> *)p)[index] = *(tt__NetworkZeroConfiguration **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (t == SOAP_TYPE_int)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<int>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<int> *)p)[index] = *(int *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address:
		if (t == SOAP_TYPE_tt__PrefixedIPv6Address || soap_fbase(t, SOAP_TYPE_tt__PrefixedIPv6Address))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__PrefixedIPv6Address *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__PrefixedIPv6Address *> *)p)[index] = *(tt__PrefixedIPv6Address **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address:
		if (t == SOAP_TYPE_tt__PrefixedIPv4Address || soap_fbase(t, SOAP_TYPE_tt__PrefixedIPv4Address))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__PrefixedIPv4Address *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__PrefixedIPv4Address *> *)p)[index] = *(tt__PrefixedIPv4Address **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration:
		if (t == SOAP_TYPE_tt__Dot11Configuration || soap_fbase(t, SOAP_TYPE_tt__Dot11Configuration))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__Dot11Configuration *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__Dot11Configuration *> *)p)[index] = *(tt__Dot11Configuration **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration:
		if (t == SOAP_TYPE_tt__Dot3Configuration || soap_fbase(t, SOAP_TYPE_tt__Dot3Configuration))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__Dot3Configuration *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__Dot3Configuration *> *)p)[index] = *(tt__Dot3Configuration **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity:
		if (t == SOAP_TYPE_tt__LocationEntity || soap_fbase(t, SOAP_TYPE_tt__LocationEntity))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__LocationEntity *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__LocationEntity *> *)p)[index] = *(tt__LocationEntity **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration:
		if (t == SOAP_TYPE_tds__StorageConfiguration || soap_fbase(t, SOAP_TYPE_tds__StorageConfiguration))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tds__StorageConfiguration *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tds__StorageConfiguration *> *)p)[index] = *(tds__StorageConfiguration **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks:
		if (t == SOAP_TYPE_tt__Dot11AvailableNetworks || soap_fbase(t, SOAP_TYPE_tt__Dot11AvailableNetworks))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__Dot11AvailableNetworks *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__Dot11AvailableNetworks *> *)p)[index] = *(tt__Dot11AvailableNetworks **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput:
		if (t == SOAP_TYPE_tt__RelayOutput || soap_fbase(t, SOAP_TYPE_tt__RelayOutput))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__RelayOutput *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__RelayOutput *> *)p)[index] = *(tt__RelayOutput **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken:
		if (t == SOAP_TYPE_tt__ReferenceToken)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration:
		if (t == SOAP_TYPE_tt__Dot1XConfiguration || soap_fbase(t, SOAP_TYPE_tt__Dot1XConfiguration))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__Dot1XConfiguration *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__Dot1XConfiguration *> *)p)[index] = *(tt__Dot1XConfiguration **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey:
		if (t == SOAP_TYPE_tt__CertificateWithPrivateKey || soap_fbase(t, SOAP_TYPE_tt__CertificateWithPrivateKey))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__CertificateWithPrivateKey *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__CertificateWithPrivateKey *> *)p)[index] = *(tt__CertificateWithPrivateKey **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus:
		if (t == SOAP_TYPE_tt__CertificateStatus || soap_fbase(t, SOAP_TYPE_tt__CertificateStatus))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__CertificateStatus *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__CertificateStatus *> *)p)[index] = *(tt__CertificateStatus **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate:
		if (t == SOAP_TYPE_tt__Certificate || soap_fbase(t, SOAP_TYPE_tt__Certificate))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__Certificate *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__Certificate *> *)p)[index] = *(tt__Certificate **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IPv6Address:
		if (t == SOAP_TYPE_tt__IPv6Address)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__IPv4Address:
		if (t == SOAP_TYPE_tt__IPv4Address)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol:
		if (t == SOAP_TYPE_tt__NetworkProtocol || soap_fbase(t, SOAP_TYPE_tt__NetworkProtocol))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__NetworkProtocol *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__NetworkProtocol *> *)p)[index] = *(tt__NetworkProtocol **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface:
		if (t == SOAP_TYPE_tt__NetworkInterface || soap_fbase(t, SOAP_TYPE_tt__NetworkInterface))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__NetworkInterface *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__NetworkInterface *> *)p)[index] = *(tt__NetworkInterface **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress:
		if (t == SOAP_TYPE_tt__IPAddress || soap_fbase(t, SOAP_TYPE_tt__IPAddress))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__IPAddress *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__IPAddress *> *)p)[index] = *(tt__IPAddress **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__token:
		if (t == SOAP_TYPE_xsd__token)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory:
		if (t == SOAP_TYPE_tt__CapabilityCategory)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__CapabilityCategory>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__CapabilityCategory> *)p)[index] = *(enum tt__CapabilityCategory *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (t == SOAP_TYPE_std__string)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__User:
		if (t == SOAP_TYPE_tt__User || soap_fbase(t, SOAP_TYPE_tt__User))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__User *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__User *> *)p)[index] = *(tt__User **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost:
		if (t == SOAP_TYPE_tt__NetworkHost || soap_fbase(t, SOAP_TYPE_tt__NetworkHost))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__NetworkHost *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__NetworkHost *> *)p)[index] = *(tt__NetworkHost **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__anyURI:
		if (t == SOAP_TYPE_xsd__anyURI)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope:
		if (t == SOAP_TYPE_tt__Scope || soap_fbase(t, SOAP_TYPE_tt__Scope))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__Scope *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__Scope *> *)p)[index] = *(tt__Scope **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile:
		if (t == SOAP_TYPE_tt__BackupFile || soap_fbase(t, SOAP_TYPE_tt__BackupFile))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__BackupFile *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__BackupFile *> *)p)[index] = *(tt__BackupFile **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service:
		if (t == SOAP_TYPE_tds__Service || soap_fbase(t, SOAP_TYPE_tds__Service))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tds__Service *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tds__Service *> *)p)[index] = *(tds__Service **)q;
		}
		break;
	case SOAP_TYPE__xop__Include:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _xop__Include type=%d location=%p object=%p\n", t, p, q));
		*(struct _xop__Include*)p = *(struct _xop__Include*)q;
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct chan__ChannelInstanceType type=%d location=%p object=%p\n", t, p, q));
		*(struct chan__ChannelInstanceType*)p = *(struct chan__ChannelInstanceType*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__anyType type=%d location=%p object=%p\n", t, p, q));
		*(xsd__anyType*)p = *(xsd__anyType*)q;
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Envelope type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Envelope*)p = *(struct SOAP_ENV__Envelope*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_xsd__hexBinary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__hexBinary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
		break;
	case SOAP_TYPE__tds__Service_Capabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__Service_Capabilities type=%d location=%p object=%p\n", t, p, q));
		*(_tds__Service_Capabilities*)p = *(_tds__Service_Capabilities*)q;
		break;
	case SOAP_TYPE_tds__Service:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tds__Service type=%d location=%p object=%p\n", t, p, q));
		*(tds__Service*)p = *(tds__Service*)q;
		break;
	case SOAP_TYPE_tds__DeviceServiceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tds__DeviceServiceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tds__DeviceServiceCapabilities*)p = *(tds__DeviceServiceCapabilities*)q;
		break;
	case SOAP_TYPE_tds__NetworkCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tds__NetworkCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tds__NetworkCapabilities*)p = *(tds__NetworkCapabilities*)q;
		break;
	case SOAP_TYPE_tds__SecurityCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tds__SecurityCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tds__SecurityCapabilities*)p = *(tds__SecurityCapabilities*)q;
		break;
	case SOAP_TYPE_tds__SystemCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tds__SystemCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tds__SystemCapabilities*)p = *(tds__SystemCapabilities*)q;
		break;
	case SOAP_TYPE_tds__MiscCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tds__MiscCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tds__MiscCapabilities*)p = *(tds__MiscCapabilities*)q;
		break;
	case SOAP_TYPE__tds__UserCredential_Extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__UserCredential_Extension type=%d location=%p object=%p\n", t, p, q));
		*(_tds__UserCredential_Extension*)p = *(_tds__UserCredential_Extension*)q;
		break;
	case SOAP_TYPE_tds__UserCredential:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tds__UserCredential type=%d location=%p object=%p\n", t, p, q));
		*(tds__UserCredential*)p = *(tds__UserCredential*)q;
		break;
	case SOAP_TYPE__tds__StorageConfigurationData_Extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__StorageConfigurationData_Extension type=%d location=%p object=%p\n", t, p, q));
		*(_tds__StorageConfigurationData_Extension*)p = *(_tds__StorageConfigurationData_Extension*)q;
		break;
	case SOAP_TYPE_tds__StorageConfigurationData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tds__StorageConfigurationData type=%d location=%p object=%p\n", t, p, q));
		*(tds__StorageConfigurationData*)p = *(tds__StorageConfigurationData*)q;
		break;
	case SOAP_TYPE__tds__GetServices:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetServices type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetServices*)p = *(_tds__GetServices*)q;
		break;
	case SOAP_TYPE__tds__GetServicesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetServicesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetServicesResponse*)p = *(_tds__GetServicesResponse*)q;
		break;
	case SOAP_TYPE__tds__GetServiceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetServiceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetServiceCapabilities*)p = *(_tds__GetServiceCapabilities*)q;
		break;
	case SOAP_TYPE__tds__GetServiceCapabilitiesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetServiceCapabilitiesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetServiceCapabilitiesResponse*)p = *(_tds__GetServiceCapabilitiesResponse*)q;
		break;
	case SOAP_TYPE__tds__GetDeviceInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDeviceInformation type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDeviceInformation*)p = *(_tds__GetDeviceInformation*)q;
		break;
	case SOAP_TYPE__tds__GetDeviceInformationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDeviceInformationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDeviceInformationResponse*)p = *(_tds__GetDeviceInformationResponse*)q;
		break;
	case SOAP_TYPE__tds__SetSystemDateAndTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetSystemDateAndTime type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetSystemDateAndTime*)p = *(_tds__SetSystemDateAndTime*)q;
		break;
	case SOAP_TYPE__tds__SetSystemDateAndTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetSystemDateAndTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetSystemDateAndTimeResponse*)p = *(_tds__SetSystemDateAndTimeResponse*)q;
		break;
	case SOAP_TYPE__tds__GetSystemDateAndTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemDateAndTime type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemDateAndTime*)p = *(_tds__GetSystemDateAndTime*)q;
		break;
	case SOAP_TYPE__tds__GetSystemDateAndTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemDateAndTimeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemDateAndTimeResponse*)p = *(_tds__GetSystemDateAndTimeResponse*)q;
		break;
	case SOAP_TYPE__tds__SetSystemFactoryDefault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetSystemFactoryDefault type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetSystemFactoryDefault*)p = *(_tds__SetSystemFactoryDefault*)q;
		break;
	case SOAP_TYPE__tds__SetSystemFactoryDefaultResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetSystemFactoryDefaultResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetSystemFactoryDefaultResponse*)p = *(_tds__SetSystemFactoryDefaultResponse*)q;
		break;
	case SOAP_TYPE__tds__UpgradeSystemFirmware:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__UpgradeSystemFirmware type=%d location=%p object=%p\n", t, p, q));
		*(_tds__UpgradeSystemFirmware*)p = *(_tds__UpgradeSystemFirmware*)q;
		break;
	case SOAP_TYPE__tds__UpgradeSystemFirmwareResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__UpgradeSystemFirmwareResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__UpgradeSystemFirmwareResponse*)p = *(_tds__UpgradeSystemFirmwareResponse*)q;
		break;
	case SOAP_TYPE__tds__SystemReboot:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SystemReboot type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SystemReboot*)p = *(_tds__SystemReboot*)q;
		break;
	case SOAP_TYPE__tds__SystemRebootResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SystemRebootResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SystemRebootResponse*)p = *(_tds__SystemRebootResponse*)q;
		break;
	case SOAP_TYPE__tds__RestoreSystem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__RestoreSystem type=%d location=%p object=%p\n", t, p, q));
		*(_tds__RestoreSystem*)p = *(_tds__RestoreSystem*)q;
		break;
	case SOAP_TYPE__tds__RestoreSystemResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__RestoreSystemResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__RestoreSystemResponse*)p = *(_tds__RestoreSystemResponse*)q;
		break;
	case SOAP_TYPE__tds__GetSystemBackup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemBackup type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemBackup*)p = *(_tds__GetSystemBackup*)q;
		break;
	case SOAP_TYPE__tds__GetSystemBackupResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemBackupResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemBackupResponse*)p = *(_tds__GetSystemBackupResponse*)q;
		break;
	case SOAP_TYPE__tds__GetSystemSupportInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemSupportInformation type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemSupportInformation*)p = *(_tds__GetSystemSupportInformation*)q;
		break;
	case SOAP_TYPE__tds__GetSystemSupportInformationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemSupportInformationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemSupportInformationResponse*)p = *(_tds__GetSystemSupportInformationResponse*)q;
		break;
	case SOAP_TYPE__tds__GetSystemLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemLog type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemLog*)p = *(_tds__GetSystemLog*)q;
		break;
	case SOAP_TYPE__tds__GetSystemLogResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemLogResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemLogResponse*)p = *(_tds__GetSystemLogResponse*)q;
		break;
	case SOAP_TYPE__tds__GetScopes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetScopes type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetScopes*)p = *(_tds__GetScopes*)q;
		break;
	case SOAP_TYPE__tds__GetScopesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetScopesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetScopesResponse*)p = *(_tds__GetScopesResponse*)q;
		break;
	case SOAP_TYPE__tds__SetScopes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetScopes type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetScopes*)p = *(_tds__SetScopes*)q;
		break;
	case SOAP_TYPE__tds__SetScopesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetScopesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetScopesResponse*)p = *(_tds__SetScopesResponse*)q;
		break;
	case SOAP_TYPE__tds__AddScopes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__AddScopes type=%d location=%p object=%p\n", t, p, q));
		*(_tds__AddScopes*)p = *(_tds__AddScopes*)q;
		break;
	case SOAP_TYPE__tds__AddScopesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__AddScopesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__AddScopesResponse*)p = *(_tds__AddScopesResponse*)q;
		break;
	case SOAP_TYPE__tds__RemoveScopes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__RemoveScopes type=%d location=%p object=%p\n", t, p, q));
		*(_tds__RemoveScopes*)p = *(_tds__RemoveScopes*)q;
		break;
	case SOAP_TYPE__tds__RemoveScopesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__RemoveScopesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__RemoveScopesResponse*)p = *(_tds__RemoveScopesResponse*)q;
		break;
	case SOAP_TYPE__tds__GetDiscoveryMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDiscoveryMode type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDiscoveryMode*)p = *(_tds__GetDiscoveryMode*)q;
		break;
	case SOAP_TYPE__tds__GetDiscoveryModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDiscoveryModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDiscoveryModeResponse*)p = *(_tds__GetDiscoveryModeResponse*)q;
		break;
	case SOAP_TYPE__tds__SetDiscoveryMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetDiscoveryMode type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetDiscoveryMode*)p = *(_tds__SetDiscoveryMode*)q;
		break;
	case SOAP_TYPE__tds__SetDiscoveryModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetDiscoveryModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetDiscoveryModeResponse*)p = *(_tds__SetDiscoveryModeResponse*)q;
		break;
	case SOAP_TYPE__tds__GetRemoteDiscoveryMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetRemoteDiscoveryMode type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetRemoteDiscoveryMode*)p = *(_tds__GetRemoteDiscoveryMode*)q;
		break;
	case SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetRemoteDiscoveryModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetRemoteDiscoveryModeResponse*)p = *(_tds__GetRemoteDiscoveryModeResponse*)q;
		break;
	case SOAP_TYPE__tds__SetRemoteDiscoveryMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetRemoteDiscoveryMode type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetRemoteDiscoveryMode*)p = *(_tds__SetRemoteDiscoveryMode*)q;
		break;
	case SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetRemoteDiscoveryModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetRemoteDiscoveryModeResponse*)p = *(_tds__SetRemoteDiscoveryModeResponse*)q;
		break;
	case SOAP_TYPE__tds__GetDPAddresses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDPAddresses type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDPAddresses*)p = *(_tds__GetDPAddresses*)q;
		break;
	case SOAP_TYPE__tds__GetDPAddressesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDPAddressesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDPAddressesResponse*)p = *(_tds__GetDPAddressesResponse*)q;
		break;
	case SOAP_TYPE__tds__SetDPAddresses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetDPAddresses type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetDPAddresses*)p = *(_tds__SetDPAddresses*)q;
		break;
	case SOAP_TYPE__tds__SetDPAddressesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetDPAddressesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetDPAddressesResponse*)p = *(_tds__SetDPAddressesResponse*)q;
		break;
	case SOAP_TYPE__tds__GetEndpointReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetEndpointReference type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetEndpointReference*)p = *(_tds__GetEndpointReference*)q;
		break;
	case SOAP_TYPE__tds__GetEndpointReferenceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetEndpointReferenceResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetEndpointReferenceResponse*)p = *(_tds__GetEndpointReferenceResponse*)q;
		break;
	case SOAP_TYPE__tds__GetRemoteUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetRemoteUser type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetRemoteUser*)p = *(_tds__GetRemoteUser*)q;
		break;
	case SOAP_TYPE__tds__GetRemoteUserResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetRemoteUserResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetRemoteUserResponse*)p = *(_tds__GetRemoteUserResponse*)q;
		break;
	case SOAP_TYPE__tds__SetRemoteUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetRemoteUser type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetRemoteUser*)p = *(_tds__SetRemoteUser*)q;
		break;
	case SOAP_TYPE__tds__SetRemoteUserResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetRemoteUserResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetRemoteUserResponse*)p = *(_tds__SetRemoteUserResponse*)q;
		break;
	case SOAP_TYPE__tds__GetUsers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetUsers type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetUsers*)p = *(_tds__GetUsers*)q;
		break;
	case SOAP_TYPE__tds__GetUsersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetUsersResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetUsersResponse*)p = *(_tds__GetUsersResponse*)q;
		break;
	case SOAP_TYPE__tds__CreateUsers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__CreateUsers type=%d location=%p object=%p\n", t, p, q));
		*(_tds__CreateUsers*)p = *(_tds__CreateUsers*)q;
		break;
	case SOAP_TYPE__tds__CreateUsersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__CreateUsersResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__CreateUsersResponse*)p = *(_tds__CreateUsersResponse*)q;
		break;
	case SOAP_TYPE__tds__DeleteUsers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__DeleteUsers type=%d location=%p object=%p\n", t, p, q));
		*(_tds__DeleteUsers*)p = *(_tds__DeleteUsers*)q;
		break;
	case SOAP_TYPE__tds__DeleteUsersResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__DeleteUsersResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__DeleteUsersResponse*)p = *(_tds__DeleteUsersResponse*)q;
		break;
	case SOAP_TYPE__tds__SetUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetUser type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetUser*)p = *(_tds__SetUser*)q;
		break;
	case SOAP_TYPE__tds__SetUserResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetUserResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetUserResponse*)p = *(_tds__SetUserResponse*)q;
		break;
	case SOAP_TYPE__tds__GetWsdlUrl:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetWsdlUrl type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetWsdlUrl*)p = *(_tds__GetWsdlUrl*)q;
		break;
	case SOAP_TYPE__tds__GetWsdlUrlResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetWsdlUrlResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetWsdlUrlResponse*)p = *(_tds__GetWsdlUrlResponse*)q;
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetPasswordComplexityOptions type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetPasswordComplexityOptions*)p = *(_tds__GetPasswordComplexityOptions*)q;
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetPasswordComplexityOptionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetPasswordComplexityOptionsResponse*)p = *(_tds__GetPasswordComplexityOptionsResponse*)q;
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetPasswordComplexityConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetPasswordComplexityConfiguration*)p = *(_tds__GetPasswordComplexityConfiguration*)q;
		break;
	case SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetPasswordComplexityConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetPasswordComplexityConfigurationResponse*)p = *(_tds__GetPasswordComplexityConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__SetPasswordComplexityConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetPasswordComplexityConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetPasswordComplexityConfiguration*)p = *(_tds__SetPasswordComplexityConfiguration*)q;
		break;
	case SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetPasswordComplexityConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetPasswordComplexityConfigurationResponse*)p = *(_tds__SetPasswordComplexityConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__GetPasswordHistoryConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetPasswordHistoryConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetPasswordHistoryConfiguration*)p = *(_tds__GetPasswordHistoryConfiguration*)q;
		break;
	case SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetPasswordHistoryConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetPasswordHistoryConfigurationResponse*)p = *(_tds__GetPasswordHistoryConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__SetPasswordHistoryConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetPasswordHistoryConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetPasswordHistoryConfiguration*)p = *(_tds__SetPasswordHistoryConfiguration*)q;
		break;
	case SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetPasswordHistoryConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetPasswordHistoryConfigurationResponse*)p = *(_tds__SetPasswordHistoryConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetAuthFailureWarningOptions type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetAuthFailureWarningOptions*)p = *(_tds__GetAuthFailureWarningOptions*)q;
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetAuthFailureWarningOptionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetAuthFailureWarningOptionsResponse*)p = *(_tds__GetAuthFailureWarningOptionsResponse*)q;
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetAuthFailureWarningConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetAuthFailureWarningConfiguration*)p = *(_tds__GetAuthFailureWarningConfiguration*)q;
		break;
	case SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetAuthFailureWarningConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetAuthFailureWarningConfigurationResponse*)p = *(_tds__GetAuthFailureWarningConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__SetAuthFailureWarningConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetAuthFailureWarningConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetAuthFailureWarningConfiguration*)p = *(_tds__SetAuthFailureWarningConfiguration*)q;
		break;
	case SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetAuthFailureWarningConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetAuthFailureWarningConfigurationResponse*)p = *(_tds__SetAuthFailureWarningConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__GetCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetCapabilities*)p = *(_tds__GetCapabilities*)q;
		break;
	case SOAP_TYPE__tds__GetCapabilitiesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetCapabilitiesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetCapabilitiesResponse*)p = *(_tds__GetCapabilitiesResponse*)q;
		break;
	case SOAP_TYPE__tds__GetHostname:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetHostname type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetHostname*)p = *(_tds__GetHostname*)q;
		break;
	case SOAP_TYPE__tds__GetHostnameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetHostnameResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetHostnameResponse*)p = *(_tds__GetHostnameResponse*)q;
		break;
	case SOAP_TYPE__tds__SetHostname:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetHostname type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetHostname*)p = *(_tds__SetHostname*)q;
		break;
	case SOAP_TYPE__tds__SetHostnameResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetHostnameResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetHostnameResponse*)p = *(_tds__SetHostnameResponse*)q;
		break;
	case SOAP_TYPE__tds__SetHostnameFromDHCP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetHostnameFromDHCP type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetHostnameFromDHCP*)p = *(_tds__SetHostnameFromDHCP*)q;
		break;
	case SOAP_TYPE__tds__SetHostnameFromDHCPResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetHostnameFromDHCPResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetHostnameFromDHCPResponse*)p = *(_tds__SetHostnameFromDHCPResponse*)q;
		break;
	case SOAP_TYPE__tds__GetDNS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDNS type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDNS*)p = *(_tds__GetDNS*)q;
		break;
	case SOAP_TYPE__tds__GetDNSResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDNSResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDNSResponse*)p = *(_tds__GetDNSResponse*)q;
		break;
	case SOAP_TYPE__tds__SetDNS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetDNS type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetDNS*)p = *(_tds__SetDNS*)q;
		break;
	case SOAP_TYPE__tds__SetDNSResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetDNSResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetDNSResponse*)p = *(_tds__SetDNSResponse*)q;
		break;
	case SOAP_TYPE__tds__GetNTP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetNTP type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetNTP*)p = *(_tds__GetNTP*)q;
		break;
	case SOAP_TYPE__tds__GetNTPResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetNTPResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetNTPResponse*)p = *(_tds__GetNTPResponse*)q;
		break;
	case SOAP_TYPE__tds__SetNTP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetNTP type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetNTP*)p = *(_tds__SetNTP*)q;
		break;
	case SOAP_TYPE__tds__SetNTPResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetNTPResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetNTPResponse*)p = *(_tds__SetNTPResponse*)q;
		break;
	case SOAP_TYPE__tds__GetDynamicDNS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDynamicDNS type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDynamicDNS*)p = *(_tds__GetDynamicDNS*)q;
		break;
	case SOAP_TYPE__tds__GetDynamicDNSResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDynamicDNSResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDynamicDNSResponse*)p = *(_tds__GetDynamicDNSResponse*)q;
		break;
	case SOAP_TYPE__tds__SetDynamicDNS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetDynamicDNS type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetDynamicDNS*)p = *(_tds__SetDynamicDNS*)q;
		break;
	case SOAP_TYPE__tds__SetDynamicDNSResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetDynamicDNSResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetDynamicDNSResponse*)p = *(_tds__SetDynamicDNSResponse*)q;
		break;
	case SOAP_TYPE__tds__GetNetworkInterfaces:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetNetworkInterfaces type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetNetworkInterfaces*)p = *(_tds__GetNetworkInterfaces*)q;
		break;
	case SOAP_TYPE__tds__GetNetworkInterfacesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetNetworkInterfacesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetNetworkInterfacesResponse*)p = *(_tds__GetNetworkInterfacesResponse*)q;
		break;
	case SOAP_TYPE__tds__SetNetworkInterfaces:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetNetworkInterfaces type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetNetworkInterfaces*)p = *(_tds__SetNetworkInterfaces*)q;
		break;
	case SOAP_TYPE__tds__SetNetworkInterfacesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetNetworkInterfacesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetNetworkInterfacesResponse*)p = *(_tds__SetNetworkInterfacesResponse*)q;
		break;
	case SOAP_TYPE__tds__GetNetworkProtocols:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetNetworkProtocols type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetNetworkProtocols*)p = *(_tds__GetNetworkProtocols*)q;
		break;
	case SOAP_TYPE__tds__GetNetworkProtocolsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetNetworkProtocolsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetNetworkProtocolsResponse*)p = *(_tds__GetNetworkProtocolsResponse*)q;
		break;
	case SOAP_TYPE__tds__SetNetworkProtocols:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetNetworkProtocols type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetNetworkProtocols*)p = *(_tds__SetNetworkProtocols*)q;
		break;
	case SOAP_TYPE__tds__SetNetworkProtocolsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetNetworkProtocolsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetNetworkProtocolsResponse*)p = *(_tds__SetNetworkProtocolsResponse*)q;
		break;
	case SOAP_TYPE__tds__GetNetworkDefaultGateway:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetNetworkDefaultGateway type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetNetworkDefaultGateway*)p = *(_tds__GetNetworkDefaultGateway*)q;
		break;
	case SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetNetworkDefaultGatewayResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetNetworkDefaultGatewayResponse*)p = *(_tds__GetNetworkDefaultGatewayResponse*)q;
		break;
	case SOAP_TYPE__tds__SetNetworkDefaultGateway:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetNetworkDefaultGateway type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetNetworkDefaultGateway*)p = *(_tds__SetNetworkDefaultGateway*)q;
		break;
	case SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetNetworkDefaultGatewayResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetNetworkDefaultGatewayResponse*)p = *(_tds__SetNetworkDefaultGatewayResponse*)q;
		break;
	case SOAP_TYPE__tds__GetZeroConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetZeroConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetZeroConfiguration*)p = *(_tds__GetZeroConfiguration*)q;
		break;
	case SOAP_TYPE__tds__GetZeroConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetZeroConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetZeroConfigurationResponse*)p = *(_tds__GetZeroConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__SetZeroConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetZeroConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetZeroConfiguration*)p = *(_tds__SetZeroConfiguration*)q;
		break;
	case SOAP_TYPE__tds__SetZeroConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetZeroConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetZeroConfigurationResponse*)p = *(_tds__SetZeroConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__GetIPAddressFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetIPAddressFilter type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetIPAddressFilter*)p = *(_tds__GetIPAddressFilter*)q;
		break;
	case SOAP_TYPE__tds__GetIPAddressFilterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetIPAddressFilterResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetIPAddressFilterResponse*)p = *(_tds__GetIPAddressFilterResponse*)q;
		break;
	case SOAP_TYPE__tds__SetIPAddressFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetIPAddressFilter type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetIPAddressFilter*)p = *(_tds__SetIPAddressFilter*)q;
		break;
	case SOAP_TYPE__tds__SetIPAddressFilterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetIPAddressFilterResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetIPAddressFilterResponse*)p = *(_tds__SetIPAddressFilterResponse*)q;
		break;
	case SOAP_TYPE__tds__AddIPAddressFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__AddIPAddressFilter type=%d location=%p object=%p\n", t, p, q));
		*(_tds__AddIPAddressFilter*)p = *(_tds__AddIPAddressFilter*)q;
		break;
	case SOAP_TYPE__tds__AddIPAddressFilterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__AddIPAddressFilterResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__AddIPAddressFilterResponse*)p = *(_tds__AddIPAddressFilterResponse*)q;
		break;
	case SOAP_TYPE__tds__RemoveIPAddressFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__RemoveIPAddressFilter type=%d location=%p object=%p\n", t, p, q));
		*(_tds__RemoveIPAddressFilter*)p = *(_tds__RemoveIPAddressFilter*)q;
		break;
	case SOAP_TYPE__tds__RemoveIPAddressFilterResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__RemoveIPAddressFilterResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__RemoveIPAddressFilterResponse*)p = *(_tds__RemoveIPAddressFilterResponse*)q;
		break;
	case SOAP_TYPE__tds__GetAccessPolicy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetAccessPolicy type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetAccessPolicy*)p = *(_tds__GetAccessPolicy*)q;
		break;
	case SOAP_TYPE__tds__GetAccessPolicyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetAccessPolicyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetAccessPolicyResponse*)p = *(_tds__GetAccessPolicyResponse*)q;
		break;
	case SOAP_TYPE__tds__SetAccessPolicy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetAccessPolicy type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetAccessPolicy*)p = *(_tds__SetAccessPolicy*)q;
		break;
	case SOAP_TYPE__tds__SetAccessPolicyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetAccessPolicyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetAccessPolicyResponse*)p = *(_tds__SetAccessPolicyResponse*)q;
		break;
	case SOAP_TYPE__tds__CreateCertificate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__CreateCertificate type=%d location=%p object=%p\n", t, p, q));
		*(_tds__CreateCertificate*)p = *(_tds__CreateCertificate*)q;
		break;
	case SOAP_TYPE__tds__CreateCertificateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__CreateCertificateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__CreateCertificateResponse*)p = *(_tds__CreateCertificateResponse*)q;
		break;
	case SOAP_TYPE__tds__GetCertificates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetCertificates type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetCertificates*)p = *(_tds__GetCertificates*)q;
		break;
	case SOAP_TYPE__tds__GetCertificatesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetCertificatesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetCertificatesResponse*)p = *(_tds__GetCertificatesResponse*)q;
		break;
	case SOAP_TYPE__tds__GetCertificatesStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetCertificatesStatus type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetCertificatesStatus*)p = *(_tds__GetCertificatesStatus*)q;
		break;
	case SOAP_TYPE__tds__GetCertificatesStatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetCertificatesStatusResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetCertificatesStatusResponse*)p = *(_tds__GetCertificatesStatusResponse*)q;
		break;
	case SOAP_TYPE__tds__SetCertificatesStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetCertificatesStatus type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetCertificatesStatus*)p = *(_tds__SetCertificatesStatus*)q;
		break;
	case SOAP_TYPE__tds__SetCertificatesStatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetCertificatesStatusResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetCertificatesStatusResponse*)p = *(_tds__SetCertificatesStatusResponse*)q;
		break;
	case SOAP_TYPE__tds__DeleteCertificates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__DeleteCertificates type=%d location=%p object=%p\n", t, p, q));
		*(_tds__DeleteCertificates*)p = *(_tds__DeleteCertificates*)q;
		break;
	case SOAP_TYPE__tds__DeleteCertificatesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__DeleteCertificatesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__DeleteCertificatesResponse*)p = *(_tds__DeleteCertificatesResponse*)q;
		break;
	case SOAP_TYPE__tds__GetPkcs10Request:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetPkcs10Request type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetPkcs10Request*)p = *(_tds__GetPkcs10Request*)q;
		break;
	case SOAP_TYPE__tds__GetPkcs10RequestResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetPkcs10RequestResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetPkcs10RequestResponse*)p = *(_tds__GetPkcs10RequestResponse*)q;
		break;
	case SOAP_TYPE__tds__LoadCertificates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__LoadCertificates type=%d location=%p object=%p\n", t, p, q));
		*(_tds__LoadCertificates*)p = *(_tds__LoadCertificates*)q;
		break;
	case SOAP_TYPE__tds__LoadCertificatesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__LoadCertificatesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__LoadCertificatesResponse*)p = *(_tds__LoadCertificatesResponse*)q;
		break;
	case SOAP_TYPE__tds__GetClientCertificateMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetClientCertificateMode type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetClientCertificateMode*)p = *(_tds__GetClientCertificateMode*)q;
		break;
	case SOAP_TYPE__tds__GetClientCertificateModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetClientCertificateModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetClientCertificateModeResponse*)p = *(_tds__GetClientCertificateModeResponse*)q;
		break;
	case SOAP_TYPE__tds__SetClientCertificateMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetClientCertificateMode type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetClientCertificateMode*)p = *(_tds__SetClientCertificateMode*)q;
		break;
	case SOAP_TYPE__tds__SetClientCertificateModeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetClientCertificateModeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetClientCertificateModeResponse*)p = *(_tds__SetClientCertificateModeResponse*)q;
		break;
	case SOAP_TYPE__tds__GetCACertificates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetCACertificates type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetCACertificates*)p = *(_tds__GetCACertificates*)q;
		break;
	case SOAP_TYPE__tds__GetCACertificatesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetCACertificatesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetCACertificatesResponse*)p = *(_tds__GetCACertificatesResponse*)q;
		break;
	case SOAP_TYPE__tds__LoadCertificateWithPrivateKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__LoadCertificateWithPrivateKey type=%d location=%p object=%p\n", t, p, q));
		*(_tds__LoadCertificateWithPrivateKey*)p = *(_tds__LoadCertificateWithPrivateKey*)q;
		break;
	case SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__LoadCertificateWithPrivateKeyResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__LoadCertificateWithPrivateKeyResponse*)p = *(_tds__LoadCertificateWithPrivateKeyResponse*)q;
		break;
	case SOAP_TYPE__tds__GetCertificateInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetCertificateInformation type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetCertificateInformation*)p = *(_tds__GetCertificateInformation*)q;
		break;
	case SOAP_TYPE__tds__GetCertificateInformationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetCertificateInformationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetCertificateInformationResponse*)p = *(_tds__GetCertificateInformationResponse*)q;
		break;
	case SOAP_TYPE__tds__LoadCACertificates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__LoadCACertificates type=%d location=%p object=%p\n", t, p, q));
		*(_tds__LoadCACertificates*)p = *(_tds__LoadCACertificates*)q;
		break;
	case SOAP_TYPE__tds__LoadCACertificatesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__LoadCACertificatesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__LoadCACertificatesResponse*)p = *(_tds__LoadCACertificatesResponse*)q;
		break;
	case SOAP_TYPE__tds__CreateDot1XConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__CreateDot1XConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__CreateDot1XConfiguration*)p = *(_tds__CreateDot1XConfiguration*)q;
		break;
	case SOAP_TYPE__tds__CreateDot1XConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__CreateDot1XConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__CreateDot1XConfigurationResponse*)p = *(_tds__CreateDot1XConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__SetDot1XConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetDot1XConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetDot1XConfiguration*)p = *(_tds__SetDot1XConfiguration*)q;
		break;
	case SOAP_TYPE__tds__SetDot1XConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetDot1XConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetDot1XConfigurationResponse*)p = *(_tds__SetDot1XConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__GetDot1XConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDot1XConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDot1XConfiguration*)p = *(_tds__GetDot1XConfiguration*)q;
		break;
	case SOAP_TYPE__tds__GetDot1XConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDot1XConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDot1XConfigurationResponse*)p = *(_tds__GetDot1XConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__GetDot1XConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDot1XConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDot1XConfigurations*)p = *(_tds__GetDot1XConfigurations*)q;
		break;
	case SOAP_TYPE__tds__GetDot1XConfigurationsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDot1XConfigurationsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDot1XConfigurationsResponse*)p = *(_tds__GetDot1XConfigurationsResponse*)q;
		break;
	case SOAP_TYPE__tds__DeleteDot1XConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__DeleteDot1XConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__DeleteDot1XConfiguration*)p = *(_tds__DeleteDot1XConfiguration*)q;
		break;
	case SOAP_TYPE__tds__DeleteDot1XConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__DeleteDot1XConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__DeleteDot1XConfigurationResponse*)p = *(_tds__DeleteDot1XConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__GetRelayOutputs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetRelayOutputs type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetRelayOutputs*)p = *(_tds__GetRelayOutputs*)q;
		break;
	case SOAP_TYPE__tds__GetRelayOutputsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetRelayOutputsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetRelayOutputsResponse*)p = *(_tds__GetRelayOutputsResponse*)q;
		break;
	case SOAP_TYPE__tds__SetRelayOutputSettings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetRelayOutputSettings type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetRelayOutputSettings*)p = *(_tds__SetRelayOutputSettings*)q;
		break;
	case SOAP_TYPE__tds__SetRelayOutputSettingsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetRelayOutputSettingsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetRelayOutputSettingsResponse*)p = *(_tds__SetRelayOutputSettingsResponse*)q;
		break;
	case SOAP_TYPE__tds__SetRelayOutputState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetRelayOutputState type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetRelayOutputState*)p = *(_tds__SetRelayOutputState*)q;
		break;
	case SOAP_TYPE__tds__SetRelayOutputStateResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetRelayOutputStateResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetRelayOutputStateResponse*)p = *(_tds__SetRelayOutputStateResponse*)q;
		break;
	case SOAP_TYPE__tds__SendAuxiliaryCommand:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SendAuxiliaryCommand type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SendAuxiliaryCommand*)p = *(_tds__SendAuxiliaryCommand*)q;
		break;
	case SOAP_TYPE__tds__SendAuxiliaryCommandResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SendAuxiliaryCommandResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SendAuxiliaryCommandResponse*)p = *(_tds__SendAuxiliaryCommandResponse*)q;
		break;
	case SOAP_TYPE__tds__GetDot11Capabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDot11Capabilities type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDot11Capabilities*)p = *(_tds__GetDot11Capabilities*)q;
		break;
	case SOAP_TYPE__tds__GetDot11CapabilitiesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDot11CapabilitiesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDot11CapabilitiesResponse*)p = *(_tds__GetDot11CapabilitiesResponse*)q;
		break;
	case SOAP_TYPE__tds__GetDot11Status:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDot11Status type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDot11Status*)p = *(_tds__GetDot11Status*)q;
		break;
	case SOAP_TYPE__tds__GetDot11StatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetDot11StatusResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetDot11StatusResponse*)p = *(_tds__GetDot11StatusResponse*)q;
		break;
	case SOAP_TYPE__tds__ScanAvailableDot11Networks:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__ScanAvailableDot11Networks type=%d location=%p object=%p\n", t, p, q));
		*(_tds__ScanAvailableDot11Networks*)p = *(_tds__ScanAvailableDot11Networks*)q;
		break;
	case SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__ScanAvailableDot11NetworksResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__ScanAvailableDot11NetworksResponse*)p = *(_tds__ScanAvailableDot11NetworksResponse*)q;
		break;
	case SOAP_TYPE__tds__GetSystemUris:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemUris type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemUris*)p = *(_tds__GetSystemUris*)q;
		break;
	case SOAP_TYPE__tds__GetSystemUrisResponse_Extension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemUrisResponse_Extension type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemUrisResponse_Extension*)p = *(_tds__GetSystemUrisResponse_Extension*)q;
		break;
	case SOAP_TYPE__tds__GetSystemUrisResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetSystemUrisResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetSystemUrisResponse*)p = *(_tds__GetSystemUrisResponse*)q;
		break;
	case SOAP_TYPE__tds__StartFirmwareUpgrade:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__StartFirmwareUpgrade type=%d location=%p object=%p\n", t, p, q));
		*(_tds__StartFirmwareUpgrade*)p = *(_tds__StartFirmwareUpgrade*)q;
		break;
	case SOAP_TYPE__tds__StartFirmwareUpgradeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__StartFirmwareUpgradeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__StartFirmwareUpgradeResponse*)p = *(_tds__StartFirmwareUpgradeResponse*)q;
		break;
	case SOAP_TYPE__tds__StartSystemRestore:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__StartSystemRestore type=%d location=%p object=%p\n", t, p, q));
		*(_tds__StartSystemRestore*)p = *(_tds__StartSystemRestore*)q;
		break;
	case SOAP_TYPE__tds__StartSystemRestoreResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__StartSystemRestoreResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__StartSystemRestoreResponse*)p = *(_tds__StartSystemRestoreResponse*)q;
		break;
	case SOAP_TYPE__tds__SetHashingAlgorithm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetHashingAlgorithm type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetHashingAlgorithm*)p = *(_tds__SetHashingAlgorithm*)q;
		break;
	case SOAP_TYPE__tds__SetHashingAlgorithmResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetHashingAlgorithmResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetHashingAlgorithmResponse*)p = *(_tds__SetHashingAlgorithmResponse*)q;
		break;
	case SOAP_TYPE__tds__GetStorageConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetStorageConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetStorageConfigurations*)p = *(_tds__GetStorageConfigurations*)q;
		break;
	case SOAP_TYPE__tds__GetStorageConfigurationsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetStorageConfigurationsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetStorageConfigurationsResponse*)p = *(_tds__GetStorageConfigurationsResponse*)q;
		break;
	case SOAP_TYPE__tds__CreateStorageConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__CreateStorageConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__CreateStorageConfiguration*)p = *(_tds__CreateStorageConfiguration*)q;
		break;
	case SOAP_TYPE__tds__CreateStorageConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__CreateStorageConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__CreateStorageConfigurationResponse*)p = *(_tds__CreateStorageConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__GetStorageConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetStorageConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetStorageConfiguration*)p = *(_tds__GetStorageConfiguration*)q;
		break;
	case SOAP_TYPE__tds__GetStorageConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetStorageConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetStorageConfigurationResponse*)p = *(_tds__GetStorageConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__SetStorageConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetStorageConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetStorageConfiguration*)p = *(_tds__SetStorageConfiguration*)q;
		break;
	case SOAP_TYPE__tds__SetStorageConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetStorageConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetStorageConfigurationResponse*)p = *(_tds__SetStorageConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__DeleteStorageConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__DeleteStorageConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tds__DeleteStorageConfiguration*)p = *(_tds__DeleteStorageConfiguration*)q;
		break;
	case SOAP_TYPE__tds__DeleteStorageConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__DeleteStorageConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__DeleteStorageConfigurationResponse*)p = *(_tds__DeleteStorageConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tds__GetGeoLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetGeoLocation type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetGeoLocation*)p = *(_tds__GetGeoLocation*)q;
		break;
	case SOAP_TYPE__tds__GetGeoLocationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__GetGeoLocationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__GetGeoLocationResponse*)p = *(_tds__GetGeoLocationResponse*)q;
		break;
	case SOAP_TYPE__tds__SetGeoLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetGeoLocation type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetGeoLocation*)p = *(_tds__SetGeoLocation*)q;
		break;
	case SOAP_TYPE__tds__SetGeoLocationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__SetGeoLocationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__SetGeoLocationResponse*)p = *(_tds__SetGeoLocationResponse*)q;
		break;
	case SOAP_TYPE__tds__DeleteGeoLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__DeleteGeoLocation type=%d location=%p object=%p\n", t, p, q));
		*(_tds__DeleteGeoLocation*)p = *(_tds__DeleteGeoLocation*)q;
		break;
	case SOAP_TYPE__tds__DeleteGeoLocationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tds__DeleteGeoLocationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tds__DeleteGeoLocationResponse*)p = *(_tds__DeleteGeoLocationResponse*)q;
		break;
	case SOAP_TYPE_tt__DeviceEntity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DeviceEntity type=%d location=%p object=%p\n", t, p, q));
		*(tt__DeviceEntity*)p = *(tt__DeviceEntity*)q;
		break;
	case SOAP_TYPE_tt__Scope:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Scope type=%d location=%p object=%p\n", t, p, q));
		*(tt__Scope*)p = *(tt__Scope*)q;
		break;
	case SOAP_TYPE_tt__NetworkInterfaceExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkInterfaceExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkInterfaceExtension*)p = *(tt__NetworkInterfaceExtension*)q;
		break;
	case SOAP_TYPE_tt__Dot3Configuration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot3Configuration type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot3Configuration*)p = *(tt__Dot3Configuration*)q;
		break;
	case SOAP_TYPE_tt__NetworkInterfaceExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkInterfaceExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkInterfaceExtension2*)p = *(tt__NetworkInterfaceExtension2*)q;
		break;
	case SOAP_TYPE_tt__NetworkInterfaceLink:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkInterfaceLink type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkInterfaceLink*)p = *(tt__NetworkInterfaceLink*)q;
		break;
	case SOAP_TYPE_tt__NetworkInterfaceConnectionSetting:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkInterfaceConnectionSetting type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkInterfaceConnectionSetting*)p = *(tt__NetworkInterfaceConnectionSetting*)q;
		break;
	case SOAP_TYPE_tt__NetworkInterfaceInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkInterfaceInfo type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkInterfaceInfo*)p = *(tt__NetworkInterfaceInfo*)q;
		break;
	case SOAP_TYPE_tt__IPv6NetworkInterface:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPv6NetworkInterface type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPv6NetworkInterface*)p = *(tt__IPv6NetworkInterface*)q;
		break;
	case SOAP_TYPE_tt__IPv4NetworkInterface:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPv4NetworkInterface type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPv4NetworkInterface*)p = *(tt__IPv4NetworkInterface*)q;
		break;
	case SOAP_TYPE_tt__IPv4Configuration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPv4Configuration type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPv4Configuration*)p = *(tt__IPv4Configuration*)q;
		break;
	case SOAP_TYPE_tt__IPv6Configuration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPv6Configuration type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPv6Configuration*)p = *(tt__IPv6Configuration*)q;
		break;
	case SOAP_TYPE_tt__IPv6ConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPv6ConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPv6ConfigurationExtension*)p = *(tt__IPv6ConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__NetworkProtocol:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkProtocol type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkProtocol*)p = *(tt__NetworkProtocol*)q;
		break;
	case SOAP_TYPE_tt__NetworkProtocolExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkProtocolExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkProtocolExtension*)p = *(tt__NetworkProtocolExtension*)q;
		break;
	case SOAP_TYPE_tt__NetworkHost:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkHost type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkHost*)p = *(tt__NetworkHost*)q;
		break;
	case SOAP_TYPE_tt__NetworkHostExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkHostExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkHostExtension*)p = *(tt__NetworkHostExtension*)q;
		break;
	case SOAP_TYPE_tt__IPAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPAddress type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPAddress*)p = *(tt__IPAddress*)q;
		break;
	case SOAP_TYPE_tt__PrefixedIPv4Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PrefixedIPv4Address type=%d location=%p object=%p\n", t, p, q));
		*(tt__PrefixedIPv4Address*)p = *(tt__PrefixedIPv4Address*)q;
		break;
	case SOAP_TYPE_tt__PrefixedIPv6Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PrefixedIPv6Address type=%d location=%p object=%p\n", t, p, q));
		*(tt__PrefixedIPv6Address*)p = *(tt__PrefixedIPv6Address*)q;
		break;
	case SOAP_TYPE_tt__HostnameInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__HostnameInformation type=%d location=%p object=%p\n", t, p, q));
		*(tt__HostnameInformation*)p = *(tt__HostnameInformation*)q;
		break;
	case SOAP_TYPE_tt__HostnameInformationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__HostnameInformationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__HostnameInformationExtension*)p = *(tt__HostnameInformationExtension*)q;
		break;
	case SOAP_TYPE_tt__DNSInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DNSInformation type=%d location=%p object=%p\n", t, p, q));
		*(tt__DNSInformation*)p = *(tt__DNSInformation*)q;
		break;
	case SOAP_TYPE_tt__DNSInformationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DNSInformationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__DNSInformationExtension*)p = *(tt__DNSInformationExtension*)q;
		break;
	case SOAP_TYPE_tt__NTPInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NTPInformation type=%d location=%p object=%p\n", t, p, q));
		*(tt__NTPInformation*)p = *(tt__NTPInformation*)q;
		break;
	case SOAP_TYPE_tt__NTPInformationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NTPInformationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__NTPInformationExtension*)p = *(tt__NTPInformationExtension*)q;
		break;
	case SOAP_TYPE_tt__DynamicDNSInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DynamicDNSInformation type=%d location=%p object=%p\n", t, p, q));
		*(tt__DynamicDNSInformation*)p = *(tt__DynamicDNSInformation*)q;
		break;
	case SOAP_TYPE_tt__DynamicDNSInformationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DynamicDNSInformationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__DynamicDNSInformationExtension*)p = *(tt__DynamicDNSInformationExtension*)q;
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkInterfaceSetConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkInterfaceSetConfiguration*)p = *(tt__NetworkInterfaceSetConfiguration*)q;
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkInterfaceSetConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkInterfaceSetConfigurationExtension*)p = *(tt__NetworkInterfaceSetConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPv6NetworkInterfaceSetConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPv6NetworkInterfaceSetConfiguration*)p = *(tt__IPv6NetworkInterfaceSetConfiguration*)q;
		break;
	case SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPv4NetworkInterfaceSetConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPv4NetworkInterfaceSetConfiguration*)p = *(tt__IPv4NetworkInterfaceSetConfiguration*)q;
		break;
	case SOAP_TYPE_tt__NetworkGateway:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkGateway type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkGateway*)p = *(tt__NetworkGateway*)q;
		break;
	case SOAP_TYPE_tt__NetworkZeroConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkZeroConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkZeroConfiguration*)p = *(tt__NetworkZeroConfiguration*)q;
		break;
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkZeroConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkZeroConfigurationExtension*)p = *(tt__NetworkZeroConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__NetworkZeroConfigurationExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkZeroConfigurationExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkZeroConfigurationExtension2*)p = *(tt__NetworkZeroConfigurationExtension2*)q;
		break;
	case SOAP_TYPE_tt__IPAddressFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPAddressFilter type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPAddressFilter*)p = *(tt__IPAddressFilter*)q;
		break;
	case SOAP_TYPE_tt__IPAddressFilterExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IPAddressFilterExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__IPAddressFilterExtension*)p = *(tt__IPAddressFilterExtension*)q;
		break;
	case SOAP_TYPE_tt__Dot11Configuration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot11Configuration type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot11Configuration*)p = *(tt__Dot11Configuration*)q;
		break;
	case SOAP_TYPE_tt__Dot11SecurityConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot11SecurityConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot11SecurityConfiguration*)p = *(tt__Dot11SecurityConfiguration*)q;
		break;
	case SOAP_TYPE_tt__Dot11SecurityConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot11SecurityConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot11SecurityConfigurationExtension*)p = *(tt__Dot11SecurityConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__Dot11PSKSet:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot11PSKSet type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot11PSKSet*)p = *(tt__Dot11PSKSet*)q;
		break;
	case SOAP_TYPE_tt__Dot11PSKSetExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot11PSKSetExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot11PSKSetExtension*)p = *(tt__Dot11PSKSetExtension*)q;
		break;
	case SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkInterfaceSetConfigurationExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkInterfaceSetConfigurationExtension2*)p = *(tt__NetworkInterfaceSetConfigurationExtension2*)q;
		break;
	case SOAP_TYPE_tt__Dot11Capabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot11Capabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot11Capabilities*)p = *(tt__Dot11Capabilities*)q;
		break;
	case SOAP_TYPE_tt__Dot11Status:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot11Status type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot11Status*)p = *(tt__Dot11Status*)q;
		break;
	case SOAP_TYPE_tt__Dot11AvailableNetworks:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot11AvailableNetworks type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot11AvailableNetworks*)p = *(tt__Dot11AvailableNetworks*)q;
		break;
	case SOAP_TYPE_tt__Dot11AvailableNetworksExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot11AvailableNetworksExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot11AvailableNetworksExtension*)p = *(tt__Dot11AvailableNetworksExtension*)q;
		break;
	case SOAP_TYPE_tt__Capabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Capabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__Capabilities*)p = *(tt__Capabilities*)q;
		break;
	case SOAP_TYPE_tt__CapabilitiesExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__CapabilitiesExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__CapabilitiesExtension*)p = *(tt__CapabilitiesExtension*)q;
		break;
	case SOAP_TYPE_tt__CapabilitiesExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__CapabilitiesExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__CapabilitiesExtension2*)p = *(tt__CapabilitiesExtension2*)q;
		break;
	case SOAP_TYPE_tt__AnalyticsCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AnalyticsCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__AnalyticsCapabilities*)p = *(tt__AnalyticsCapabilities*)q;
		break;
	case SOAP_TYPE_tt__DeviceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DeviceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__DeviceCapabilities*)p = *(tt__DeviceCapabilities*)q;
		break;
	case SOAP_TYPE_tt__DeviceCapabilitiesExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DeviceCapabilitiesExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__DeviceCapabilitiesExtension*)p = *(tt__DeviceCapabilitiesExtension*)q;
		break;
	case SOAP_TYPE_tt__EventCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__EventCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__EventCapabilities*)p = *(tt__EventCapabilities*)q;
		break;
	case SOAP_TYPE_tt__IOCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IOCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__IOCapabilities*)p = *(tt__IOCapabilities*)q;
		break;
	case SOAP_TYPE_tt__IOCapabilitiesExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IOCapabilitiesExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__IOCapabilitiesExtension*)p = *(tt__IOCapabilitiesExtension*)q;
		break;
	case SOAP_TYPE_tt__IOCapabilitiesExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IOCapabilitiesExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__IOCapabilitiesExtension2*)p = *(tt__IOCapabilitiesExtension2*)q;
		break;
	case SOAP_TYPE_tt__MediaCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__MediaCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__MediaCapabilities*)p = *(tt__MediaCapabilities*)q;
		break;
	case SOAP_TYPE_tt__MediaCapabilitiesExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__MediaCapabilitiesExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__MediaCapabilitiesExtension*)p = *(tt__MediaCapabilitiesExtension*)q;
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RealTimeStreamingCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__RealTimeStreamingCapabilities*)p = *(tt__RealTimeStreamingCapabilities*)q;
		break;
	case SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RealTimeStreamingCapabilitiesExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__RealTimeStreamingCapabilitiesExtension*)p = *(tt__RealTimeStreamingCapabilitiesExtension*)q;
		break;
	case SOAP_TYPE_tt__ProfileCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ProfileCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__ProfileCapabilities*)p = *(tt__ProfileCapabilities*)q;
		break;
	case SOAP_TYPE_tt__NetworkCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkCapabilities*)p = *(tt__NetworkCapabilities*)q;
		break;
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkCapabilitiesExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkCapabilitiesExtension*)p = *(tt__NetworkCapabilitiesExtension*)q;
		break;
	case SOAP_TYPE_tt__NetworkCapabilitiesExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkCapabilitiesExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkCapabilitiesExtension2*)p = *(tt__NetworkCapabilitiesExtension2*)q;
		break;
	case SOAP_TYPE_tt__SecurityCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SecurityCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__SecurityCapabilities*)p = *(tt__SecurityCapabilities*)q;
		break;
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SecurityCapabilitiesExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__SecurityCapabilitiesExtension*)p = *(tt__SecurityCapabilitiesExtension*)q;
		break;
	case SOAP_TYPE_tt__SecurityCapabilitiesExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SecurityCapabilitiesExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__SecurityCapabilitiesExtension2*)p = *(tt__SecurityCapabilitiesExtension2*)q;
		break;
	case SOAP_TYPE_tt__SystemCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SystemCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__SystemCapabilities*)p = *(tt__SystemCapabilities*)q;
		break;
	case SOAP_TYPE_tt__SystemCapabilitiesExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SystemCapabilitiesExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__SystemCapabilitiesExtension*)p = *(tt__SystemCapabilitiesExtension*)q;
		break;
	case SOAP_TYPE_tt__SystemCapabilitiesExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SystemCapabilitiesExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__SystemCapabilitiesExtension2*)p = *(tt__SystemCapabilitiesExtension2*)q;
		break;
	case SOAP_TYPE_tt__OnvifVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__OnvifVersion type=%d location=%p object=%p\n", t, p, q));
		*(tt__OnvifVersion*)p = *(tt__OnvifVersion*)q;
		break;
	case SOAP_TYPE_tt__ImagingCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ImagingCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__ImagingCapabilities*)p = *(tt__ImagingCapabilities*)q;
		break;
	case SOAP_TYPE_tt__PTZCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZCapabilities*)p = *(tt__PTZCapabilities*)q;
		break;
	case SOAP_TYPE_tt__DeviceIOCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DeviceIOCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__DeviceIOCapabilities*)p = *(tt__DeviceIOCapabilities*)q;
		break;
	case SOAP_TYPE_tt__DisplayCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DisplayCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__DisplayCapabilities*)p = *(tt__DisplayCapabilities*)q;
		break;
	case SOAP_TYPE_tt__RecordingCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RecordingCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__RecordingCapabilities*)p = *(tt__RecordingCapabilities*)q;
		break;
	case SOAP_TYPE_tt__SearchCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SearchCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__SearchCapabilities*)p = *(tt__SearchCapabilities*)q;
		break;
	case SOAP_TYPE_tt__ReplayCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ReplayCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__ReplayCapabilities*)p = *(tt__ReplayCapabilities*)q;
		break;
	case SOAP_TYPE_tt__ReceiverCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ReceiverCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__ReceiverCapabilities*)p = *(tt__ReceiverCapabilities*)q;
		break;
	case SOAP_TYPE_tt__AnalyticsDeviceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AnalyticsDeviceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(tt__AnalyticsDeviceCapabilities*)p = *(tt__AnalyticsDeviceCapabilities*)q;
		break;
	case SOAP_TYPE_tt__AnalyticsDeviceExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AnalyticsDeviceExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__AnalyticsDeviceExtension*)p = *(tt__AnalyticsDeviceExtension*)q;
		break;
	case SOAP_TYPE_tt__SystemLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SystemLog type=%d location=%p object=%p\n", t, p, q));
		*(tt__SystemLog*)p = *(tt__SystemLog*)q;
		break;
	case SOAP_TYPE_tt__SupportInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SupportInformation type=%d location=%p object=%p\n", t, p, q));
		*(tt__SupportInformation*)p = *(tt__SupportInformation*)q;
		break;
	case SOAP_TYPE_tt__BinaryData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__BinaryData type=%d location=%p object=%p\n", t, p, q));
		*(tt__BinaryData*)p = *(tt__BinaryData*)q;
		break;
	case SOAP_TYPE_tt__AttachmentData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__AttachmentData type=%d location=%p object=%p\n", t, p, q));
		*(tt__AttachmentData*)p = *(tt__AttachmentData*)q;
		break;
	case SOAP_TYPE_tt__BackupFile:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__BackupFile type=%d location=%p object=%p\n", t, p, q));
		*(tt__BackupFile*)p = *(tt__BackupFile*)q;
		break;
	case SOAP_TYPE_tt__SystemLogUriList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SystemLogUriList type=%d location=%p object=%p\n", t, p, q));
		*(tt__SystemLogUriList*)p = *(tt__SystemLogUriList*)q;
		break;
	case SOAP_TYPE_tt__SystemLogUri:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SystemLogUri type=%d location=%p object=%p\n", t, p, q));
		*(tt__SystemLogUri*)p = *(tt__SystemLogUri*)q;
		break;
	case SOAP_TYPE_tt__SystemDateTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SystemDateTime type=%d location=%p object=%p\n", t, p, q));
		*(tt__SystemDateTime*)p = *(tt__SystemDateTime*)q;
		break;
	case SOAP_TYPE_tt__SystemDateTimeExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__SystemDateTimeExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__SystemDateTimeExtension*)p = *(tt__SystemDateTimeExtension*)q;
		break;
	case SOAP_TYPE_tt__DateTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DateTime type=%d location=%p object=%p\n", t, p, q));
		*(tt__DateTime*)p = *(tt__DateTime*)q;
		break;
	case SOAP_TYPE_tt__Date:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Date type=%d location=%p object=%p\n", t, p, q));
		*(tt__Date*)p = *(tt__Date*)q;
		break;
	case SOAP_TYPE_tt__Time:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Time type=%d location=%p object=%p\n", t, p, q));
		*(tt__Time*)p = *(tt__Time*)q;
		break;
	case SOAP_TYPE_tt__TimeZone:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__TimeZone type=%d location=%p object=%p\n", t, p, q));
		*(tt__TimeZone*)p = *(tt__TimeZone*)q;
		break;
	case SOAP_TYPE_tt__RemoteUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RemoteUser type=%d location=%p object=%p\n", t, p, q));
		*(tt__RemoteUser*)p = *(tt__RemoteUser*)q;
		break;
	case SOAP_TYPE_tt__User:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__User type=%d location=%p object=%p\n", t, p, q));
		*(tt__User*)p = *(tt__User*)q;
		break;
	case SOAP_TYPE_tt__UserExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__UserExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__UserExtension*)p = *(tt__UserExtension*)q;
		break;
	case SOAP_TYPE_tt__Certificate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Certificate type=%d location=%p object=%p\n", t, p, q));
		*(tt__Certificate*)p = *(tt__Certificate*)q;
		break;
	case SOAP_TYPE_tt__CertificateStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__CertificateStatus type=%d location=%p object=%p\n", t, p, q));
		*(tt__CertificateStatus*)p = *(tt__CertificateStatus*)q;
		break;
	case SOAP_TYPE_tt__CertificateWithPrivateKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__CertificateWithPrivateKey type=%d location=%p object=%p\n", t, p, q));
		*(tt__CertificateWithPrivateKey*)p = *(tt__CertificateWithPrivateKey*)q;
		break;
	case SOAP_TYPE_tt__CertificateInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__CertificateInformation type=%d location=%p object=%p\n", t, p, q));
		*(tt__CertificateInformation*)p = *(tt__CertificateInformation*)q;
		break;
	case SOAP_TYPE_tt__CertificateInformationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__CertificateInformationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__CertificateInformationExtension*)p = *(tt__CertificateInformationExtension*)q;
		break;
	case SOAP_TYPE_tt__Dot1XConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot1XConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot1XConfiguration*)p = *(tt__Dot1XConfiguration*)q;
		break;
	case SOAP_TYPE_tt__Dot1XConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Dot1XConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__Dot1XConfigurationExtension*)p = *(tt__Dot1XConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__EAPMethodConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__EAPMethodConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__EAPMethodConfiguration*)p = *(tt__EAPMethodConfiguration*)q;
		break;
	case SOAP_TYPE_tt__EapMethodExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__EapMethodExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__EapMethodExtension*)p = *(tt__EapMethodExtension*)q;
		break;
	case SOAP_TYPE_tt__TLSConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__TLSConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__TLSConfiguration*)p = *(tt__TLSConfiguration*)q;
		break;
	case SOAP_TYPE_tt__RelayOutputSettings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RelayOutputSettings type=%d location=%p object=%p\n", t, p, q));
		*(tt__RelayOutputSettings*)p = *(tt__RelayOutputSettings*)q;
		break;
	case SOAP_TYPE_tt__DateTimeRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DateTimeRange type=%d location=%p object=%p\n", t, p, q));
		*(tt__DateTimeRange*)p = *(tt__DateTimeRange*)q;
		break;
	case SOAP_TYPE_tt__IntRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IntRange type=%d location=%p object=%p\n", t, p, q));
		*(tt__IntRange*)p = *(tt__IntRange*)q;
		break;
	case SOAP_TYPE_tt__GeoLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__GeoLocation type=%d location=%p object=%p\n", t, p, q));
		*(tt__GeoLocation*)p = *(tt__GeoLocation*)q;
		break;
	case SOAP_TYPE_tt__GeoOrientation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__GeoOrientation type=%d location=%p object=%p\n", t, p, q));
		*(tt__GeoOrientation*)p = *(tt__GeoOrientation*)q;
		break;
	case SOAP_TYPE_tt__LocalLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__LocalLocation type=%d location=%p object=%p\n", t, p, q));
		*(tt__LocalLocation*)p = *(tt__LocalLocation*)q;
		break;
	case SOAP_TYPE_tt__LocalOrientation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__LocalOrientation type=%d location=%p object=%p\n", t, p, q));
		*(tt__LocalOrientation*)p = *(tt__LocalOrientation*)q;
		break;
	case SOAP_TYPE_tt__LocationEntity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__LocationEntity type=%d location=%p object=%p\n", t, p, q));
		*(tt__LocationEntity*)p = *(tt__LocationEntity*)q;
		break;
	case SOAP_TYPE_tds__StorageConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tds__StorageConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tds__StorageConfiguration*)p = *(tds__StorageConfiguration*)q;
		break;
	case SOAP_TYPE_tt__NetworkInterface:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__NetworkInterface type=%d location=%p object=%p\n", t, p, q));
		*(tt__NetworkInterface*)p = *(tt__NetworkInterface*)q;
		break;
	case SOAP_TYPE_tt__CertificateUsage:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__CertificateUsage type=%d location=%p object=%p\n", t, p, q));
		*(tt__CertificateUsage*)p = *(tt__CertificateUsage*)q;
		break;
	case SOAP_TYPE_tt__RelayOutput:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__RelayOutput type=%d location=%p object=%p\n", t, p, q));
		*(tt__RelayOutput*)p = *(tt__RelayOutput*)q;
		break;
	case SOAP_TYPE___tds__GetServices:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetServices type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetServices*)p = *(struct __tds__GetServices*)q;
		break;
	case SOAP_TYPE___tds__GetServiceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetServiceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetServiceCapabilities*)p = *(struct __tds__GetServiceCapabilities*)q;
		break;
	case SOAP_TYPE___tds__GetDeviceInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetDeviceInformation type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetDeviceInformation*)p = *(struct __tds__GetDeviceInformation*)q;
		break;
	case SOAP_TYPE___tds__SetSystemDateAndTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetSystemDateAndTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetSystemDateAndTime*)p = *(struct __tds__SetSystemDateAndTime*)q;
		break;
	case SOAP_TYPE___tds__GetSystemDateAndTime:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetSystemDateAndTime type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetSystemDateAndTime*)p = *(struct __tds__GetSystemDateAndTime*)q;
		break;
	case SOAP_TYPE___tds__SetSystemFactoryDefault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetSystemFactoryDefault type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetSystemFactoryDefault*)p = *(struct __tds__SetSystemFactoryDefault*)q;
		break;
	case SOAP_TYPE___tds__UpgradeSystemFirmware:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__UpgradeSystemFirmware type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__UpgradeSystemFirmware*)p = *(struct __tds__UpgradeSystemFirmware*)q;
		break;
	case SOAP_TYPE___tds__SystemReboot:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SystemReboot type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SystemReboot*)p = *(struct __tds__SystemReboot*)q;
		break;
	case SOAP_TYPE___tds__RestoreSystem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__RestoreSystem type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__RestoreSystem*)p = *(struct __tds__RestoreSystem*)q;
		break;
	case SOAP_TYPE___tds__GetSystemBackup:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetSystemBackup type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetSystemBackup*)p = *(struct __tds__GetSystemBackup*)q;
		break;
	case SOAP_TYPE___tds__GetSystemLog:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetSystemLog type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetSystemLog*)p = *(struct __tds__GetSystemLog*)q;
		break;
	case SOAP_TYPE___tds__GetSystemSupportInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetSystemSupportInformation type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetSystemSupportInformation*)p = *(struct __tds__GetSystemSupportInformation*)q;
		break;
	case SOAP_TYPE___tds__GetScopes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetScopes type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetScopes*)p = *(struct __tds__GetScopes*)q;
		break;
	case SOAP_TYPE___tds__SetScopes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetScopes type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetScopes*)p = *(struct __tds__SetScopes*)q;
		break;
	case SOAP_TYPE___tds__AddScopes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__AddScopes type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__AddScopes*)p = *(struct __tds__AddScopes*)q;
		break;
	case SOAP_TYPE___tds__RemoveScopes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__RemoveScopes type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__RemoveScopes*)p = *(struct __tds__RemoveScopes*)q;
		break;
	case SOAP_TYPE___tds__GetDiscoveryMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetDiscoveryMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetDiscoveryMode*)p = *(struct __tds__GetDiscoveryMode*)q;
		break;
	case SOAP_TYPE___tds__SetDiscoveryMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetDiscoveryMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetDiscoveryMode*)p = *(struct __tds__SetDiscoveryMode*)q;
		break;
	case SOAP_TYPE___tds__GetRemoteDiscoveryMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetRemoteDiscoveryMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetRemoteDiscoveryMode*)p = *(struct __tds__GetRemoteDiscoveryMode*)q;
		break;
	case SOAP_TYPE___tds__SetRemoteDiscoveryMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetRemoteDiscoveryMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetRemoteDiscoveryMode*)p = *(struct __tds__SetRemoteDiscoveryMode*)q;
		break;
	case SOAP_TYPE___tds__GetDPAddresses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetDPAddresses type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetDPAddresses*)p = *(struct __tds__GetDPAddresses*)q;
		break;
	case SOAP_TYPE___tds__GetEndpointReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetEndpointReference type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetEndpointReference*)p = *(struct __tds__GetEndpointReference*)q;
		break;
	case SOAP_TYPE___tds__GetRemoteUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetRemoteUser type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetRemoteUser*)p = *(struct __tds__GetRemoteUser*)q;
		break;
	case SOAP_TYPE___tds__SetRemoteUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetRemoteUser type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetRemoteUser*)p = *(struct __tds__SetRemoteUser*)q;
		break;
	case SOAP_TYPE___tds__GetUsers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetUsers type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetUsers*)p = *(struct __tds__GetUsers*)q;
		break;
	case SOAP_TYPE___tds__CreateUsers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__CreateUsers type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__CreateUsers*)p = *(struct __tds__CreateUsers*)q;
		break;
	case SOAP_TYPE___tds__DeleteUsers:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__DeleteUsers type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__DeleteUsers*)p = *(struct __tds__DeleteUsers*)q;
		break;
	case SOAP_TYPE___tds__SetUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetUser type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetUser*)p = *(struct __tds__SetUser*)q;
		break;
	case SOAP_TYPE___tds__GetWsdlUrl:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetWsdlUrl type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetWsdlUrl*)p = *(struct __tds__GetWsdlUrl*)q;
		break;
	case SOAP_TYPE___tds__GetPasswordComplexityOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetPasswordComplexityOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetPasswordComplexityOptions*)p = *(struct __tds__GetPasswordComplexityOptions*)q;
		break;
	case SOAP_TYPE___tds__GetPasswordComplexityConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetPasswordComplexityConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetPasswordComplexityConfiguration*)p = *(struct __tds__GetPasswordComplexityConfiguration*)q;
		break;
	case SOAP_TYPE___tds__SetPasswordComplexityConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetPasswordComplexityConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetPasswordComplexityConfiguration*)p = *(struct __tds__SetPasswordComplexityConfiguration*)q;
		break;
	case SOAP_TYPE___tds__GetPasswordHistoryConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetPasswordHistoryConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetPasswordHistoryConfiguration*)p = *(struct __tds__GetPasswordHistoryConfiguration*)q;
		break;
	case SOAP_TYPE___tds__SetPasswordHistoryConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetPasswordHistoryConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetPasswordHistoryConfiguration*)p = *(struct __tds__SetPasswordHistoryConfiguration*)q;
		break;
	case SOAP_TYPE___tds__GetAuthFailureWarningOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetAuthFailureWarningOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetAuthFailureWarningOptions*)p = *(struct __tds__GetAuthFailureWarningOptions*)q;
		break;
	case SOAP_TYPE___tds__GetAuthFailureWarningConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetAuthFailureWarningConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetAuthFailureWarningConfiguration*)p = *(struct __tds__GetAuthFailureWarningConfiguration*)q;
		break;
	case SOAP_TYPE___tds__SetAuthFailureWarningConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetAuthFailureWarningConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetAuthFailureWarningConfiguration*)p = *(struct __tds__SetAuthFailureWarningConfiguration*)q;
		break;
	case SOAP_TYPE___tds__GetCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetCapabilities*)p = *(struct __tds__GetCapabilities*)q;
		break;
	case SOAP_TYPE___tds__SetDPAddresses:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetDPAddresses type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetDPAddresses*)p = *(struct __tds__SetDPAddresses*)q;
		break;
	case SOAP_TYPE___tds__GetHostname:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetHostname type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetHostname*)p = *(struct __tds__GetHostname*)q;
		break;
	case SOAP_TYPE___tds__SetHostname:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetHostname type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetHostname*)p = *(struct __tds__SetHostname*)q;
		break;
	case SOAP_TYPE___tds__SetHostnameFromDHCP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetHostnameFromDHCP type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetHostnameFromDHCP*)p = *(struct __tds__SetHostnameFromDHCP*)q;
		break;
	case SOAP_TYPE___tds__GetDNS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetDNS type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetDNS*)p = *(struct __tds__GetDNS*)q;
		break;
	case SOAP_TYPE___tds__SetDNS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetDNS type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetDNS*)p = *(struct __tds__SetDNS*)q;
		break;
	case SOAP_TYPE___tds__GetNTP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetNTP type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetNTP*)p = *(struct __tds__GetNTP*)q;
		break;
	case SOAP_TYPE___tds__SetNTP:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetNTP type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetNTP*)p = *(struct __tds__SetNTP*)q;
		break;
	case SOAP_TYPE___tds__GetDynamicDNS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetDynamicDNS type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetDynamicDNS*)p = *(struct __tds__GetDynamicDNS*)q;
		break;
	case SOAP_TYPE___tds__SetDynamicDNS:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetDynamicDNS type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetDynamicDNS*)p = *(struct __tds__SetDynamicDNS*)q;
		break;
	case SOAP_TYPE___tds__GetNetworkInterfaces:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetNetworkInterfaces type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetNetworkInterfaces*)p = *(struct __tds__GetNetworkInterfaces*)q;
		break;
	case SOAP_TYPE___tds__SetNetworkInterfaces:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetNetworkInterfaces type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetNetworkInterfaces*)p = *(struct __tds__SetNetworkInterfaces*)q;
		break;
	case SOAP_TYPE___tds__GetNetworkProtocols:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetNetworkProtocols type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetNetworkProtocols*)p = *(struct __tds__GetNetworkProtocols*)q;
		break;
	case SOAP_TYPE___tds__SetNetworkProtocols:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetNetworkProtocols type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetNetworkProtocols*)p = *(struct __tds__SetNetworkProtocols*)q;
		break;
	case SOAP_TYPE___tds__GetNetworkDefaultGateway:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetNetworkDefaultGateway type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetNetworkDefaultGateway*)p = *(struct __tds__GetNetworkDefaultGateway*)q;
		break;
	case SOAP_TYPE___tds__SetNetworkDefaultGateway:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetNetworkDefaultGateway type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetNetworkDefaultGateway*)p = *(struct __tds__SetNetworkDefaultGateway*)q;
		break;
	case SOAP_TYPE___tds__GetZeroConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetZeroConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetZeroConfiguration*)p = *(struct __tds__GetZeroConfiguration*)q;
		break;
	case SOAP_TYPE___tds__SetZeroConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetZeroConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetZeroConfiguration*)p = *(struct __tds__SetZeroConfiguration*)q;
		break;
	case SOAP_TYPE___tds__GetIPAddressFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetIPAddressFilter type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetIPAddressFilter*)p = *(struct __tds__GetIPAddressFilter*)q;
		break;
	case SOAP_TYPE___tds__SetIPAddressFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetIPAddressFilter type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetIPAddressFilter*)p = *(struct __tds__SetIPAddressFilter*)q;
		break;
	case SOAP_TYPE___tds__AddIPAddressFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__AddIPAddressFilter type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__AddIPAddressFilter*)p = *(struct __tds__AddIPAddressFilter*)q;
		break;
	case SOAP_TYPE___tds__RemoveIPAddressFilter:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__RemoveIPAddressFilter type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__RemoveIPAddressFilter*)p = *(struct __tds__RemoveIPAddressFilter*)q;
		break;
	case SOAP_TYPE___tds__GetAccessPolicy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetAccessPolicy type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetAccessPolicy*)p = *(struct __tds__GetAccessPolicy*)q;
		break;
	case SOAP_TYPE___tds__SetAccessPolicy:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetAccessPolicy type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetAccessPolicy*)p = *(struct __tds__SetAccessPolicy*)q;
		break;
	case SOAP_TYPE___tds__CreateCertificate:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__CreateCertificate type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__CreateCertificate*)p = *(struct __tds__CreateCertificate*)q;
		break;
	case SOAP_TYPE___tds__GetCertificates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetCertificates type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetCertificates*)p = *(struct __tds__GetCertificates*)q;
		break;
	case SOAP_TYPE___tds__GetCertificatesStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetCertificatesStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetCertificatesStatus*)p = *(struct __tds__GetCertificatesStatus*)q;
		break;
	case SOAP_TYPE___tds__SetCertificatesStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetCertificatesStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetCertificatesStatus*)p = *(struct __tds__SetCertificatesStatus*)q;
		break;
	case SOAP_TYPE___tds__DeleteCertificates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__DeleteCertificates type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__DeleteCertificates*)p = *(struct __tds__DeleteCertificates*)q;
		break;
	case SOAP_TYPE___tds__GetPkcs10Request:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetPkcs10Request type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetPkcs10Request*)p = *(struct __tds__GetPkcs10Request*)q;
		break;
	case SOAP_TYPE___tds__LoadCertificates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__LoadCertificates type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__LoadCertificates*)p = *(struct __tds__LoadCertificates*)q;
		break;
	case SOAP_TYPE___tds__GetClientCertificateMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetClientCertificateMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetClientCertificateMode*)p = *(struct __tds__GetClientCertificateMode*)q;
		break;
	case SOAP_TYPE___tds__SetClientCertificateMode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetClientCertificateMode type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetClientCertificateMode*)p = *(struct __tds__SetClientCertificateMode*)q;
		break;
	case SOAP_TYPE___tds__GetRelayOutputs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetRelayOutputs type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetRelayOutputs*)p = *(struct __tds__GetRelayOutputs*)q;
		break;
	case SOAP_TYPE___tds__SetRelayOutputSettings:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetRelayOutputSettings type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetRelayOutputSettings*)p = *(struct __tds__SetRelayOutputSettings*)q;
		break;
	case SOAP_TYPE___tds__SetRelayOutputState:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetRelayOutputState type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetRelayOutputState*)p = *(struct __tds__SetRelayOutputState*)q;
		break;
	case SOAP_TYPE___tds__SendAuxiliaryCommand:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SendAuxiliaryCommand type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SendAuxiliaryCommand*)p = *(struct __tds__SendAuxiliaryCommand*)q;
		break;
	case SOAP_TYPE___tds__GetCACertificates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetCACertificates type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetCACertificates*)p = *(struct __tds__GetCACertificates*)q;
		break;
	case SOAP_TYPE___tds__LoadCertificateWithPrivateKey:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__LoadCertificateWithPrivateKey type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__LoadCertificateWithPrivateKey*)p = *(struct __tds__LoadCertificateWithPrivateKey*)q;
		break;
	case SOAP_TYPE___tds__GetCertificateInformation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetCertificateInformation type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetCertificateInformation*)p = *(struct __tds__GetCertificateInformation*)q;
		break;
	case SOAP_TYPE___tds__LoadCACertificates:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__LoadCACertificates type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__LoadCACertificates*)p = *(struct __tds__LoadCACertificates*)q;
		break;
	case SOAP_TYPE___tds__CreateDot1XConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__CreateDot1XConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__CreateDot1XConfiguration*)p = *(struct __tds__CreateDot1XConfiguration*)q;
		break;
	case SOAP_TYPE___tds__SetDot1XConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetDot1XConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetDot1XConfiguration*)p = *(struct __tds__SetDot1XConfiguration*)q;
		break;
	case SOAP_TYPE___tds__GetDot1XConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetDot1XConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetDot1XConfiguration*)p = *(struct __tds__GetDot1XConfiguration*)q;
		break;
	case SOAP_TYPE___tds__GetDot1XConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetDot1XConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetDot1XConfigurations*)p = *(struct __tds__GetDot1XConfigurations*)q;
		break;
	case SOAP_TYPE___tds__DeleteDot1XConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__DeleteDot1XConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__DeleteDot1XConfiguration*)p = *(struct __tds__DeleteDot1XConfiguration*)q;
		break;
	case SOAP_TYPE___tds__GetDot11Capabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetDot11Capabilities type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetDot11Capabilities*)p = *(struct __tds__GetDot11Capabilities*)q;
		break;
	case SOAP_TYPE___tds__GetDot11Status:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetDot11Status type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetDot11Status*)p = *(struct __tds__GetDot11Status*)q;
		break;
	case SOAP_TYPE___tds__ScanAvailableDot11Networks:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__ScanAvailableDot11Networks type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__ScanAvailableDot11Networks*)p = *(struct __tds__ScanAvailableDot11Networks*)q;
		break;
	case SOAP_TYPE___tds__GetSystemUris:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetSystemUris type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetSystemUris*)p = *(struct __tds__GetSystemUris*)q;
		break;
	case SOAP_TYPE___tds__StartFirmwareUpgrade:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__StartFirmwareUpgrade type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__StartFirmwareUpgrade*)p = *(struct __tds__StartFirmwareUpgrade*)q;
		break;
	case SOAP_TYPE___tds__StartSystemRestore:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__StartSystemRestore type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__StartSystemRestore*)p = *(struct __tds__StartSystemRestore*)q;
		break;
	case SOAP_TYPE___tds__GetStorageConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetStorageConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetStorageConfigurations*)p = *(struct __tds__GetStorageConfigurations*)q;
		break;
	case SOAP_TYPE___tds__CreateStorageConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__CreateStorageConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__CreateStorageConfiguration*)p = *(struct __tds__CreateStorageConfiguration*)q;
		break;
	case SOAP_TYPE___tds__GetStorageConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetStorageConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetStorageConfiguration*)p = *(struct __tds__GetStorageConfiguration*)q;
		break;
	case SOAP_TYPE___tds__SetStorageConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetStorageConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetStorageConfiguration*)p = *(struct __tds__SetStorageConfiguration*)q;
		break;
	case SOAP_TYPE___tds__DeleteStorageConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__DeleteStorageConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__DeleteStorageConfiguration*)p = *(struct __tds__DeleteStorageConfiguration*)q;
		break;
	case SOAP_TYPE___tds__GetGeoLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__GetGeoLocation type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__GetGeoLocation*)p = *(struct __tds__GetGeoLocation*)q;
		break;
	case SOAP_TYPE___tds__SetGeoLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetGeoLocation type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetGeoLocation*)p = *(struct __tds__SetGeoLocation*)q;
		break;
	case SOAP_TYPE___tds__DeleteGeoLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__DeleteGeoLocation type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__DeleteGeoLocation*)p = *(struct __tds__DeleteGeoLocation*)q;
		break;
	case SOAP_TYPE___tds__SetHashingAlgorithm:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tds__SetHashingAlgorithm type=%d location=%p object=%p\n", t, p, q));
		*(struct __tds__SetHashingAlgorithm*)p = *(struct __tds__SetHashingAlgorithm*)q;
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE__wsa5__Metadata:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__From:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE_xsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__NCName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__duration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__integer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__token:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__xml__lang:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__IntList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__StringAttrList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__StringList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__Name:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__NetworkInterfaceConfigPriority:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__IPv4Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__IPv6Address:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__HwAddress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__DNSName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__Dot11SSIDType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__hexBinary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
		break;
	case SOAP_TYPE_tt__Dot11PSK:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__hexBinary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
		break;
	case SOAP_TYPE_tt__Dot11PSKPassphrase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__AuxiliaryData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IANA_IfTypes(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_tt__IANA_IfTypes);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_tt__IANA_IfTypes(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_tt__IANA_IfTypes);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IANA_IfTypes(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_tt__IANA_IfTypes(soap, tag ? tag : "tt:IANA-IfTypes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_tt__IANA_IfTypes(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IANA_IfTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *a = static_cast<float *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(float)));
	for (float *p = a; p && n--; ++p)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RetryAfter(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RetryAfter(soap, tag ? tag : "wsa5:RetryAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *a = static_cast<ULONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ULONG64)));
	for (ULONG64 *p = a; p && n--; ++p)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RelayMode[] =
{	{ (LONG64)tt__RelayMode__Monostable, "Monostable" },
	{ (LONG64)tt__RelayMode__Bistable, "Bistable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayMode2s(struct soap *soap, enum tt__RelayMode n)
{
	const char *s = soap_code_str(soap_codes_tt__RelayMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayMode(struct soap *soap, const char *tag, int id, const enum tt__RelayMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayMode), type) || soap_send(soap, soap_tt__RelayMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayMode(struct soap *soap, const char *s, enum tt__RelayMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayMode, s);
	if (map)
		*a = (enum tt__RelayMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_in_tt__RelayMode(struct soap *soap, const char *tag, enum tt__RelayMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__RelayMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__RelayMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayMode, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_new_tt__RelayMode(struct soap *soap, int n)
{
	enum tt__RelayMode *a = static_cast<enum tt__RelayMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RelayMode)));
	for (enum tt__RelayMode *p = a; p && n--; ++p)
		soap_default_tt__RelayMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayMode(struct soap *soap, const enum tt__RelayMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayMode(soap, tag ? tag : "tt:RelayMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayMode * SOAP_FMAC4 soap_get_tt__RelayMode(struct soap *soap, enum tt__RelayMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RelayIdleState[] =
{	{ (LONG64)tt__RelayIdleState__closed, "closed" },
	{ (LONG64)tt__RelayIdleState__open, "open" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayIdleState2s(struct soap *soap, enum tt__RelayIdleState n)
{
	const char *s = soap_code_str(soap_codes_tt__RelayIdleState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayIdleState(struct soap *soap, const char *tag, int id, const enum tt__RelayIdleState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayIdleState), type) || soap_send(soap, soap_tt__RelayIdleState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayIdleState(struct soap *soap, const char *s, enum tt__RelayIdleState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayIdleState, s);
	if (map)
		*a = (enum tt__RelayIdleState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayIdleState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_in_tt__RelayIdleState(struct soap *soap, const char *tag, enum tt__RelayIdleState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayIdleState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayIdleState, sizeof(enum tt__RelayIdleState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__RelayIdleState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__RelayIdleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayIdleState, SOAP_TYPE_tt__RelayIdleState, sizeof(enum tt__RelayIdleState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_new_tt__RelayIdleState(struct soap *soap, int n)
{
	enum tt__RelayIdleState *a = static_cast<enum tt__RelayIdleState *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RelayIdleState)));
	for (enum tt__RelayIdleState *p = a; p && n--; ++p)
		soap_default_tt__RelayIdleState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayIdleState(struct soap *soap, const enum tt__RelayIdleState *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayIdleState(soap, tag ? tag : "tt:RelayIdleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayIdleState * SOAP_FMAC4 soap_get_tt__RelayIdleState(struct soap *soap, enum tt__RelayIdleState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__RelayLogicalState[] =
{	{ (LONG64)tt__RelayLogicalState__active, "active" },
	{ (LONG64)tt__RelayLogicalState__inactive, "inactive" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__RelayLogicalState2s(struct soap *soap, enum tt__RelayLogicalState n)
{
	const char *s = soap_code_str(soap_codes_tt__RelayLogicalState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayLogicalState(struct soap *soap, const char *tag, int id, const enum tt__RelayLogicalState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayLogicalState), type) || soap_send(soap, soap_tt__RelayLogicalState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__RelayLogicalState(struct soap *soap, const char *s, enum tt__RelayLogicalState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__RelayLogicalState, s);
	if (map)
		*a = (enum tt__RelayLogicalState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__RelayLogicalState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_in_tt__RelayLogicalState(struct soap *soap, const char *tag, enum tt__RelayLogicalState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__RelayLogicalState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayLogicalState, sizeof(enum tt__RelayLogicalState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__RelayLogicalState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__RelayLogicalState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayLogicalState, SOAP_TYPE_tt__RelayLogicalState, sizeof(enum tt__RelayLogicalState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_new_tt__RelayLogicalState(struct soap *soap, int n)
{
	enum tt__RelayLogicalState *a = static_cast<enum tt__RelayLogicalState *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__RelayLogicalState)));
	for (enum tt__RelayLogicalState *p = a; p && n--; ++p)
		soap_default_tt__RelayLogicalState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelayLogicalState(struct soap *soap, const enum tt__RelayLogicalState *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelayLogicalState(soap, tag ? tag : "tt:RelayLogicalState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayLogicalState * SOAP_FMAC4 soap_get_tt__RelayLogicalState(struct soap *soap, enum tt__RelayLogicalState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayLogicalState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__UserLevel[] =
{	{ (LONG64)tt__UserLevel__Administrator, "Administrator" },
	{ (LONG64)tt__UserLevel__Operator, "Operator" },
	{ (LONG64)tt__UserLevel__User, "User" },
	{ (LONG64)tt__UserLevel__Anonymous, "Anonymous" },
	{ (LONG64)tt__UserLevel__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__UserLevel2s(struct soap *soap, enum tt__UserLevel n)
{
	const char *s = soap_code_str(soap_codes_tt__UserLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserLevel(struct soap *soap, const char *tag, int id, const enum tt__UserLevel *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserLevel), type) || soap_send(soap, soap_tt__UserLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__UserLevel(struct soap *soap, const char *s, enum tt__UserLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__UserLevel, s);
	if (map)
		*a = (enum tt__UserLevel)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__UserLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_in_tt__UserLevel(struct soap *soap, const char *tag, enum tt__UserLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__UserLevel*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserLevel, sizeof(enum tt__UserLevel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__UserLevel(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__UserLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserLevel, SOAP_TYPE_tt__UserLevel, sizeof(enum tt__UserLevel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_new_tt__UserLevel(struct soap *soap, int n)
{
	enum tt__UserLevel *a = static_cast<enum tt__UserLevel *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__UserLevel)));
	for (enum tt__UserLevel *p = a; p && n--; ++p)
		soap_default_tt__UserLevel(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__UserLevel(struct soap *soap, const enum tt__UserLevel *a, const char *tag, const char *type)
{
	if (soap_out_tt__UserLevel(soap, tag ? tag : "tt:UserLevel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__UserLevel * SOAP_FMAC4 soap_get_tt__UserLevel(struct soap *soap, enum tt__UserLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SetDateTimeType[] =
{	{ (LONG64)tt__SetDateTimeType__Manual, "Manual" },
	{ (LONG64)tt__SetDateTimeType__NTP, "NTP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SetDateTimeType2s(struct soap *soap, enum tt__SetDateTimeType n)
{
	const char *s = soap_code_str(soap_codes_tt__SetDateTimeType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SetDateTimeType(struct soap *soap, const char *tag, int id, const enum tt__SetDateTimeType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SetDateTimeType), type) || soap_send(soap, soap_tt__SetDateTimeType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SetDateTimeType(struct soap *soap, const char *s, enum tt__SetDateTimeType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SetDateTimeType, s);
	if (map)
		*a = (enum tt__SetDateTimeType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SetDateTimeType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_in_tt__SetDateTimeType(struct soap *soap, const char *tag, enum tt__SetDateTimeType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SetDateTimeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SetDateTimeType, sizeof(enum tt__SetDateTimeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__SetDateTimeType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__SetDateTimeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SetDateTimeType, SOAP_TYPE_tt__SetDateTimeType, sizeof(enum tt__SetDateTimeType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_new_tt__SetDateTimeType(struct soap *soap, int n)
{
	enum tt__SetDateTimeType *a = static_cast<enum tt__SetDateTimeType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SetDateTimeType)));
	for (enum tt__SetDateTimeType *p = a; p && n--; ++p)
		soap_default_tt__SetDateTimeType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SetDateTimeType(struct soap *soap, const enum tt__SetDateTimeType *a, const char *tag, const char *type)
{
	if (soap_out_tt__SetDateTimeType(soap, tag ? tag : "tt:SetDateTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SetDateTimeType * SOAP_FMAC4 soap_get_tt__SetDateTimeType(struct soap *soap, enum tt__SetDateTimeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SetDateTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__FactoryDefaultType[] =
{	{ (LONG64)tt__FactoryDefaultType__Hard, "Hard" },
	{ (LONG64)tt__FactoryDefaultType__Soft, "Soft" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__FactoryDefaultType2s(struct soap *soap, enum tt__FactoryDefaultType n)
{
	const char *s = soap_code_str(soap_codes_tt__FactoryDefaultType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FactoryDefaultType(struct soap *soap, const char *tag, int id, const enum tt__FactoryDefaultType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FactoryDefaultType), type) || soap_send(soap, soap_tt__FactoryDefaultType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__FactoryDefaultType(struct soap *soap, const char *s, enum tt__FactoryDefaultType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__FactoryDefaultType, s);
	if (map)
		*a = (enum tt__FactoryDefaultType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__FactoryDefaultType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_in_tt__FactoryDefaultType(struct soap *soap, const char *tag, enum tt__FactoryDefaultType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__FactoryDefaultType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FactoryDefaultType, sizeof(enum tt__FactoryDefaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__FactoryDefaultType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__FactoryDefaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FactoryDefaultType, SOAP_TYPE_tt__FactoryDefaultType, sizeof(enum tt__FactoryDefaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_new_tt__FactoryDefaultType(struct soap *soap, int n)
{
	enum tt__FactoryDefaultType *a = static_cast<enum tt__FactoryDefaultType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__FactoryDefaultType)));
	for (enum tt__FactoryDefaultType *p = a; p && n--; ++p)
		soap_default_tt__FactoryDefaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FactoryDefaultType(struct soap *soap, const enum tt__FactoryDefaultType *a, const char *tag, const char *type)
{
	if (soap_out_tt__FactoryDefaultType(soap, tag ? tag : "tt:FactoryDefaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__FactoryDefaultType * SOAP_FMAC4 soap_get_tt__FactoryDefaultType(struct soap *soap, enum tt__FactoryDefaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FactoryDefaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__SystemLogType[] =
{	{ (LONG64)tt__SystemLogType__System, "System" },
	{ (LONG64)tt__SystemLogType__Access, "Access" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__SystemLogType2s(struct soap *soap, enum tt__SystemLogType n)
{
	const char *s = soap_code_str(soap_codes_tt__SystemLogType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogType(struct soap *soap, const char *tag, int id, const enum tt__SystemLogType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogType), type) || soap_send(soap, soap_tt__SystemLogType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__SystemLogType(struct soap *soap, const char *s, enum tt__SystemLogType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__SystemLogType, s);
	if (map)
		*a = (enum tt__SystemLogType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__SystemLogType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_in_tt__SystemLogType(struct soap *soap, const char *tag, enum tt__SystemLogType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__SystemLogType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogType, sizeof(enum tt__SystemLogType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__SystemLogType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__SystemLogType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogType, SOAP_TYPE_tt__SystemLogType, sizeof(enum tt__SystemLogType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_new_tt__SystemLogType(struct soap *soap, int n)
{
	enum tt__SystemLogType *a = static_cast<enum tt__SystemLogType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__SystemLogType)));
	for (enum tt__SystemLogType *p = a; p && n--; ++p)
		soap_default_tt__SystemLogType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLogType(struct soap *soap, const enum tt__SystemLogType *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemLogType(soap, tag ? tag : "tt:SystemLogType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__SystemLogType * SOAP_FMAC4 soap_get_tt__SystemLogType(struct soap *soap, enum tt__SystemLogType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__CapabilityCategory[] =
{	{ (LONG64)tt__CapabilityCategory__All, "All" },
	{ (LONG64)tt__CapabilityCategory__Analytics, "Analytics" },
	{ (LONG64)tt__CapabilityCategory__Device, "Device" },
	{ (LONG64)tt__CapabilityCategory__Events, "Events" },
	{ (LONG64)tt__CapabilityCategory__Imaging, "Imaging" },
	{ (LONG64)tt__CapabilityCategory__Media, "Media" },
	{ (LONG64)tt__CapabilityCategory__PTZ, "PTZ" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__CapabilityCategory2s(struct soap *soap, enum tt__CapabilityCategory n)
{
	const char *s = soap_code_str(soap_codes_tt__CapabilityCategory, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilityCategory(struct soap *soap, const char *tag, int id, const enum tt__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilityCategory), type) || soap_send(soap, soap_tt__CapabilityCategory2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__CapabilityCategory(struct soap *soap, const char *s, enum tt__CapabilityCategory *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__CapabilityCategory, s);
	if (map)
		*a = (enum tt__CapabilityCategory)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 6)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__CapabilityCategory)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_in_tt__CapabilityCategory(struct soap *soap, const char *tag, enum tt__CapabilityCategory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__CapabilityCategory*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__CapabilityCategory(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__CapabilityCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilityCategory, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_new_tt__CapabilityCategory(struct soap *soap, int n)
{
	enum tt__CapabilityCategory *a = static_cast<enum tt__CapabilityCategory *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__CapabilityCategory)));
	for (enum tt__CapabilityCategory *p = a; p && n--; ++p)
		soap_default_tt__CapabilityCategory(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilityCategory(struct soap *soap, const enum tt__CapabilityCategory *a, const char *tag, const char *type)
{
	if (soap_out_tt__CapabilityCategory(soap, tag ? tag : "tt:CapabilityCategory", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__CapabilityCategory * SOAP_FMAC4 soap_get_tt__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11AuthAndMangementSuite[] =
{	{ (LONG64)tt__Dot11AuthAndMangementSuite__None, "None" },
	{ (LONG64)tt__Dot11AuthAndMangementSuite__Dot1X, "Dot1X" },
	{ (LONG64)tt__Dot11AuthAndMangementSuite__PSK, "PSK" },
	{ (LONG64)tt__Dot11AuthAndMangementSuite__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11AuthAndMangementSuite2s(struct soap *soap, enum tt__Dot11AuthAndMangementSuite n)
{
	const char *s = soap_code_str(soap_codes_tt__Dot11AuthAndMangementSuite, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, int id, const enum tt__Dot11AuthAndMangementSuite *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite), type) || soap_send(soap, soap_tt__Dot11AuthAndMangementSuite2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11AuthAndMangementSuite(struct soap *soap, const char *s, enum tt__Dot11AuthAndMangementSuite *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11AuthAndMangementSuite, s);
	if (map)
		*a = (enum tt__Dot11AuthAndMangementSuite)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11AuthAndMangementSuite)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite * SOAP_FMAC4 soap_in_tt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, enum tt__Dot11AuthAndMangementSuite *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11AuthAndMangementSuite*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Dot11AuthAndMangementSuite(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Dot11AuthAndMangementSuite *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite * SOAP_FMAC4 soap_new_tt__Dot11AuthAndMangementSuite(struct soap *soap, int n)
{
	enum tt__Dot11AuthAndMangementSuite *a = static_cast<enum tt__Dot11AuthAndMangementSuite *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11AuthAndMangementSuite)));
	for (enum tt__Dot11AuthAndMangementSuite *p = a; p && n--; ++p)
		soap_default_tt__Dot11AuthAndMangementSuite(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11AuthAndMangementSuite(struct soap *soap, const enum tt__Dot11AuthAndMangementSuite *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11AuthAndMangementSuite(soap, tag ? tag : "tt:Dot11AuthAndMangementSuite", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite * SOAP_FMAC4 soap_get_tt__Dot11AuthAndMangementSuite(struct soap *soap, enum tt__Dot11AuthAndMangementSuite *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11SignalStrength[] =
{	{ (LONG64)tt__Dot11SignalStrength__None, "None" },
	{ (LONG64)tt__Dot11SignalStrength__Very_x0020Bad, "Very Bad" },
	{ (LONG64)tt__Dot11SignalStrength__Bad, "Bad" },
	{ (LONG64)tt__Dot11SignalStrength__Good, "Good" },
	{ (LONG64)tt__Dot11SignalStrength__Very_x0020Good, "Very Good" },
	{ (LONG64)tt__Dot11SignalStrength__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SignalStrength2s(struct soap *soap, enum tt__Dot11SignalStrength n)
{
	const char *s = soap_code_str(soap_codes_tt__Dot11SignalStrength, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SignalStrength(struct soap *soap, const char *tag, int id, const enum tt__Dot11SignalStrength *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SignalStrength), type) || soap_send(soap, soap_tt__Dot11SignalStrength2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SignalStrength(struct soap *soap, const char *s, enum tt__Dot11SignalStrength *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11SignalStrength, s);
	if (map)
		*a = (enum tt__Dot11SignalStrength)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 5)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11SignalStrength)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11SignalStrength * SOAP_FMAC4 soap_in_tt__Dot11SignalStrength(struct soap *soap, const char *tag, enum tt__Dot11SignalStrength *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11SignalStrength*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Dot11SignalStrength(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Dot11SignalStrength *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SignalStrength, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11SignalStrength * SOAP_FMAC4 soap_new_tt__Dot11SignalStrength(struct soap *soap, int n)
{
	enum tt__Dot11SignalStrength *a = static_cast<enum tt__Dot11SignalStrength *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11SignalStrength)));
	for (enum tt__Dot11SignalStrength *p = a; p && n--; ++p)
		soap_default_tt__Dot11SignalStrength(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SignalStrength(struct soap *soap, const enum tt__Dot11SignalStrength *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SignalStrength(soap, tag ? tag : "tt:Dot11SignalStrength", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11SignalStrength * SOAP_FMAC4 soap_get_tt__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SignalStrength(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11Cipher[] =
{	{ (LONG64)tt__Dot11Cipher__CCMP, "CCMP" },
	{ (LONG64)tt__Dot11Cipher__TKIP, "TKIP" },
	{ (LONG64)tt__Dot11Cipher__Any, "Any" },
	{ (LONG64)tt__Dot11Cipher__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11Cipher2s(struct soap *soap, enum tt__Dot11Cipher n)
{
	const char *s = soap_code_str(soap_codes_tt__Dot11Cipher, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Cipher(struct soap *soap, const char *tag, int id, const enum tt__Dot11Cipher *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Cipher), type) || soap_send(soap, soap_tt__Dot11Cipher2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11Cipher(struct soap *soap, const char *s, enum tt__Dot11Cipher *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11Cipher, s);
	if (map)
		*a = (enum tt__Dot11Cipher)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11Cipher)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_in_tt__Dot11Cipher(struct soap *soap, const char *tag, enum tt__Dot11Cipher *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11Cipher*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Dot11Cipher(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Dot11Cipher *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Cipher, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_new_tt__Dot11Cipher(struct soap *soap, int n)
{
	enum tt__Dot11Cipher *a = static_cast<enum tt__Dot11Cipher *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11Cipher)));
	for (enum tt__Dot11Cipher *p = a; p && n--; ++p)
		soap_default_tt__Dot11Cipher(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11Cipher(struct soap *soap, const enum tt__Dot11Cipher *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11Cipher(soap, tag ? tag : "tt:Dot11Cipher", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11Cipher * SOAP_FMAC4 soap_get_tt__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Cipher(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11SecurityMode[] =
{	{ (LONG64)tt__Dot11SecurityMode__None, "None" },
	{ (LONG64)tt__Dot11SecurityMode__WEP, "WEP" },
	{ (LONG64)tt__Dot11SecurityMode__PSK, "PSK" },
	{ (LONG64)tt__Dot11SecurityMode__Dot1X, "Dot1X" },
	{ (LONG64)tt__Dot11SecurityMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SecurityMode2s(struct soap *soap, enum tt__Dot11SecurityMode n)
{
	const char *s = soap_code_str(soap_codes_tt__Dot11SecurityMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityMode(struct soap *soap, const char *tag, int id, const enum tt__Dot11SecurityMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityMode), type) || soap_send(soap, soap_tt__Dot11SecurityMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SecurityMode(struct soap *soap, const char *s, enum tt__Dot11SecurityMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11SecurityMode, s);
	if (map)
		*a = (enum tt__Dot11SecurityMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11SecurityMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_in_tt__Dot11SecurityMode(struct soap *soap, const char *tag, enum tt__Dot11SecurityMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11SecurityMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityMode, sizeof(enum tt__Dot11SecurityMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Dot11SecurityMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Dot11SecurityMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityMode, SOAP_TYPE_tt__Dot11SecurityMode, sizeof(enum tt__Dot11SecurityMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_new_tt__Dot11SecurityMode(struct soap *soap, int n)
{
	enum tt__Dot11SecurityMode *a = static_cast<enum tt__Dot11SecurityMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11SecurityMode)));
	for (enum tt__Dot11SecurityMode *p = a; p && n--; ++p)
		soap_default_tt__Dot11SecurityMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SecurityMode(struct soap *soap, const enum tt__Dot11SecurityMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SecurityMode(soap, tag ? tag : "tt:Dot11SecurityMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11SecurityMode * SOAP_FMAC4 soap_get_tt__Dot11SecurityMode(struct soap *soap, enum tt__Dot11SecurityMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Dot11StationMode[] =
{	{ (LONG64)tt__Dot11StationMode__Ad_hoc, "Ad-hoc" },
	{ (LONG64)tt__Dot11StationMode__Infrastructure, "Infrastructure" },
	{ (LONG64)tt__Dot11StationMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11StationMode2s(struct soap *soap, enum tt__Dot11StationMode n)
{
	const char *s = soap_code_str(soap_codes_tt__Dot11StationMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11StationMode(struct soap *soap, const char *tag, int id, const enum tt__Dot11StationMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11StationMode), type) || soap_send(soap, soap_tt__Dot11StationMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11StationMode(struct soap *soap, const char *s, enum tt__Dot11StationMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Dot11StationMode, s);
	if (map)
		*a = (enum tt__Dot11StationMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Dot11StationMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_in_tt__Dot11StationMode(struct soap *soap, const char *tag, enum tt__Dot11StationMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Dot11StationMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11StationMode, sizeof(enum tt__Dot11StationMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Dot11StationMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Dot11StationMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11StationMode, SOAP_TYPE_tt__Dot11StationMode, sizeof(enum tt__Dot11StationMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_new_tt__Dot11StationMode(struct soap *soap, int n)
{
	enum tt__Dot11StationMode *a = static_cast<enum tt__Dot11StationMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Dot11StationMode)));
	for (enum tt__Dot11StationMode *p = a; p && n--; ++p)
		soap_default_tt__Dot11StationMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11StationMode(struct soap *soap, const enum tt__Dot11StationMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11StationMode(soap, tag ? tag : "tt:Dot11StationMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11StationMode * SOAP_FMAC4 soap_get_tt__Dot11StationMode(struct soap *soap, enum tt__Dot11StationMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11StationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__DynamicDNSType[] =
{	{ (LONG64)tt__DynamicDNSType__NoUpdate, "NoUpdate" },
	{ (LONG64)tt__DynamicDNSType__ClientUpdates, "ClientUpdates" },
	{ (LONG64)tt__DynamicDNSType__ServerUpdates, "ServerUpdates" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DynamicDNSType2s(struct soap *soap, enum tt__DynamicDNSType n)
{
	const char *s = soap_code_str(soap_codes_tt__DynamicDNSType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSType(struct soap *soap, const char *tag, int id, const enum tt__DynamicDNSType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSType), type) || soap_send(soap, soap_tt__DynamicDNSType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DynamicDNSType(struct soap *soap, const char *s, enum tt__DynamicDNSType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DynamicDNSType, s);
	if (map)
		*a = (enum tt__DynamicDNSType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DynamicDNSType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_in_tt__DynamicDNSType(struct soap *soap, const char *tag, enum tt__DynamicDNSType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DynamicDNSType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSType, sizeof(enum tt__DynamicDNSType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__DynamicDNSType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__DynamicDNSType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSType, SOAP_TYPE_tt__DynamicDNSType, sizeof(enum tt__DynamicDNSType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_new_tt__DynamicDNSType(struct soap *soap, int n)
{
	enum tt__DynamicDNSType *a = static_cast<enum tt__DynamicDNSType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__DynamicDNSType)));
	for (enum tt__DynamicDNSType *p = a; p && n--; ++p)
		soap_default_tt__DynamicDNSType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DynamicDNSType(struct soap *soap, const enum tt__DynamicDNSType *a, const char *tag, const char *type)
{
	if (soap_out_tt__DynamicDNSType(soap, tag ? tag : "tt:DynamicDNSType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DynamicDNSType * SOAP_FMAC4 soap_get_tt__DynamicDNSType(struct soap *soap, enum tt__DynamicDNSType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPAddressFilterType[] =
{	{ (LONG64)tt__IPAddressFilterType__Allow, "Allow" },
	{ (LONG64)tt__IPAddressFilterType__Deny, "Deny" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPAddressFilterType2s(struct soap *soap, enum tt__IPAddressFilterType n)
{
	const char *s = soap_code_str(soap_codes_tt__IPAddressFilterType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterType(struct soap *soap, const char *tag, int id, const enum tt__IPAddressFilterType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterType), type) || soap_send(soap, soap_tt__IPAddressFilterType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPAddressFilterType(struct soap *soap, const char *s, enum tt__IPAddressFilterType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPAddressFilterType, s);
	if (map)
		*a = (enum tt__IPAddressFilterType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPAddressFilterType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_in_tt__IPAddressFilterType(struct soap *soap, const char *tag, enum tt__IPAddressFilterType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPAddressFilterType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterType, sizeof(enum tt__IPAddressFilterType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IPAddressFilterType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IPAddressFilterType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterType, SOAP_TYPE_tt__IPAddressFilterType, sizeof(enum tt__IPAddressFilterType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_new_tt__IPAddressFilterType(struct soap *soap, int n)
{
	enum tt__IPAddressFilterType *a = static_cast<enum tt__IPAddressFilterType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPAddressFilterType)));
	for (enum tt__IPAddressFilterType *p = a; p && n--; ++p)
		soap_default_tt__IPAddressFilterType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPAddressFilterType(struct soap *soap, const enum tt__IPAddressFilterType *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPAddressFilterType(soap, tag ? tag : "tt:IPAddressFilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPAddressFilterType * SOAP_FMAC4 soap_get_tt__IPAddressFilterType(struct soap *soap, enum tt__IPAddressFilterType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPType[] =
{	{ (LONG64)tt__IPType__IPv4, "IPv4" },
	{ (LONG64)tt__IPType__IPv6, "IPv6" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPType2s(struct soap *soap, enum tt__IPType n)
{
	const char *s = soap_code_str(soap_codes_tt__IPType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPType(struct soap *soap, const char *tag, int id, const enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPType), type) || soap_send(soap, soap_tt__IPType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPType(struct soap *soap, const char *s, enum tt__IPType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPType, s);
	if (map)
		*a = (enum tt__IPType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_in_tt__IPType(struct soap *soap, const char *tag, enum tt__IPType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IPType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IPType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPType, SOAP_TYPE_tt__IPType, sizeof(enum tt__IPType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_new_tt__IPType(struct soap *soap, int n)
{
	enum tt__IPType *a = static_cast<enum tt__IPType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPType)));
	for (enum tt__IPType *p = a; p && n--; ++p)
		soap_default_tt__IPType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPType(struct soap *soap, const enum tt__IPType *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPType(soap, tag ? tag : "tt:IPType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPType * SOAP_FMAC4 soap_get_tt__IPType(struct soap *soap, enum tt__IPType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__NetworkHostType[] =
{	{ (LONG64)tt__NetworkHostType__IPv4, "IPv4" },
	{ (LONG64)tt__NetworkHostType__IPv6, "IPv6" },
	{ (LONG64)tt__NetworkHostType__DNS, "DNS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__NetworkHostType2s(struct soap *soap, enum tt__NetworkHostType n)
{
	const char *s = soap_code_str(soap_codes_tt__NetworkHostType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostType(struct soap *soap, const char *tag, int id, const enum tt__NetworkHostType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostType), type) || soap_send(soap, soap_tt__NetworkHostType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__NetworkHostType(struct soap *soap, const char *s, enum tt__NetworkHostType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__NetworkHostType, s);
	if (map)
		*a = (enum tt__NetworkHostType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__NetworkHostType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_in_tt__NetworkHostType(struct soap *soap, const char *tag, enum tt__NetworkHostType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__NetworkHostType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostType, sizeof(enum tt__NetworkHostType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__NetworkHostType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__NetworkHostType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostType, SOAP_TYPE_tt__NetworkHostType, sizeof(enum tt__NetworkHostType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_new_tt__NetworkHostType(struct soap *soap, int n)
{
	enum tt__NetworkHostType *a = static_cast<enum tt__NetworkHostType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__NetworkHostType)));
	for (enum tt__NetworkHostType *p = a; p && n--; ++p)
		soap_default_tt__NetworkHostType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkHostType(struct soap *soap, const enum tt__NetworkHostType *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkHostType(soap, tag ? tag : "tt:NetworkHostType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__NetworkHostType * SOAP_FMAC4 soap_get_tt__NetworkHostType(struct soap *soap, enum tt__NetworkHostType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__NetworkProtocolType[] =
{	{ (LONG64)tt__NetworkProtocolType__HTTP, "HTTP" },
	{ (LONG64)tt__NetworkProtocolType__HTTPS, "HTTPS" },
	{ (LONG64)tt__NetworkProtocolType__RTSP, "RTSP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__NetworkProtocolType2s(struct soap *soap, enum tt__NetworkProtocolType n)
{
	const char *s = soap_code_str(soap_codes_tt__NetworkProtocolType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolType(struct soap *soap, const char *tag, int id, const enum tt__NetworkProtocolType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolType), type) || soap_send(soap, soap_tt__NetworkProtocolType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__NetworkProtocolType(struct soap *soap, const char *s, enum tt__NetworkProtocolType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__NetworkProtocolType, s);
	if (map)
		*a = (enum tt__NetworkProtocolType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__NetworkProtocolType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_in_tt__NetworkProtocolType(struct soap *soap, const char *tag, enum tt__NetworkProtocolType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__NetworkProtocolType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolType, sizeof(enum tt__NetworkProtocolType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__NetworkProtocolType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__NetworkProtocolType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolType, SOAP_TYPE_tt__NetworkProtocolType, sizeof(enum tt__NetworkProtocolType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_new_tt__NetworkProtocolType(struct soap *soap, int n)
{
	enum tt__NetworkProtocolType *a = static_cast<enum tt__NetworkProtocolType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__NetworkProtocolType)));
	for (enum tt__NetworkProtocolType *p = a; p && n--; ++p)
		soap_default_tt__NetworkProtocolType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkProtocolType(struct soap *soap, const enum tt__NetworkProtocolType *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkProtocolType(soap, tag ? tag : "tt:NetworkProtocolType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__NetworkProtocolType * SOAP_FMAC4 soap_get_tt__NetworkProtocolType(struct soap *soap, enum tt__NetworkProtocolType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__IPv6DHCPConfiguration[] =
{	{ (LONG64)tt__IPv6DHCPConfiguration__Auto, "Auto" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Stateful, "Stateful" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Stateless, "Stateless" },
	{ (LONG64)tt__IPv6DHCPConfiguration__Off, "Off" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__IPv6DHCPConfiguration2s(struct soap *soap, enum tt__IPv6DHCPConfiguration n)
{
	const char *s = soap_code_str(soap_codes_tt__IPv6DHCPConfiguration, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, const enum tt__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration), type) || soap_send(soap, soap_tt__IPv6DHCPConfiguration2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__IPv6DHCPConfiguration(struct soap *soap, const char *s, enum tt__IPv6DHCPConfiguration *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__IPv6DHCPConfiguration, s);
	if (map)
		*a = (enum tt__IPv6DHCPConfiguration)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__IPv6DHCPConfiguration)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_in_tt__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__IPv6DHCPConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__IPv6DHCPConfiguration(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__IPv6DHCPConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6DHCPConfiguration, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_new_tt__IPv6DHCPConfiguration(struct soap *soap, int n)
{
	enum tt__IPv6DHCPConfiguration *a = static_cast<enum tt__IPv6DHCPConfiguration *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__IPv6DHCPConfiguration)));
	for (enum tt__IPv6DHCPConfiguration *p = a; p && n--; ++p)
		soap_default_tt__IPv6DHCPConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6DHCPConfiguration(struct soap *soap, const enum tt__IPv6DHCPConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__IPv6DHCPConfiguration(soap, tag ? tag : "tt:IPv6DHCPConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration * SOAP_FMAC4 soap_get_tt__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__Duplex[] =
{	{ (LONG64)tt__Duplex__Full, "Full" },
	{ (LONG64)tt__Duplex__Half, "Half" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Duplex2s(struct soap *soap, enum tt__Duplex n)
{
	const char *s = soap_code_str(soap_codes_tt__Duplex, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Duplex(struct soap *soap, const char *tag, int id, const enum tt__Duplex *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Duplex), type) || soap_send(soap, soap_tt__Duplex2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Duplex(struct soap *soap, const char *s, enum tt__Duplex *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__Duplex, s);
	if (map)
		*a = (enum tt__Duplex)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__Duplex)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_in_tt__Duplex(struct soap *soap, const char *tag, enum tt__Duplex *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__Duplex*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__Duplex(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__Duplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Duplex, SOAP_TYPE_tt__Duplex, sizeof(enum tt__Duplex), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_new_tt__Duplex(struct soap *soap, int n)
{
	enum tt__Duplex *a = static_cast<enum tt__Duplex *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__Duplex)));
	for (enum tt__Duplex *p = a; p && n--; ++p)
		soap_default_tt__Duplex(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Duplex(struct soap *soap, const enum tt__Duplex *a, const char *tag, const char *type)
{
	if (soap_out_tt__Duplex(soap, tag ? tag : "tt:Duplex", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Duplex * SOAP_FMAC4 soap_get_tt__Duplex(struct soap *soap, enum tt__Duplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Duplex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__DiscoveryMode[] =
{	{ (LONG64)tt__DiscoveryMode__Discoverable, "Discoverable" },
	{ (LONG64)tt__DiscoveryMode__NonDiscoverable, "NonDiscoverable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__DiscoveryMode2s(struct soap *soap, enum tt__DiscoveryMode n)
{
	const char *s = soap_code_str(soap_codes_tt__DiscoveryMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DiscoveryMode(struct soap *soap, const char *tag, int id, const enum tt__DiscoveryMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DiscoveryMode), type) || soap_send(soap, soap_tt__DiscoveryMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__DiscoveryMode(struct soap *soap, const char *s, enum tt__DiscoveryMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__DiscoveryMode, s);
	if (map)
		*a = (enum tt__DiscoveryMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__DiscoveryMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_in_tt__DiscoveryMode(struct soap *soap, const char *tag, enum tt__DiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__DiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__DiscoveryMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__DiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DiscoveryMode, SOAP_TYPE_tt__DiscoveryMode, sizeof(enum tt__DiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_new_tt__DiscoveryMode(struct soap *soap, int n)
{
	enum tt__DiscoveryMode *a = static_cast<enum tt__DiscoveryMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__DiscoveryMode)));
	for (enum tt__DiscoveryMode *p = a; p && n--; ++p)
		soap_default_tt__DiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DiscoveryMode(struct soap *soap, const enum tt__DiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__DiscoveryMode(soap, tag ? tag : "tt:DiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DiscoveryMode * SOAP_FMAC4 soap_get_tt__DiscoveryMode(struct soap *soap, enum tt__DiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ScopeDefinition[] =
{	{ (LONG64)tt__ScopeDefinition__Fixed, "Fixed" },
	{ (LONG64)tt__ScopeDefinition__Configurable, "Configurable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ScopeDefinition2s(struct soap *soap, enum tt__ScopeDefinition n)
{
	const char *s = soap_code_str(soap_codes_tt__ScopeDefinition, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ScopeDefinition(struct soap *soap, const char *tag, int id, const enum tt__ScopeDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ScopeDefinition), type) || soap_send(soap, soap_tt__ScopeDefinition2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ScopeDefinition(struct soap *soap, const char *s, enum tt__ScopeDefinition *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ScopeDefinition, s);
	if (map)
		*a = (enum tt__ScopeDefinition)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ScopeDefinition)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_in_tt__ScopeDefinition(struct soap *soap, const char *tag, enum tt__ScopeDefinition *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ScopeDefinition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ScopeDefinition(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ScopeDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ScopeDefinition, SOAP_TYPE_tt__ScopeDefinition, sizeof(enum tt__ScopeDefinition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_new_tt__ScopeDefinition(struct soap *soap, int n)
{
	enum tt__ScopeDefinition *a = static_cast<enum tt__ScopeDefinition *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ScopeDefinition)));
	for (enum tt__ScopeDefinition *p = a; p && n--; ++p)
		soap_default_tt__ScopeDefinition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ScopeDefinition(struct soap *soap, const enum tt__ScopeDefinition *a, const char *tag, const char *type)
{
	if (soap_out_tt__ScopeDefinition(soap, tag ? tag : "tt:ScopeDefinition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ScopeDefinition * SOAP_FMAC4 soap_get_tt__ScopeDefinition(struct soap *soap, enum tt__ScopeDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ScopeDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{
	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *a = static_cast<enum _wsa5__IsReferenceParameter *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter)));
	for (enum _wsa5__IsReferenceParameter *p = a; p && n--; ++p)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (LONG64)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (LONG64)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (LONG64)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (LONG64)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (LONG64)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (LONG64)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (LONG64)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (LONG64)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (LONG64)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (LONG64)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (LONG64)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n)
{
	enum wsa5__FaultCodesType *a = static_cast<enum wsa5__FaultCodesType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__FaultCodesType)));
	for (enum wsa5__FaultCodesType *p = a; p && n--; ++p)
		soap_default_wsa5__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesType(soap, tag ? tag : "wsa5:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (LONG64)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n)
{
	enum wsa5__RelationshipType *a = static_cast<enum wsa5__RelationshipType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__RelationshipType)));
	for (enum wsa5__RelationshipType *p = a; p && n--; ++p)
		soap_default_wsa5__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipType(soap, tag ? tag : "wsa5:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemUrisResponse_Extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void _tds__GetSystemUrisResponse_Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemUrisResponse_Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemUrisResponse_Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, const _tds__GetSystemUrisResponse_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemUrisResponse_Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemUrisResponse_Extension(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, _tds__GetSystemUrisResponse_Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemUrisResponse_Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(_tds__GetSystemUrisResponse_Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemUrisResponse_Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemUrisResponse_Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemUrisResponse_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(_tds__GetSystemUrisResponse_Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemUrisResponse_Extension * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse_Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemUrisResponse_Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemUrisResponse_Extension *p;
	size_t k = sizeof(_tds__GetSystemUrisResponse_Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemUrisResponse_Extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemUrisResponse_Extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemUrisResponse_Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemUrisResponse_Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemUrisResponse_Extension(soap, tag ? tag : "tds:GetSystemUrisResponse-Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemUrisResponse_Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemUrisResponse_Extension(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse_Extension(struct soap *soap, _tds__GetSystemUrisResponse_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StorageConfigurationData_Extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void _tds__StorageConfigurationData_Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__StorageConfigurationData_Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StorageConfigurationData_Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, int id, const _tds__StorageConfigurationData_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StorageConfigurationData_Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StorageConfigurationData_Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StorageConfigurationData_Extension(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StorageConfigurationData_Extension * SOAP_FMAC4 soap_in__tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, _tds__StorageConfigurationData_Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StorageConfigurationData_Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(_tds__StorageConfigurationData_Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StorageConfigurationData_Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StorageConfigurationData_Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StorageConfigurationData_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StorageConfigurationData_Extension, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(_tds__StorageConfigurationData_Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StorageConfigurationData_Extension * SOAP_FMAC2 soap_instantiate__tds__StorageConfigurationData_Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StorageConfigurationData_Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StorageConfigurationData_Extension *p;
	size_t k = sizeof(_tds__StorageConfigurationData_Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StorageConfigurationData_Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StorageConfigurationData_Extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StorageConfigurationData_Extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StorageConfigurationData_Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StorageConfigurationData_Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StorageConfigurationData_Extension(soap, tag ? tag : "tds:StorageConfigurationData-Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StorageConfigurationData_Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StorageConfigurationData_Extension(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StorageConfigurationData_Extension * SOAP_FMAC4 soap_get__tds__StorageConfigurationData_Extension(struct soap *soap, _tds__StorageConfigurationData_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StorageConfigurationData_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__UserCredential_Extension::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void _tds__UserCredential_Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__UserCredential_Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__UserCredential_Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UserCredential_Extension(struct soap *soap, const char *tag, int id, const _tds__UserCredential_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UserCredential_Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__UserCredential_Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__UserCredential_Extension(soap, tag, this, type);
}

SOAP_FMAC3 _tds__UserCredential_Extension * SOAP_FMAC4 soap_in__tds__UserCredential_Extension(struct soap *soap, const char *tag, _tds__UserCredential_Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__UserCredential_Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UserCredential_Extension, sizeof(_tds__UserCredential_Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__UserCredential_Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__UserCredential_Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__UserCredential_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UserCredential_Extension, SOAP_TYPE__tds__UserCredential_Extension, sizeof(_tds__UserCredential_Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__UserCredential_Extension * SOAP_FMAC2 soap_instantiate__tds__UserCredential_Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__UserCredential_Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__UserCredential_Extension *p;
	size_t k = sizeof(_tds__UserCredential_Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__UserCredential_Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__UserCredential_Extension);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__UserCredential_Extension, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__UserCredential_Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__UserCredential_Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__UserCredential_Extension(soap, tag ? tag : "tds:UserCredential-Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__UserCredential_Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__UserCredential_Extension(soap, this, tag, type);
}

SOAP_FMAC3 _tds__UserCredential_Extension * SOAP_FMAC4 soap_get__tds__UserCredential_Extension(struct soap *soap, _tds__UserCredential_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UserCredential_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__Service_Capabilities::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
}

void _tds__Service_Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__Service_Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__Service_Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__Service_Capabilities(struct soap *soap, const char *tag, int id, const _tds__Service_Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__Service_Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__Service_Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__Service_Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__Service_Capabilities * SOAP_FMAC4 soap_in__tds__Service_Capabilities(struct soap *soap, const char *tag, _tds__Service_Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__Service_Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__Service_Capabilities, sizeof(_tds__Service_Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__Service_Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__Service_Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__Service_Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__Service_Capabilities, SOAP_TYPE__tds__Service_Capabilities, sizeof(_tds__Service_Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__Service_Capabilities * SOAP_FMAC2 soap_instantiate__tds__Service_Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__Service_Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__Service_Capabilities *p;
	size_t k = sizeof(_tds__Service_Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__Service_Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__Service_Capabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__Service_Capabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__Service_Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__Service_Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__Service_Capabilities(soap, tag ? tag : "tds:Service-Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__Service_Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__Service_Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__Service_Capabilities * SOAP_FMAC4 soap_get__tds__Service_Capabilities(struct soap *soap, _tds__Service_Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceToken(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__ReferenceToken), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 64, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__ReferenceToken, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AuxiliaryData(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AuxiliaryData(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__AuxiliaryData), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__AuxiliaryData(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 128, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__AuxiliaryData, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AuxiliaryData(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__AuxiliaryData(soap, tag ? tag : "tt:AuxiliaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__AuxiliaryData(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKPassphrase(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__Dot11PSKPassphrase), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Dot11PSKPassphrase, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, "[ -~]{8,63}")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Dot11PSKPassphrase, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__Dot11PSKPassphrase, SOAP_TYPE_tt__Dot11PSKPassphrase, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKPassphrase(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSKPassphrase(soap, tag ? tag : "tt:Dot11PSKPassphrase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__Dot11PSKPassphrase(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKPassphrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11PSK(struct soap *soap, xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSK(struct soap *soap, const xsd__hexBinary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_tt__Dot11PSK);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11PSK2s(struct soap *soap, xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSK(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_tt__Dot11PSK, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11PSK(struct soap *soap, const char *s, xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	if (a->__size < 32)
		return soap->error = SOAP_LENGTH;
	if (a->__size > 32)
		return soap->error = SOAP_LENGTH;
	return SOAP_OK;
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11PSK(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSK, sizeof(xsd__hexBinary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
		if (a->__size < 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
		if (a->__size > 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSK, SOAP_TYPE_tt__Dot11PSK, sizeof(xsd__hexBinary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSK(struct soap *soap, const xsd__hexBinary *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11PSK(soap, tag ? tag : "tt:Dot11PSK", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11PSK(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Dot11SSIDType(struct soap *soap, xsd__hexBinary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11SSIDType(struct soap *soap, const xsd__hexBinary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_array_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE_tt__Dot11SSIDType);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__Dot11SSIDType2s(struct soap *soap, xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SSIDType(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_tt__Dot11SSIDType, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__Dot11SSIDType(struct soap *soap, const char *s, xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	if (a->__size < 1)
		return soap->error = SOAP_LENGTH;
	if (a->__size > 32)
		return soap->error = SOAP_LENGTH;
	return SOAP_OK;
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_tt__Dot11SSIDType(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SSIDType, sizeof(xsd__hexBinary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
		if (a->__size < 1)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
		if (a->__size > 32)
		{	soap->error = SOAP_LENGTH;
			return NULL;
		}
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SSIDType, SOAP_TYPE_tt__Dot11SSIDType, sizeof(xsd__hexBinary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11SSIDType(struct soap *soap, const xsd__hexBinary *a, const char *tag, const char *type)
{
	if (soap_out_tt__Dot11SSIDType(soap, tag ? tag : "tt:Dot11SSIDType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_tt__Dot11SSIDType(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SSIDType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Name(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__Name), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Name, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 64, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Name, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__Name, SOAP_TYPE_tt__Name, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__Name(soap, tag ? tag : "tt:Name", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__StringList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__StringList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__StringList, SOAP_TYPE_tt__StringList, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__StringList(soap, tag ? tag : "tt:StringList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__StringList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringAttrList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringAttrList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__StringAttrList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__StringAttrList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__StringAttrList, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringAttrList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__StringAttrList(soap, tag ? tag : "tt:StringAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__StringAttrList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__IntList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__IntList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IntList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IntList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__IntList, SOAP_TYPE_tt__IntList, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntList(soap, tag ? tag : "tt:IntList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__IntList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LocationEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__LocationEntity::GeoLocation = NULL;
	this->tt__LocationEntity::GeoOrientation = NULL;
	this->tt__LocationEntity::LocalLocation = NULL;
	this->tt__LocationEntity::LocalOrientation = NULL;
	this->tt__LocationEntity::Entity = NULL;
	this->tt__LocationEntity::Token = NULL;
	this->tt__LocationEntity::Fixed = NULL;
	this->tt__LocationEntity::GeoSource = NULL;
	this->tt__LocationEntity::AutoGeo = NULL;
}

void tt__LocationEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__GeoLocation(soap, &this->tt__LocationEntity::GeoLocation);
	soap_serialize_PointerTott__GeoOrientation(soap, &this->tt__LocationEntity::GeoOrientation);
	soap_serialize_PointerTott__LocalLocation(soap, &this->tt__LocationEntity::LocalLocation);
	soap_serialize_PointerTott__LocalOrientation(soap, &this->tt__LocationEntity::LocalOrientation);
#endif
}

int tt__LocationEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LocationEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocationEntity(struct soap *soap, const char *tag, int id, const tt__LocationEntity *a, const char *type)
{
	if (((tt__LocationEntity*)a)->Entity)
	{	soap_set_attr(soap, "Entity", soap_std__string2s(soap, *((tt__LocationEntity*)a)->Entity), 1);
	}
	if (((tt__LocationEntity*)a)->Token)
	{	soap_set_attr(soap, "Token", soap_tt__ReferenceToken2s(soap, *((tt__LocationEntity*)a)->Token), 1);
	}
	if (((tt__LocationEntity*)a)->Fixed)
	{	soap_set_attr(soap, "Fixed", soap_bool2s(soap, *((tt__LocationEntity*)a)->Fixed), 1);
	}
	if (((tt__LocationEntity*)a)->GeoSource)
	{	soap_set_attr(soap, "GeoSource", soap_xsd__anyURI2s(soap, *((tt__LocationEntity*)a)->GeoSource), 1);
	}
	if (((tt__LocationEntity*)a)->AutoGeo)
	{	soap_set_attr(soap, "AutoGeo", soap_bool2s(soap, *((tt__LocationEntity*)a)->AutoGeo), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LocationEntity), type))
		return soap->error;
	if (soap_out_PointerTott__GeoLocation(soap, "tt:GeoLocation", -1, &a->tt__LocationEntity::GeoLocation, ""))
		return soap->error;
	if (soap_out_PointerTott__GeoOrientation(soap, "tt:GeoOrientation", -1, &a->tt__LocationEntity::GeoOrientation, ""))
		return soap->error;
	if (soap_out_PointerTott__LocalLocation(soap, "tt:LocalLocation", -1, &a->tt__LocationEntity::LocalLocation, ""))
		return soap->error;
	if (soap_out_PointerTott__LocalOrientation(soap, "tt:LocalOrientation", -1, &a->tt__LocationEntity::LocalOrientation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LocationEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LocationEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__LocationEntity * SOAP_FMAC4 soap_in_tt__LocationEntity(struct soap *soap, const char *tag, tt__LocationEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LocationEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocationEntity, sizeof(tt__LocationEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LocationEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LocationEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "Entity", 1, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->Entity = soap_new_std__string(soap)))
				return NULL;
			if (soap_s2std__string(soap, t, ((tt__LocationEntity*)a)->Entity))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Token", 1, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->Token = soap_new_tt__ReferenceToken(soap)))
				return NULL;
			if (soap_s2tt__ReferenceToken(soap, t, ((tt__LocationEntity*)a)->Token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Fixed", 5, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->Fixed = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__LocationEntity*)a)->Fixed))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoSource", 4, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->GeoSource = soap_new_xsd__anyURI(soap)))
				return NULL;
			if (soap_s2xsd__anyURI(soap, t, ((tt__LocationEntity*)a)->GeoSource))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AutoGeo", 5, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->AutoGeo = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__LocationEntity*)a)->AutoGeo))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_GeoLocation1 = 1;
	size_t soap_flag_GeoOrientation1 = 1;
	size_t soap_flag_LocalLocation1 = 1;
	size_t soap_flag_LocalOrientation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GeoLocation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoLocation(soap, "tt:GeoLocation", &a->tt__LocationEntity::GeoLocation, "tt:GeoLocation"))
				{	soap_flag_GeoLocation1--;
					continue;
				}
			}
			if (soap_flag_GeoOrientation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoOrientation(soap, "tt:GeoOrientation", &a->tt__LocationEntity::GeoOrientation, "tt:GeoOrientation"))
				{	soap_flag_GeoOrientation1--;
					continue;
				}
			}
			if (soap_flag_LocalLocation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LocalLocation(soap, "tt:LocalLocation", &a->tt__LocationEntity::LocalLocation, "tt:LocalLocation"))
				{	soap_flag_LocalLocation1--;
					continue;
				}
			}
			if (soap_flag_LocalOrientation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LocalOrientation(soap, "tt:LocalOrientation", &a->tt__LocationEntity::LocalOrientation, "tt:LocalOrientation"))
				{	soap_flag_LocalOrientation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__LocationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocationEntity, SOAP_TYPE_tt__LocationEntity, sizeof(tt__LocationEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LocationEntity * SOAP_FMAC2 soap_instantiate_tt__LocationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LocationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LocationEntity *p;
	size_t k = sizeof(tt__LocationEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LocationEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LocationEntity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LocationEntity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LocationEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LocationEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LocationEntity(soap, tag ? tag : "tt:LocationEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LocationEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LocationEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__LocationEntity * SOAP_FMAC4 soap_get_tt__LocationEntity(struct soap *soap, tt__LocationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LocalOrientation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__LocalOrientation::pan = NULL;
	this->tt__LocalOrientation::tilt = NULL;
	this->tt__LocalOrientation::roll = NULL;
}

void tt__LocalOrientation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__LocalOrientation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LocalOrientation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocalOrientation(struct soap *soap, const char *tag, int id, const tt__LocalOrientation *a, const char *type)
{
	if (((tt__LocalOrientation*)a)->pan)
	{	soap_set_attr(soap, "pan", soap_float2s(soap, *((tt__LocalOrientation*)a)->pan), 1);
	}
	if (((tt__LocalOrientation*)a)->tilt)
	{	soap_set_attr(soap, "tilt", soap_float2s(soap, *((tt__LocalOrientation*)a)->tilt), 1);
	}
	if (((tt__LocalOrientation*)a)->roll)
	{	soap_set_attr(soap, "roll", soap_float2s(soap, *((tt__LocalOrientation*)a)->roll), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LocalOrientation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LocalOrientation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LocalOrientation(soap, tag, this, type);
}

SOAP_FMAC3 tt__LocalOrientation * SOAP_FMAC4 soap_in_tt__LocalOrientation(struct soap *soap, const char *tag, tt__LocalOrientation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LocalOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocalOrientation, sizeof(tt__LocalOrientation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LocalOrientation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LocalOrientation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "pan", 5, 0);
		if (t)
		{
			if (!(((tt__LocalOrientation*)a)->pan = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalOrientation*)a)->pan))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "tilt", 5, 0);
		if (t)
		{
			if (!(((tt__LocalOrientation*)a)->tilt = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalOrientation*)a)->tilt))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "roll", 5, 0);
		if (t)
		{
			if (!(((tt__LocalOrientation*)a)->roll = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalOrientation*)a)->roll))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__LocalOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocalOrientation, SOAP_TYPE_tt__LocalOrientation, sizeof(tt__LocalOrientation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LocalOrientation * SOAP_FMAC2 soap_instantiate_tt__LocalOrientation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LocalOrientation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LocalOrientation *p;
	size_t k = sizeof(tt__LocalOrientation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LocalOrientation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LocalOrientation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LocalOrientation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LocalOrientation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LocalOrientation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LocalOrientation(soap, tag ? tag : "tt:LocalOrientation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LocalOrientation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LocalOrientation(soap, this, tag, type);
}

SOAP_FMAC3 tt__LocalOrientation * SOAP_FMAC4 soap_get_tt__LocalOrientation(struct soap *soap, tt__LocalOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocalOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LocalLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__LocalLocation::x = NULL;
	this->tt__LocalLocation::y = NULL;
	this->tt__LocalLocation::z = NULL;
}

void tt__LocalLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__LocalLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LocalLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocalLocation(struct soap *soap, const char *tag, int id, const tt__LocalLocation *a, const char *type)
{
	if (((tt__LocalLocation*)a)->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *((tt__LocalLocation*)a)->x), 1);
	}
	if (((tt__LocalLocation*)a)->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *((tt__LocalLocation*)a)->y), 1);
	}
	if (((tt__LocalLocation*)a)->z)
	{	soap_set_attr(soap, "z", soap_float2s(soap, *((tt__LocalLocation*)a)->z), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LocalLocation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LocalLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LocalLocation(soap, tag, this, type);
}

SOAP_FMAC3 tt__LocalLocation * SOAP_FMAC4 soap_in_tt__LocalLocation(struct soap *soap, const char *tag, tt__LocalLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LocalLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocalLocation, sizeof(tt__LocalLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LocalLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LocalLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(((tt__LocalLocation*)a)->x = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalLocation*)a)->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(((tt__LocalLocation*)a)->y = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalLocation*)a)->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "z", 5, 0);
		if (t)
		{
			if (!(((tt__LocalLocation*)a)->z = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalLocation*)a)->z))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__LocalLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocalLocation, SOAP_TYPE_tt__LocalLocation, sizeof(tt__LocalLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LocalLocation * SOAP_FMAC2 soap_instantiate_tt__LocalLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LocalLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LocalLocation *p;
	size_t k = sizeof(tt__LocalLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LocalLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LocalLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LocalLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LocalLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LocalLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LocalLocation(soap, tag ? tag : "tt:LocalLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LocalLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LocalLocation(soap, this, tag, type);
}

SOAP_FMAC3 tt__LocalLocation * SOAP_FMAC4 soap_get_tt__LocalLocation(struct soap *soap, tt__LocalLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocalLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GeoOrientation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__GeoOrientation::roll = NULL;
	this->tt__GeoOrientation::pitch = NULL;
	this->tt__GeoOrientation::yaw = NULL;
}

void tt__GeoOrientation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__GeoOrientation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GeoOrientation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GeoOrientation(struct soap *soap, const char *tag, int id, const tt__GeoOrientation *a, const char *type)
{
	if (((tt__GeoOrientation*)a)->roll)
	{	soap_set_attr(soap, "roll", soap_float2s(soap, *((tt__GeoOrientation*)a)->roll), 1);
	}
	if (((tt__GeoOrientation*)a)->pitch)
	{	soap_set_attr(soap, "pitch", soap_float2s(soap, *((tt__GeoOrientation*)a)->pitch), 1);
	}
	if (((tt__GeoOrientation*)a)->yaw)
	{	soap_set_attr(soap, "yaw", soap_float2s(soap, *((tt__GeoOrientation*)a)->yaw), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GeoOrientation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__GeoOrientation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GeoOrientation(soap, tag, this, type);
}

SOAP_FMAC3 tt__GeoOrientation * SOAP_FMAC4 soap_in_tt__GeoOrientation(struct soap *soap, const char *tag, tt__GeoOrientation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__GeoOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoOrientation, sizeof(tt__GeoOrientation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GeoOrientation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__GeoOrientation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "roll", 5, 0);
		if (t)
		{
			if (!(((tt__GeoOrientation*)a)->roll = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__GeoOrientation*)a)->roll))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "pitch", 5, 0);
		if (t)
		{
			if (!(((tt__GeoOrientation*)a)->pitch = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__GeoOrientation*)a)->pitch))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "yaw", 5, 0);
		if (t)
		{
			if (!(((tt__GeoOrientation*)a)->yaw = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__GeoOrientation*)a)->yaw))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__GeoOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GeoOrientation, SOAP_TYPE_tt__GeoOrientation, sizeof(tt__GeoOrientation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GeoOrientation * SOAP_FMAC2 soap_instantiate_tt__GeoOrientation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GeoOrientation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GeoOrientation *p;
	size_t k = sizeof(tt__GeoOrientation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GeoOrientation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GeoOrientation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GeoOrientation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GeoOrientation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GeoOrientation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GeoOrientation(soap, tag ? tag : "tt:GeoOrientation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GeoOrientation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GeoOrientation(soap, this, tag, type);
}

SOAP_FMAC3 tt__GeoOrientation * SOAP_FMAC4 soap_get_tt__GeoOrientation(struct soap *soap, tt__GeoOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GeoOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__GeoLocation::lon = NULL;
	this->tt__GeoLocation::lat = NULL;
	this->tt__GeoLocation::elevation = NULL;
}

void tt__GeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__GeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GeoLocation(struct soap *soap, const char *tag, int id, const tt__GeoLocation *a, const char *type)
{
	if (((tt__GeoLocation*)a)->lon)
	{	soap_set_attr(soap, "lon", soap_double2s(soap, *((tt__GeoLocation*)a)->lon), 1);
	}
	if (((tt__GeoLocation*)a)->lat)
	{	soap_set_attr(soap, "lat", soap_double2s(soap, *((tt__GeoLocation*)a)->lat), 1);
	}
	if (((tt__GeoLocation*)a)->elevation)
	{	soap_set_attr(soap, "elevation", soap_float2s(soap, *((tt__GeoLocation*)a)->elevation), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GeoLocation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__GeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 tt__GeoLocation * SOAP_FMAC4 soap_in_tt__GeoLocation(struct soap *soap, const char *tag, tt__GeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__GeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__GeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "lon", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->lon = (double *)soap_malloc(soap, sizeof(double))))
				return NULL;
			if (soap_s2double(soap, t, ((tt__GeoLocation*)a)->lon))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "lat", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->lat = (double *)soap_malloc(soap, sizeof(double))))
				return NULL;
			if (soap_s2double(soap, t, ((tt__GeoLocation*)a)->lat))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "elevation", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->elevation = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__GeoLocation*)a)->elevation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__GeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GeoLocation, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GeoLocation * SOAP_FMAC2 soap_instantiate_tt__GeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GeoLocation *p;
	size_t k = sizeof(tt__GeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 tt__GeoLocation * SOAP_FMAC4 soap_get_tt__GeoLocation(struct soap *soap, tt__GeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__IntRange::Min);
	soap_default_int(soap, &this->tt__IntRange::Max);
}

void tt__IntRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IntRange::Min, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__IntRange::Max, SOAP_TYPE_int);
#endif
}

int tt__IntRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const tt__IntRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Min", -1, &a->tt__IntRange::Min, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &a->tt__IntRange::Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, tt__IntRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Min", &a->tt__IntRange::Min, "xsd:int"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Max", &a->tt__IntRange::Max, "xsd:int"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRange *p;
	size_t k = sizeof(tt__IntRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRange(soap, tag ? tag : "tt:IntRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DateTimeRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_dateTime(soap, &this->tt__DateTimeRange::From);
	soap_default_dateTime(soap, &this->tt__DateTimeRange::Until);
}

void tt__DateTimeRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DateTimeRange::From, SOAP_TYPE_dateTime);
	soap_embedded(soap, &this->tt__DateTimeRange::Until, SOAP_TYPE_dateTime);
#endif
}

int tt__DateTimeRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DateTimeRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTimeRange(struct soap *soap, const char *tag, int id, const tt__DateTimeRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTimeRange), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:From", -1, &a->tt__DateTimeRange::From, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Until", -1, &a->tt__DateTimeRange::Until, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DateTimeRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DateTimeRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__DateTimeRange * SOAP_FMAC4 soap_in_tt__DateTimeRange(struct soap *soap, const char *tag, tt__DateTimeRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DateTimeRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTimeRange, sizeof(tt__DateTimeRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DateTimeRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DateTimeRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_From1 = 1;
	size_t soap_flag_Until1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_From1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:From", &a->tt__DateTimeRange::From, "xsd:dateTime"))
				{	soap_flag_From1--;
					continue;
				}
			}
			if (soap_flag_Until1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:Until", &a->tt__DateTimeRange::Until, "xsd:dateTime"))
				{	soap_flag_Until1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_From1 > 0 || soap_flag_Until1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DateTimeRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTimeRange, SOAP_TYPE_tt__DateTimeRange, sizeof(tt__DateTimeRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DateTimeRange * SOAP_FMAC2 soap_instantiate_tt__DateTimeRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DateTimeRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DateTimeRange *p;
	size_t k = sizeof(tt__DateTimeRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DateTimeRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DateTimeRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DateTimeRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DateTimeRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DateTimeRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DateTimeRange(soap, tag ? tag : "tt:DateTimeRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DateTimeRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DateTimeRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__DateTimeRange * SOAP_FMAC4 soap_get_tt__DateTimeRange(struct soap *soap, tt__DateTimeRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelayOutput::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	this->tt__RelayOutput::Properties = NULL;
}

void tt__RelayOutput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RelayOutputSettings(soap, &this->tt__RelayOutput::Properties);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__RelayOutput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayOutput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutput(struct soap *soap, const char *tag, int id, const tt__RelayOutput *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutput), type ? type : "tt:RelayOutput"))
		return soap->error;
	if (!a->tt__RelayOutput::Properties)
	{	if (soap_element_empty(soap, "tt:Properties", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RelayOutputSettings(soap, "tt:Properties", -1, &a->tt__RelayOutput::Properties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelayOutput::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelayOutput(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayOutput * SOAP_FMAC4 soap_in_tt__RelayOutput(struct soap *soap, const char *tag, tt__RelayOutput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelayOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutput, sizeof(tt__RelayOutput), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelayOutput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelayOutput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_Properties1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelayOutputSettings(soap, "tt:Properties", &a->tt__RelayOutput::Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__RelayOutput::Properties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_tt__RelayOutput, sizeof(tt__RelayOutput), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelayOutput * SOAP_FMAC2 soap_instantiate_tt__RelayOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelayOutput *p;
	size_t k = sizeof(tt__RelayOutput);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelayOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelayOutput);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelayOutput, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelayOutput location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelayOutput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelayOutput(soap, tag ? tag : "tt:RelayOutput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayOutput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayOutput(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayOutput * SOAP_FMAC4 soap_get_tt__RelayOutput(struct soap *soap, tt__RelayOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelayOutputSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__RelayMode(soap, &this->tt__RelayOutputSettings::Mode);
	soap_default_xsd__duration(soap, &this->tt__RelayOutputSettings::DelayTime);
	soap_default_tt__RelayIdleState(soap, &this->tt__RelayOutputSettings::IdleState);
}

void tt__RelayOutputSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RelayOutputSettings::DelayTime, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__RelayOutputSettings::DelayTime);
#endif
}

int tt__RelayOutputSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayOutputSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutputSettings(struct soap *soap, const char *tag, int id, const tt__RelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutputSettings), type))
		return soap->error;
	if (soap_out_tt__RelayMode(soap, "tt:Mode", -1, &a->tt__RelayOutputSettings::Mode, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:DelayTime", -1, &a->tt__RelayOutputSettings::DelayTime, ""))
		return soap->error;
	if (soap_out_tt__RelayIdleState(soap, "tt:IdleState", -1, &a->tt__RelayOutputSettings::IdleState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelayOutputSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelayOutputSettings(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayOutputSettings * SOAP_FMAC4 soap_in_tt__RelayOutputSettings(struct soap *soap, const char *tag, tt__RelayOutputSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelayOutputSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(tt__RelayOutputSettings), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelayOutputSettings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelayOutputSettings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_DelayTime1 = 1;
	size_t soap_flag_IdleState1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayMode(soap, "tt:Mode", &a->tt__RelayOutputSettings::Mode, "tt:RelayMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_DelayTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:DelayTime", &a->tt__RelayOutputSettings::DelayTime, "xsd:duration"))
				{	soap_flag_DelayTime1--;
					continue;
				}
			}
			if (soap_flag_IdleState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayIdleState(soap, "tt:IdleState", &a->tt__RelayOutputSettings::IdleState, "tt:RelayIdleState"))
				{	soap_flag_IdleState1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0 || soap_flag_DelayTime1 > 0 || soap_flag_IdleState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutputSettings, SOAP_TYPE_tt__RelayOutputSettings, sizeof(tt__RelayOutputSettings), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelayOutputSettings * SOAP_FMAC2 soap_instantiate_tt__RelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayOutputSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelayOutputSettings *p;
	size_t k = sizeof(tt__RelayOutputSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelayOutputSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelayOutputSettings);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelayOutputSettings, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelayOutputSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelayOutputSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelayOutputSettings(soap, tag ? tag : "tt:RelayOutputSettings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayOutputSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayOutputSettings(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayOutputSettings * SOAP_FMAC4 soap_get_tt__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TLSConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->tt__TLSConfiguration::CertificateID);
}

void tt__TLSConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__TLSConfiguration::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__TLSConfiguration::CertificateID);
#endif
}

int tt__TLSConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TLSConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TLSConfiguration(struct soap *soap, const char *tag, int id, const tt__TLSConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TLSConfiguration), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__TLSConfiguration::CertificateID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TLSConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TLSConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__TLSConfiguration * SOAP_FMAC4 soap_in_tt__TLSConfiguration(struct soap *soap, const char *tag, tt__TLSConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TLSConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TLSConfiguration, sizeof(tt__TLSConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TLSConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TLSConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__TLSConfiguration::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__TLSConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TLSConfiguration, SOAP_TYPE_tt__TLSConfiguration, sizeof(tt__TLSConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TLSConfiguration * SOAP_FMAC2 soap_instantiate_tt__TLSConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TLSConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TLSConfiguration *p;
	size_t k = sizeof(tt__TLSConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TLSConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TLSConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TLSConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TLSConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TLSConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TLSConfiguration(soap, tag ? tag : "tt:TLSConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TLSConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TLSConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__TLSConfiguration * SOAP_FMAC4 soap_get_tt__TLSConfiguration(struct soap *soap, tt__TLSConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TLSConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EapMethodExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__EapMethodExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__EapMethodExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EapMethodExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EapMethodExtension(struct soap *soap, const char *tag, int id, const tt__EapMethodExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EapMethodExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EapMethodExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EapMethodExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__EapMethodExtension * SOAP_FMAC4 soap_in_tt__EapMethodExtension(struct soap *soap, const char *tag, tt__EapMethodExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EapMethodExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EapMethodExtension, sizeof(tt__EapMethodExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EapMethodExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EapMethodExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EapMethodExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EapMethodExtension, SOAP_TYPE_tt__EapMethodExtension, sizeof(tt__EapMethodExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EapMethodExtension * SOAP_FMAC2 soap_instantiate_tt__EapMethodExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EapMethodExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EapMethodExtension *p;
	size_t k = sizeof(tt__EapMethodExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EapMethodExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EapMethodExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EapMethodExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EapMethodExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EapMethodExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EapMethodExtension(soap, tag ? tag : "tt:EapMethodExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EapMethodExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EapMethodExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__EapMethodExtension * SOAP_FMAC4 soap_get_tt__EapMethodExtension(struct soap *soap, tt__EapMethodExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EapMethodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EAPMethodConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__EAPMethodConfiguration::TLSConfiguration = NULL;
	this->tt__EAPMethodConfiguration::Password = NULL;
	this->tt__EAPMethodConfiguration::Extension = NULL;
}

void tt__EAPMethodConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__TLSConfiguration(soap, &this->tt__EAPMethodConfiguration::TLSConfiguration);
	soap_serialize_PointerTostd__string(soap, &this->tt__EAPMethodConfiguration::Password);
	soap_serialize_PointerTott__EapMethodExtension(soap, &this->tt__EAPMethodConfiguration::Extension);
#endif
}

int tt__EAPMethodConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EAPMethodConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, int id, const tt__EAPMethodConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EAPMethodConfiguration), type))
		return soap->error;
	if (soap_out_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", -1, &a->tt__EAPMethodConfiguration::TLSConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Password", -1, &a->tt__EAPMethodConfiguration::Password, ""))
		return soap->error;
	if (soap_out_PointerTott__EapMethodExtension(soap, "tt:Extension", -1, &a->tt__EAPMethodConfiguration::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EAPMethodConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EAPMethodConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__EAPMethodConfiguration * SOAP_FMAC4 soap_in_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, tt__EAPMethodConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EAPMethodConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(tt__EAPMethodConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EAPMethodConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EAPMethodConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TLSConfiguration1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLSConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", &a->tt__EAPMethodConfiguration::TLSConfiguration, "tt:TLSConfiguration"))
				{	soap_flag_TLSConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Password", &a->tt__EAPMethodConfiguration::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EapMethodExtension(soap, "tt:Extension", &a->tt__EAPMethodConfiguration::Extension, "tt:EapMethodExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EAPMethodConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EAPMethodConfiguration, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(tt__EAPMethodConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EAPMethodConfiguration * SOAP_FMAC2 soap_instantiate_tt__EAPMethodConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EAPMethodConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EAPMethodConfiguration *p;
	size_t k = sizeof(tt__EAPMethodConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EAPMethodConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EAPMethodConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EAPMethodConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EAPMethodConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EAPMethodConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EAPMethodConfiguration(soap, tag ? tag : "tt:EAPMethodConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EAPMethodConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EAPMethodConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__EAPMethodConfiguration * SOAP_FMAC4 soap_get_tt__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EAPMethodConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot1XConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__Dot1XConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Dot1XConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot1XConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__Dot1XConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot1XConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot1XConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, tt__Dot1XConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot1XConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(tt__Dot1XConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot1XConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot1XConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot1XConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfigurationExtension, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(tt__Dot1XConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot1XConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot1XConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot1XConfigurationExtension *p;
	size_t k = sizeof(tt__Dot1XConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot1XConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot1XConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot1XConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot1XConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot1XConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot1XConfigurationExtension(soap, tag ? tag : "tt:Dot1XConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot1XConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot1XConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->tt__Dot1XConfiguration::Dot1XConfigurationToken);
	soap_default_std__string(soap, &this->tt__Dot1XConfiguration::Identity);
	this->tt__Dot1XConfiguration::AnonymousID = NULL;
	soap_default_int(soap, &this->tt__Dot1XConfiguration::EAPMethod);
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->tt__Dot1XConfiguration::CACertificateID);
	this->tt__Dot1XConfiguration::EAPMethodConfiguration = NULL;
	this->tt__Dot1XConfiguration::Extension = NULL;
}

void tt__Dot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Dot1XConfiguration::Dot1XConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__Dot1XConfiguration::Dot1XConfigurationToken);
	soap_embedded(soap, &this->tt__Dot1XConfiguration::Identity, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__Dot1XConfiguration::Identity);
	soap_serialize_PointerTostd__string(soap, &this->tt__Dot1XConfiguration::AnonymousID);
	soap_embedded(soap, &this->tt__Dot1XConfiguration::EAPMethod, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->tt__Dot1XConfiguration::CACertificateID);
	soap_serialize_PointerTott__EAPMethodConfiguration(soap, &this->tt__Dot1XConfiguration::EAPMethodConfiguration);
	soap_serialize_PointerTott__Dot1XConfigurationExtension(soap, &this->tt__Dot1XConfiguration::Extension);
#endif
}

int tt__Dot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfiguration(struct soap *soap, const char *tag, int id, const tt__Dot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", -1, &a->tt__Dot1XConfiguration::Dot1XConfigurationToken, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Identity", -1, &a->tt__Dot1XConfiguration::Identity, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:AnonymousID", -1, &a->tt__Dot1XConfiguration::AnonymousID, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EAPMethod", -1, &a->tt__Dot1XConfiguration::EAPMethod, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tt:CACertificateID", -1, &a->tt__Dot1XConfiguration::CACertificateID, ""))
		return soap->error;
	if (soap_out_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", -1, &a->tt__Dot1XConfiguration::EAPMethodConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", -1, &a->tt__Dot1XConfiguration::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot1XConfiguration * SOAP_FMAC4 soap_in_tt__Dot1XConfiguration(struct soap *soap, const char *tag, tt__Dot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfigurationToken1 = 1;
	size_t soap_flag_Identity1 = 1;
	size_t soap_flag_AnonymousID1 = 1;
	size_t soap_flag_EAPMethod1 = 1;
	size_t soap_flag_EAPMethodConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", &a->tt__Dot1XConfiguration::Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken1--;
					continue;
				}
			}
			if (soap_flag_Identity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Identity", &a->tt__Dot1XConfiguration::Identity, "xsd:string"))
				{	soap_flag_Identity1--;
					continue;
				}
			}
			if (soap_flag_AnonymousID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:AnonymousID", &a->tt__Dot1XConfiguration::AnonymousID, "xsd:string"))
				{	soap_flag_AnonymousID1--;
					continue;
				}
			}
			if (soap_flag_EAPMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:EAPMethod", &a->tt__Dot1XConfiguration::EAPMethod, "xsd:int"))
				{	soap_flag_EAPMethod1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tt:CACertificateID", &a->tt__Dot1XConfiguration::CACertificateID, "xsd:token"))
					continue;
			}
			if (soap_flag_EAPMethodConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", &a->tt__Dot1XConfiguration::EAPMethodConfiguration, "tt:EAPMethodConfiguration"))
				{	soap_flag_EAPMethodConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", &a->tt__Dot1XConfiguration::Extension, "tt:Dot1XConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfigurationToken1 > 0 || soap_flag_Identity1 > 0 || soap_flag_EAPMethod1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfiguration, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot1XConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot1XConfiguration *p;
	size_t k = sizeof(tt__Dot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot1XConfiguration(soap, tag ? tag : "tt:Dot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot1XConfiguration * SOAP_FMAC4 soap_get_tt__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__CertificateInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__CertificateInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformationExtension(struct soap *soap, const char *tag, int id, const tt__CertificateInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateInformationExtension * SOAP_FMAC4 soap_in_tt__CertificateInformationExtension(struct soap *soap, const char *tag, tt__CertificateInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(tt__CertificateInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CertificateInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformationExtension, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(tt__CertificateInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateInformationExtension *p;
	size_t k = sizeof(tt__CertificateInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateInformationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateInformationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateInformationExtension(soap, tag ? tag : "tt:CertificateInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateInformationExtension * SOAP_FMAC4 soap_get_tt__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateUsage::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->tt__CertificateUsage::__item);
	soap_default_bool(soap, &this->tt__CertificateUsage::Critical);
}

void tt__CertificateUsage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__CertificateUsage::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__CertificateUsage::__item);
#endif
}

int tt__CertificateUsage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateUsage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateUsage(struct soap *soap, const char *tag, int id, const tt__CertificateUsage *a, const char *type)
{
	soap_set_attr(soap, "Critical", soap_bool2s(soap, ((tt__CertificateUsage*)a)->Critical), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->tt__CertificateUsage::__item, "");
}

void *tt__CertificateUsage::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateUsage(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateUsage * SOAP_FMAC4 soap_in_tt__CertificateUsage(struct soap *soap, const char *tag, tt__CertificateUsage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__CertificateUsage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateUsage, sizeof(tt__CertificateUsage), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateUsage)
		return (tt__CertificateUsage *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "Critical", 5, 1), &((tt__CertificateUsage*)a)->Critical))
		return NULL;
	if (!soap_in_std__string(soap, tag, &a->tt__CertificateUsage::__item, "tt:CertificateUsage"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__CertificateUsage * SOAP_FMAC2 soap_instantiate_tt__CertificateUsage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateUsage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateUsage *p;
	size_t k = sizeof(tt__CertificateUsage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateUsage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateUsage);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateUsage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateUsage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateUsage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateUsage(soap, tag ? tag : "tt:CertificateUsage", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateUsage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateUsage(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateUsage * SOAP_FMAC4 soap_get_tt__CertificateUsage(struct soap *soap, tt__CertificateUsage *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->tt__CertificateInformation::CertificateID);
	this->tt__CertificateInformation::IssuerDN = NULL;
	this->tt__CertificateInformation::SubjectDN = NULL;
	this->tt__CertificateInformation::KeyUsage = NULL;
	this->tt__CertificateInformation::ExtendedKeyUsage = NULL;
	this->tt__CertificateInformation::KeyLength = NULL;
	this->tt__CertificateInformation::Version = NULL;
	this->tt__CertificateInformation::SerialNum = NULL;
	this->tt__CertificateInformation::SignatureAlgorithm = NULL;
	this->tt__CertificateInformation::Validity = NULL;
	this->tt__CertificateInformation::Extension = NULL;
}

void tt__CertificateInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__CertificateInformation::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__CertificateInformation::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::IssuerDN);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::SubjectDN);
	soap_serialize_PointerTott__CertificateUsage(soap, &this->tt__CertificateInformation::KeyUsage);
	soap_serialize_PointerTott__CertificateUsage(soap, &this->tt__CertificateInformation::ExtendedKeyUsage);
	soap_serialize_PointerToint(soap, &this->tt__CertificateInformation::KeyLength);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::Version);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::SerialNum);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::SignatureAlgorithm);
	soap_serialize_PointerTott__DateTimeRange(soap, &this->tt__CertificateInformation::Validity);
	soap_serialize_PointerTott__CertificateInformationExtension(soap, &this->tt__CertificateInformation::Extension);
#endif
}

int tt__CertificateInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformation(struct soap *soap, const char *tag, int id, const tt__CertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformation), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__CertificateInformation::CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:IssuerDN", -1, &a->tt__CertificateInformation::IssuerDN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:SubjectDN", -1, &a->tt__CertificateInformation::SubjectDN, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:KeyUsage", -1, &a->tt__CertificateInformation::KeyUsage, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", -1, &a->tt__CertificateInformation::ExtendedKeyUsage, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:KeyLength", -1, &a->tt__CertificateInformation::KeyLength, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Version", -1, &a->tt__CertificateInformation::Version, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:SerialNum", -1, &a->tt__CertificateInformation::SerialNum, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:SignatureAlgorithm", -1, &a->tt__CertificateInformation::SignatureAlgorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTimeRange(soap, "tt:Validity", -1, &a->tt__CertificateInformation::Validity, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateInformationExtension(soap, "tt:Extension", -1, &a->tt__CertificateInformation::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateInformation * SOAP_FMAC4 soap_in_tt__CertificateInformation(struct soap *soap, const char *tag, tt__CertificateInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformation, sizeof(tt__CertificateInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_IssuerDN1 = 1;
	size_t soap_flag_SubjectDN1 = 1;
	size_t soap_flag_KeyUsage1 = 1;
	size_t soap_flag_ExtendedKeyUsage1 = 1;
	size_t soap_flag_KeyLength1 = 1;
	size_t soap_flag_Version1 = 1;
	size_t soap_flag_SerialNum1 = 1;
	size_t soap_flag_SignatureAlgorithm1 = 1;
	size_t soap_flag_Validity1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__CertificateInformation::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_IssuerDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:IssuerDN", &a->tt__CertificateInformation::IssuerDN, "xsd:string"))
				{	soap_flag_IssuerDN1--;
					continue;
				}
			}
			if (soap_flag_SubjectDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:SubjectDN", &a->tt__CertificateInformation::SubjectDN, "xsd:string"))
				{	soap_flag_SubjectDN1--;
					continue;
				}
			}
			if (soap_flag_KeyUsage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateUsage(soap, "tt:KeyUsage", &a->tt__CertificateInformation::KeyUsage, "tt:CertificateUsage"))
				{	soap_flag_KeyUsage1--;
					continue;
				}
			}
			if (soap_flag_ExtendedKeyUsage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", &a->tt__CertificateInformation::ExtendedKeyUsage, "tt:CertificateUsage"))
				{	soap_flag_ExtendedKeyUsage1--;
					continue;
				}
			}
			if (soap_flag_KeyLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:KeyLength", &a->tt__CertificateInformation::KeyLength, "xsd:int"))
				{	soap_flag_KeyLength1--;
					continue;
				}
			}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Version", &a->tt__CertificateInformation::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			}
			if (soap_flag_SerialNum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:SerialNum", &a->tt__CertificateInformation::SerialNum, "xsd:string"))
				{	soap_flag_SerialNum1--;
					continue;
				}
			}
			if (soap_flag_SignatureAlgorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:SignatureAlgorithm", &a->tt__CertificateInformation::SignatureAlgorithm, "xsd:string"))
				{	soap_flag_SignatureAlgorithm1--;
					continue;
				}
			}
			if (soap_flag_Validity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTimeRange(soap, "tt:Validity", &a->tt__CertificateInformation::Validity, "tt:DateTimeRange"))
				{	soap_flag_Validity1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateInformationExtension(soap, "tt:Extension", &a->tt__CertificateInformation::Extension, "tt:CertificateInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformation, SOAP_TYPE_tt__CertificateInformation, sizeof(tt__CertificateInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateInformation * SOAP_FMAC2 soap_instantiate_tt__CertificateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateInformation *p;
	size_t k = sizeof(tt__CertificateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateInformation(soap, tag ? tag : "tt:CertificateInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateInformation * SOAP_FMAC4 soap_get_tt__CertificateInformation(struct soap *soap, tt__CertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateWithPrivateKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__CertificateWithPrivateKey::CertificateID = NULL;
	this->tt__CertificateWithPrivateKey::Certificate = NULL;
	this->tt__CertificateWithPrivateKey::PrivateKey = NULL;
}

void tt__CertificateWithPrivateKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__token(soap, &this->tt__CertificateWithPrivateKey::CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &this->tt__CertificateWithPrivateKey::Certificate);
	soap_serialize_PointerTott__BinaryData(soap, &this->tt__CertificateWithPrivateKey::PrivateKey);
#endif
}

int tt__CertificateWithPrivateKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateWithPrivateKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const tt__CertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateWithPrivateKey), type))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:CertificateID", -1, &a->tt__CertificateWithPrivateKey::CertificateID, ""))
		return soap->error;
	if (!a->tt__CertificateWithPrivateKey::Certificate)
	{	if (soap_element_empty(soap, "tt:Certificate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->tt__CertificateWithPrivateKey::Certificate, ""))
		return soap->error;
	if (!a->tt__CertificateWithPrivateKey::PrivateKey)
	{	if (soap_element_empty(soap, "tt:PrivateKey", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:PrivateKey", -1, &a->tt__CertificateWithPrivateKey::PrivateKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateWithPrivateKey::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateWithPrivateKey(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_in_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, tt__CertificateWithPrivateKey *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateWithPrivateKey*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateWithPrivateKey)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateWithPrivateKey *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Certificate1 = 1;
	size_t soap_flag_PrivateKey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tt:CertificateID", &a->tt__CertificateWithPrivateKey::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Certificate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->tt__CertificateWithPrivateKey::Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate1--;
					continue;
				}
			}
			if (soap_flag_PrivateKey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:PrivateKey", &a->tt__CertificateWithPrivateKey::PrivateKey, "tt:BinaryData"))
				{	soap_flag_PrivateKey1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__CertificateWithPrivateKey::Certificate || !a->tt__CertificateWithPrivateKey::PrivateKey))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateWithPrivateKey, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate_tt__CertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateWithPrivateKey *p;
	size_t k = sizeof(tt__CertificateWithPrivateKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateWithPrivateKey);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateWithPrivateKey, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateWithPrivateKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateWithPrivateKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateWithPrivateKey(soap, tag ? tag : "tt:CertificateWithPrivateKey", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateWithPrivateKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateWithPrivateKey(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_get_tt__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->tt__CertificateStatus::CertificateID);
	soap_default_bool(soap, &this->tt__CertificateStatus::Status);
}

void tt__CertificateStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__CertificateStatus::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__CertificateStatus::CertificateID);
	soap_embedded(soap, &this->tt__CertificateStatus::Status, SOAP_TYPE_bool);
#endif
}

int tt__CertificateStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateStatus(struct soap *soap, const char *tag, int id, const tt__CertificateStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateStatus), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__CertificateStatus::CertificateID, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Status", -1, &a->tt__CertificateStatus::Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateStatus * SOAP_FMAC4 soap_in_tt__CertificateStatus(struct soap *soap, const char *tag, tt__CertificateStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateStatus, sizeof(tt__CertificateStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Status1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__CertificateStatus::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Status", &a->tt__CertificateStatus::Status, "xsd:boolean"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0 || soap_flag_Status1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CertificateStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateStatus, SOAP_TYPE_tt__CertificateStatus, sizeof(tt__CertificateStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateStatus * SOAP_FMAC2 soap_instantiate_tt__CertificateStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateStatus *p;
	size_t k = sizeof(tt__CertificateStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateStatus(soap, tag ? tag : "tt:CertificateStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateStatus * SOAP_FMAC4 soap_get_tt__CertificateStatus(struct soap *soap, tt__CertificateStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Certificate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->tt__Certificate::CertificateID);
	this->tt__Certificate::Certificate = NULL;
}

void tt__Certificate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Certificate::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__Certificate::CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &this->tt__Certificate::Certificate);
#endif
}

int tt__Certificate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Certificate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Certificate(struct soap *soap, const char *tag, int id, const tt__Certificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Certificate), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__Certificate::CertificateID, ""))
		return soap->error;
	if (!a->tt__Certificate::Certificate)
	{	if (soap_element_empty(soap, "tt:Certificate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->tt__Certificate::Certificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Certificate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Certificate(soap, tag, this, type);
}

SOAP_FMAC3 tt__Certificate * SOAP_FMAC4 soap_in_tt__Certificate(struct soap *soap, const char *tag, tt__Certificate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Certificate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Certificate, sizeof(tt__Certificate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Certificate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Certificate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Certificate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__Certificate::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Certificate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->tt__Certificate::Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0 || !a->tt__Certificate::Certificate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Certificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Certificate, SOAP_TYPE_tt__Certificate, sizeof(tt__Certificate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Certificate * SOAP_FMAC2 soap_instantiate_tt__Certificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Certificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Certificate *p;
	size_t k = sizeof(tt__Certificate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Certificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Certificate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Certificate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Certificate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Certificate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Certificate(soap, tag ? tag : "tt:Certificate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Certificate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Certificate(soap, this, tag, type);
}

SOAP_FMAC3 tt__Certificate * SOAP_FMAC4 soap_get_tt__Certificate(struct soap *soap, tt__Certificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__UserExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__UserExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__UserExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__UserExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserExtension(struct soap *soap, const char *tag, int id, const tt__UserExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__UserExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__UserExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__UserExtension * SOAP_FMAC4 soap_in_tt__UserExtension(struct soap *soap, const char *tag, tt__UserExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__UserExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserExtension, sizeof(tt__UserExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__UserExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__UserExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__UserExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserExtension, SOAP_TYPE_tt__UserExtension, sizeof(tt__UserExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__UserExtension * SOAP_FMAC2 soap_instantiate_tt__UserExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__UserExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__UserExtension *p;
	size_t k = sizeof(tt__UserExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__UserExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__UserExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__UserExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__UserExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__UserExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__UserExtension(soap, tag ? tag : "tt:UserExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__UserExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__UserExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__UserExtension * SOAP_FMAC4 soap_get_tt__UserExtension(struct soap *soap, tt__UserExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__User::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->tt__User::Username);
	this->tt__User::Password = NULL;
	soap_default_tt__UserLevel(soap, &this->tt__User::UserLevel);
	this->tt__User::Extension = NULL;
}

void tt__User::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__User::Username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__User::Username);
	soap_serialize_PointerTostd__string(soap, &this->tt__User::Password);
	soap_serialize_PointerTott__UserExtension(soap, &this->tt__User::Extension);
#endif
}

int tt__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__User(struct soap *soap, const char *tag, int id, const tt__User *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__User), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Username", -1, &a->tt__User::Username, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Password", -1, &a->tt__User::Password, ""))
		return soap->error;
	if (soap_out_tt__UserLevel(soap, "tt:UserLevel", -1, &a->tt__User::UserLevel, ""))
		return soap->error;
	if (soap_out_PointerTott__UserExtension(soap, "tt:Extension", -1, &a->tt__User::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__User::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__User(soap, tag, this, type);
}

SOAP_FMAC3 tt__User * SOAP_FMAC4 soap_in_tt__User(struct soap *soap, const char *tag, tt__User *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__User*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__User, sizeof(tt__User), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__User)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__User *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_UserLevel1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Username", &a->tt__User::Username, "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Password", &a->tt__User::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_UserLevel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__UserLevel(soap, "tt:UserLevel", &a->tt__User::UserLevel, "tt:UserLevel"))
				{	soap_flag_UserLevel1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__UserExtension(soap, "tt:Extension", &a->tt__User::Extension, "tt:UserExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username1 > 0 || soap_flag_UserLevel1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__User, SOAP_TYPE_tt__User, sizeof(tt__User), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__User * SOAP_FMAC2 soap_instantiate_tt__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__User(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__User *p;
	size_t k = sizeof(tt__User);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__User, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__User);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__User, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__User location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__User(soap, tag ? tag : "tt:User", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__User(soap, this, tag, type);
}

SOAP_FMAC3 tt__User * SOAP_FMAC4 soap_get_tt__User(struct soap *soap, tt__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RemoteUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->tt__RemoteUser::Username);
	this->tt__RemoteUser::Password = NULL;
	soap_default_bool(soap, &this->tt__RemoteUser::UseDerivedPassword);
}

void tt__RemoteUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RemoteUser::Username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__RemoteUser::Username);
	soap_serialize_PointerTostd__string(soap, &this->tt__RemoteUser::Password);
	soap_embedded(soap, &this->tt__RemoteUser::UseDerivedPassword, SOAP_TYPE_bool);
#endif
}

int tt__RemoteUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RemoteUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RemoteUser(struct soap *soap, const char *tag, int id, const tt__RemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RemoteUser), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Username", -1, &a->tt__RemoteUser::Username, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Password", -1, &a->tt__RemoteUser::Password, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:UseDerivedPassword", -1, &a->tt__RemoteUser::UseDerivedPassword, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RemoteUser::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RemoteUser(soap, tag, this, type);
}

SOAP_FMAC3 tt__RemoteUser * SOAP_FMAC4 soap_in_tt__RemoteUser(struct soap *soap, const char *tag, tt__RemoteUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RemoteUser, sizeof(tt__RemoteUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RemoteUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RemoteUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_UseDerivedPassword1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Username", &a->tt__RemoteUser::Username, "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Password", &a->tt__RemoteUser::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_UseDerivedPassword1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:UseDerivedPassword", &a->tt__RemoteUser::UseDerivedPassword, "xsd:boolean"))
				{	soap_flag_UseDerivedPassword1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username1 > 0 || soap_flag_UseDerivedPassword1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RemoteUser, SOAP_TYPE_tt__RemoteUser, sizeof(tt__RemoteUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RemoteUser * SOAP_FMAC2 soap_instantiate_tt__RemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RemoteUser *p;
	size_t k = sizeof(tt__RemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RemoteUser);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RemoteUser, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RemoteUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RemoteUser(soap, tag ? tag : "tt:RemoteUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RemoteUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RemoteUser(soap, this, tag, type);
}

SOAP_FMAC3 tt__RemoteUser * SOAP_FMAC4 soap_get_tt__RemoteUser(struct soap *soap, tt__RemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TimeZone::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->tt__TimeZone::TZ);
}

void tt__TimeZone::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__TimeZone::TZ, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__TimeZone::TZ);
#endif
}

int tt__TimeZone::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TimeZone(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TimeZone(struct soap *soap, const char *tag, int id, const tt__TimeZone *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TimeZone), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:TZ", -1, &a->tt__TimeZone::TZ, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TimeZone::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TimeZone(soap, tag, this, type);
}

SOAP_FMAC3 tt__TimeZone * SOAP_FMAC4 soap_in_tt__TimeZone(struct soap *soap, const char *tag, tt__TimeZone *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TimeZone*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TimeZone, sizeof(tt__TimeZone), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TimeZone)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TimeZone *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TZ1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:TZ", &a->tt__TimeZone::TZ, "xsd:token"))
				{	soap_flag_TZ1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TZ1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__TimeZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TimeZone, SOAP_TYPE_tt__TimeZone, sizeof(tt__TimeZone), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TimeZone * SOAP_FMAC2 soap_instantiate_tt__TimeZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TimeZone(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TimeZone *p;
	size_t k = sizeof(tt__TimeZone);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TimeZone, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TimeZone);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TimeZone, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TimeZone location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TimeZone::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TimeZone(soap, tag ? tag : "tt:TimeZone", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TimeZone::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TimeZone(soap, this, tag, type);
}

SOAP_FMAC3 tt__TimeZone * SOAP_FMAC4 soap_get_tt__TimeZone(struct soap *soap, tt__TimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Time::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__Time::Hour);
	soap_default_int(soap, &this->tt__Time::Minute);
	soap_default_int(soap, &this->tt__Time::Second);
}

void tt__Time::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Time::Hour, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Time::Minute, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Time::Second, SOAP_TYPE_int);
#endif
}

int tt__Time::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Time(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Time(struct soap *soap, const char *tag, int id, const tt__Time *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Time), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Hour", -1, &a->tt__Time::Hour, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minute", -1, &a->tt__Time::Minute, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Second", -1, &a->tt__Time::Second, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Time::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Time(soap, tag, this, type);
}

SOAP_FMAC3 tt__Time * SOAP_FMAC4 soap_in_tt__Time(struct soap *soap, const char *tag, tt__Time *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Time*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Time, sizeof(tt__Time), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Time)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Time *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Hour1 = 1;
	size_t soap_flag_Minute1 = 1;
	size_t soap_flag_Second1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Hour1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Hour", &a->tt__Time::Hour, "xsd:int"))
				{	soap_flag_Hour1--;
					continue;
				}
			}
			if (soap_flag_Minute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Minute", &a->tt__Time::Minute, "xsd:int"))
				{	soap_flag_Minute1--;
					continue;
				}
			}
			if (soap_flag_Second1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Second", &a->tt__Time::Second, "xsd:int"))
				{	soap_flag_Second1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Hour1 > 0 || soap_flag_Minute1 > 0 || soap_flag_Second1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Time *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Time, SOAP_TYPE_tt__Time, sizeof(tt__Time), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Time * SOAP_FMAC2 soap_instantiate_tt__Time(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Time(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Time *p;
	size_t k = sizeof(tt__Time);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Time, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Time);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Time, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Time location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Time::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Time(soap, tag ? tag : "tt:Time", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Time::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Time(soap, this, tag, type);
}

SOAP_FMAC3 tt__Time * SOAP_FMAC4 soap_get_tt__Time(struct soap *soap, tt__Time *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Date::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__Date::Year);
	soap_default_int(soap, &this->tt__Date::Month);
	soap_default_int(soap, &this->tt__Date::Day);
}

void tt__Date::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Date::Year, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Date::Month, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Date::Day, SOAP_TYPE_int);
#endif
}

int tt__Date::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Date(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Date(struct soap *soap, const char *tag, int id, const tt__Date *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Date), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Year", -1, &a->tt__Date::Year, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Month", -1, &a->tt__Date::Month, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Day", -1, &a->tt__Date::Day, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Date::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Date(soap, tag, this, type);
}

SOAP_FMAC3 tt__Date * SOAP_FMAC4 soap_in_tt__Date(struct soap *soap, const char *tag, tt__Date *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Date*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Date, sizeof(tt__Date), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Date)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Date *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Year1 = 1;
	size_t soap_flag_Month1 = 1;
	size_t soap_flag_Day1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Year1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Year", &a->tt__Date::Year, "xsd:int"))
				{	soap_flag_Year1--;
					continue;
				}
			}
			if (soap_flag_Month1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Month", &a->tt__Date::Month, "xsd:int"))
				{	soap_flag_Month1--;
					continue;
				}
			}
			if (soap_flag_Day1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Day", &a->tt__Date::Day, "xsd:int"))
				{	soap_flag_Day1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Year1 > 0 || soap_flag_Month1 > 0 || soap_flag_Day1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Date, SOAP_TYPE_tt__Date, sizeof(tt__Date), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Date * SOAP_FMAC2 soap_instantiate_tt__Date(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Date(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Date *p;
	size_t k = sizeof(tt__Date);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Date, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Date);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Date, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Date location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Date::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Date(soap, tag ? tag : "tt:Date", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Date::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Date(soap, this, tag, type);
}

SOAP_FMAC3 tt__Date * SOAP_FMAC4 soap_get_tt__Date(struct soap *soap, tt__Date *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DateTime::Time = NULL;
	this->tt__DateTime::Date = NULL;
}

void tt__DateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Time(soap, &this->tt__DateTime::Time);
	soap_serialize_PointerTott__Date(soap, &this->tt__DateTime::Date);
#endif
}

int tt__DateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTime(struct soap *soap, const char *tag, int id, const tt__DateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTime), type))
		return soap->error;
	if (!a->tt__DateTime::Time)
	{	if (soap_element_empty(soap, "tt:Time", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Time(soap, "tt:Time", -1, &a->tt__DateTime::Time, ""))
		return soap->error;
	if (!a->tt__DateTime::Date)
	{	if (soap_element_empty(soap, "tt:Date", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Date(soap, "tt:Date", -1, &a->tt__DateTime::Date, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DateTime(soap, tag, this, type);
}

SOAP_FMAC3 tt__DateTime * SOAP_FMAC4 soap_in_tt__DateTime(struct soap *soap, const char *tag, tt__DateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DateTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTime, sizeof(tt__DateTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DateTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DateTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Time1 = 1;
	size_t soap_flag_Date1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Time(soap, "tt:Time", &a->tt__DateTime::Time, "tt:Time"))
				{	soap_flag_Time1--;
					continue;
				}
			}
			if (soap_flag_Date1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Date(soap, "tt:Date", &a->tt__DateTime::Date, "tt:Date"))
				{	soap_flag_Date1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__DateTime::Time || !a->tt__DateTime::Date))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTime, SOAP_TYPE_tt__DateTime, sizeof(tt__DateTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DateTime * SOAP_FMAC2 soap_instantiate_tt__DateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DateTime *p;
	size_t k = sizeof(tt__DateTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DateTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DateTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DateTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DateTime(soap, tag ? tag : "tt:DateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DateTime(soap, this, tag, type);
}

SOAP_FMAC3 tt__DateTime * SOAP_FMAC4 soap_get_tt__DateTime(struct soap *soap, tt__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemDateTimeExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__SystemDateTimeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__SystemDateTimeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemDateTimeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, const tt__SystemDateTimeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTimeExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemDateTimeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemDateTimeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemDateTimeExtension * SOAP_FMAC4 soap_in_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, tt__SystemDateTimeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemDateTimeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(tt__SystemDateTimeExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemDateTimeExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemDateTimeExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemDateTimeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTimeExtension, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(tt__SystemDateTimeExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemDateTimeExtension * SOAP_FMAC2 soap_instantiate_tt__SystemDateTimeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemDateTimeExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemDateTimeExtension *p;
	size_t k = sizeof(tt__SystemDateTimeExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemDateTimeExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemDateTimeExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemDateTimeExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemDateTimeExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemDateTimeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemDateTimeExtension(soap, tag ? tag : "tt:SystemDateTimeExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemDateTimeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemDateTimeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemDateTimeExtension * SOAP_FMAC4 soap_get_tt__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemDateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__SetDateTimeType(soap, &this->tt__SystemDateTime::DateTimeType);
	soap_default_bool(soap, &this->tt__SystemDateTime::DaylightSavings);
	this->tt__SystemDateTime::TimeZone = NULL;
	this->tt__SystemDateTime::UTCDateTime = NULL;
	this->tt__SystemDateTime::LocalDateTime = NULL;
	this->tt__SystemDateTime::Extension = NULL;
}

void tt__SystemDateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SystemDateTime::DaylightSavings, SOAP_TYPE_bool);
	soap_serialize_PointerTott__TimeZone(soap, &this->tt__SystemDateTime::TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &this->tt__SystemDateTime::UTCDateTime);
	soap_serialize_PointerTott__DateTime(soap, &this->tt__SystemDateTime::LocalDateTime);
	soap_serialize_PointerTott__SystemDateTimeExtension(soap, &this->tt__SystemDateTime::Extension);
#endif
}

int tt__SystemDateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemDateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTime(struct soap *soap, const char *tag, int id, const tt__SystemDateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tt:DateTimeType", -1, &a->tt__SystemDateTime::DateTimeType, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DaylightSavings", -1, &a->tt__SystemDateTime::DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tt:TimeZone", -1, &a->tt__SystemDateTime::TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:UTCDateTime", -1, &a->tt__SystemDateTime::UTCDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:LocalDateTime", -1, &a->tt__SystemDateTime::LocalDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", -1, &a->tt__SystemDateTime::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemDateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemDateTime(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemDateTime * SOAP_FMAC4 soap_in_tt__SystemDateTime(struct soap *soap, const char *tag, tt__SystemDateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemDateTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTime, sizeof(tt__SystemDateTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemDateTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemDateTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DateTimeType1 = 1;
	size_t soap_flag_DaylightSavings1 = 1;
	size_t soap_flag_TimeZone1 = 1;
	size_t soap_flag_UTCDateTime1 = 1;
	size_t soap_flag_LocalDateTime1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SetDateTimeType(soap, "tt:DateTimeType", &a->tt__SystemDateTime::DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType1--;
					continue;
				}
			}
			if (soap_flag_DaylightSavings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DaylightSavings", &a->tt__SystemDateTime::DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings1--;
					continue;
				}
			}
			if (soap_flag_TimeZone1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TimeZone(soap, "tt:TimeZone", &a->tt__SystemDateTime::TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone1--;
					continue;
				}
			}
			if (soap_flag_UTCDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tt:UTCDateTime", &a->tt__SystemDateTime::UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime1--;
					continue;
				}
			}
			if (soap_flag_LocalDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tt:LocalDateTime", &a->tt__SystemDateTime::LocalDateTime, "tt:DateTime"))
				{	soap_flag_LocalDateTime1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", &a->tt__SystemDateTime::Extension, "tt:SystemDateTimeExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType1 > 0 || soap_flag_DaylightSavings1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SystemDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTime, SOAP_TYPE_tt__SystemDateTime, sizeof(tt__SystemDateTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemDateTime * SOAP_FMAC2 soap_instantiate_tt__SystemDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemDateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemDateTime *p;
	size_t k = sizeof(tt__SystemDateTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemDateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemDateTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemDateTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemDateTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemDateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemDateTime(soap, tag ? tag : "tt:SystemDateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemDateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemDateTime(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemDateTime * SOAP_FMAC4 soap_get_tt__SystemDateTime(struct soap *soap, tt__SystemDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemLogUri::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__SystemLogType(soap, &this->tt__SystemLogUri::Type);
	soap_default_xsd__anyURI(soap, &this->tt__SystemLogUri::Uri);
}

void tt__SystemLogUri::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SystemLogUri::Uri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__SystemLogUri::Uri);
#endif
}

int tt__SystemLogUri::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLogUri(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUri(struct soap *soap, const char *tag, int id, const tt__SystemLogUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUri), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tt:Type", -1, &a->tt__SystemLogUri::Type, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:Uri", -1, &a->tt__SystemLogUri::Uri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemLogUri::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemLogUri(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLogUri * SOAP_FMAC4 soap_in_tt__SystemLogUri(struct soap *soap, const char *tag, tt__SystemLogUri *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemLogUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUri, sizeof(tt__SystemLogUri), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemLogUri)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemLogUri *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Uri1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SystemLogType(soap, "tt:Type", &a->tt__SystemLogUri::Type, "tt:SystemLogType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Uri", &a->tt__SystemLogUri::Uri, "xsd:anyURI"))
				{	soap_flag_Uri1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0 || soap_flag_Uri1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SystemLogUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUri, SOAP_TYPE_tt__SystemLogUri, sizeof(tt__SystemLogUri), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLogUri * SOAP_FMAC2 soap_instantiate_tt__SystemLogUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLogUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemLogUri *p;
	size_t k = sizeof(tt__SystemLogUri);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemLogUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemLogUri);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemLogUri, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemLogUri location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemLogUri::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemLogUri(soap, tag ? tag : "tt:SystemLogUri", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLogUri::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLogUri(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLogUri * SOAP_FMAC4 soap_get_tt__SystemLogUri(struct soap *soap, tt__SystemLogUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemLogUriList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__SystemLogUri(soap, &this->tt__SystemLogUriList::SystemLog);
}

void tt__SystemLogUriList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__SystemLogUri(soap, &this->tt__SystemLogUriList::SystemLog);
#endif
}

int tt__SystemLogUriList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLogUriList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUriList(struct soap *soap, const char *tag, int id, const tt__SystemLogUriList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUriList), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__SystemLogUri(soap, "tt:SystemLog", -1, &a->tt__SystemLogUriList::SystemLog, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemLogUriList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemLogUriList(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLogUriList * SOAP_FMAC4 soap_in_tt__SystemLogUriList(struct soap *soap, const char *tag, tt__SystemLogUriList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemLogUriList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUriList, sizeof(tt__SystemLogUriList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemLogUriList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemLogUriList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__SystemLogUri(soap, "tt:SystemLog", &a->tt__SystemLogUriList::SystemLog, "tt:SystemLogUri"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemLogUriList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUriList, SOAP_TYPE_tt__SystemLogUriList, sizeof(tt__SystemLogUriList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLogUriList * SOAP_FMAC2 soap_instantiate_tt__SystemLogUriList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLogUriList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemLogUriList *p;
	size_t k = sizeof(tt__SystemLogUriList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemLogUriList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemLogUriList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemLogUriList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemLogUriList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemLogUriList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemLogUriList(soap, tag ? tag : "tt:SystemLogUriList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLogUriList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLogUriList(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLogUriList * SOAP_FMAC4 soap_get_tt__SystemLogUriList(struct soap *soap, tt__SystemLogUriList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BackupFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->tt__BackupFile::Name);
	this->tt__BackupFile::Data = NULL;
}

void tt__BackupFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__BackupFile::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__BackupFile::Name);
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__BackupFile::Data);
#endif
}

int tt__BackupFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BackupFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BackupFile(struct soap *soap, const char *tag, int id, const tt__BackupFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BackupFile), type))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Name", -1, &a->tt__BackupFile::Name, ""))
		return soap->error;
	if (!a->tt__BackupFile::Data)
	{	if (soap_element_empty(soap, "tt:Data", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AttachmentData(soap, "tt:Data", -1, &a->tt__BackupFile::Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BackupFile::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BackupFile(soap, tag, this, type);
}

SOAP_FMAC3 tt__BackupFile * SOAP_FMAC4 soap_in_tt__BackupFile(struct soap *soap, const char *tag, tt__BackupFile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BackupFile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BackupFile, sizeof(tt__BackupFile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BackupFile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BackupFile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Name", &a->tt__BackupFile::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Data", &a->tt__BackupFile::Data, "tt:AttachmentData"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || !a->tt__BackupFile::Data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BackupFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BackupFile, SOAP_TYPE_tt__BackupFile, sizeof(tt__BackupFile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BackupFile * SOAP_FMAC2 soap_instantiate_tt__BackupFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BackupFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BackupFile *p;
	size_t k = sizeof(tt__BackupFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BackupFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BackupFile);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BackupFile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BackupFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BackupFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BackupFile(soap, tag ? tag : "tt:BackupFile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BackupFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BackupFile(soap, this, tag, type);
}

SOAP_FMAC3 tt__BackupFile * SOAP_FMAC4 soap_get_tt__BackupFile(struct soap *soap, tt__BackupFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AttachmentData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default__xop__Include(soap, &this->tt__AttachmentData::xop__Include);
	soap_default_string(soap, &this->tt__AttachmentData::xmime__contentType);
}

void tt__AttachmentData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__xop__Include(soap, &this->tt__AttachmentData::xop__Include);
#endif
}

int tt__AttachmentData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AttachmentData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AttachmentData(struct soap *soap, const char *tag, int id, const tt__AttachmentData *a, const char *type)
{
	if (((tt__AttachmentData*)a)->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", soap_string2s(soap, ((tt__AttachmentData*)a)->xmime__contentType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AttachmentData), type))
		return soap->error;
	if (soap_out__xop__Include(soap, "xop:Include", -1, &a->tt__AttachmentData::xop__Include, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AttachmentData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AttachmentData(soap, tag, this, type);
}

SOAP_FMAC3 tt__AttachmentData * SOAP_FMAC4 soap_in_tt__AttachmentData(struct soap *soap, const char *tag, tt__AttachmentData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AttachmentData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AttachmentData, sizeof(tt__AttachmentData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AttachmentData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AttachmentData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 1, 0), &((tt__AttachmentData*)a)->xmime__contentType))
		return NULL;
	size_t soap_flag_xop__Include1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xop__Include1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__xop__Include(soap, "xop:Include", &a->tt__AttachmentData::xop__Include, ""))
				{	soap_flag_xop__Include1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xop__Include1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AttachmentData, SOAP_TYPE_tt__AttachmentData, sizeof(tt__AttachmentData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AttachmentData * SOAP_FMAC2 soap_instantiate_tt__AttachmentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AttachmentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AttachmentData *p;
	size_t k = sizeof(tt__AttachmentData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AttachmentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AttachmentData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AttachmentData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AttachmentData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AttachmentData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AttachmentData(soap, tag ? tag : "tt:AttachmentData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AttachmentData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AttachmentData(soap, this, tag, type);
}

SOAP_FMAC3 tt__AttachmentData * SOAP_FMAC4 soap_get_tt__AttachmentData(struct soap *soap, tt__AttachmentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BinaryData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__BinaryData::Data.xsd__base64Binary::soap_default(soap);
	soap_default_string(soap, &this->tt__BinaryData::xmime__contentType);
}

void tt__BinaryData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->tt__BinaryData::Data.soap_serialize(soap);
#endif
}

int tt__BinaryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BinaryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BinaryData(struct soap *soap, const char *tag, int id, const tt__BinaryData *a, const char *type)
{
	if (((tt__BinaryData*)a)->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", soap_string2s(soap, ((tt__BinaryData*)a)->xmime__contentType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BinaryData), type))
		return soap->error;
	if ((a->tt__BinaryData::Data).soap_out(soap, "tt:Data", -1, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BinaryData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BinaryData(soap, tag, this, type);
}

SOAP_FMAC3 tt__BinaryData * SOAP_FMAC4 soap_in_tt__BinaryData(struct soap *soap, const char *tag, tt__BinaryData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BinaryData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BinaryData, sizeof(tt__BinaryData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BinaryData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BinaryData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 1, 0), &((tt__BinaryData*)a)->xmime__contentType))
		return NULL;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->tt__BinaryData::Data).soap_in(soap, "tt:Data", "xsd:base64Binary"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BinaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BinaryData, SOAP_TYPE_tt__BinaryData, sizeof(tt__BinaryData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BinaryData * SOAP_FMAC2 soap_instantiate_tt__BinaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BinaryData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BinaryData *p;
	size_t k = sizeof(tt__BinaryData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BinaryData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BinaryData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BinaryData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BinaryData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BinaryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BinaryData(soap, tag ? tag : "tt:BinaryData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BinaryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BinaryData(soap, this, tag, type);
}

SOAP_FMAC3 tt__BinaryData * SOAP_FMAC4 soap_get_tt__BinaryData(struct soap *soap, tt__BinaryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SupportInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__SupportInformation::Binary = NULL;
	this->tt__SupportInformation::String = NULL;
}

void tt__SupportInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__SupportInformation::Binary);
	soap_serialize_PointerTostd__string(soap, &this->tt__SupportInformation::String);
#endif
}

int tt__SupportInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportInformation(struct soap *soap, const char *tag, int id, const tt__SupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportInformation), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->tt__SupportInformation::Binary, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:String", -1, &a->tt__SupportInformation::String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SupportInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SupportInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportInformation * SOAP_FMAC4 soap_in_tt__SupportInformation(struct soap *soap, const char *tag, tt__SupportInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportInformation, sizeof(tt__SupportInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SupportInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SupportInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Binary1 = 1;
	size_t soap_flag_String1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->tt__SupportInformation::Binary, "tt:AttachmentData"))
				{	soap_flag_Binary1--;
					continue;
				}
			}
			if (soap_flag_String1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:String", &a->tt__SupportInformation::String, "xsd:string"))
				{	soap_flag_String1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportInformation, SOAP_TYPE_tt__SupportInformation, sizeof(tt__SupportInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SupportInformation * SOAP_FMAC2 soap_instantiate_tt__SupportInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SupportInformation *p;
	size_t k = sizeof(tt__SupportInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SupportInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SupportInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SupportInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SupportInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SupportInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SupportInformation(soap, tag ? tag : "tt:SupportInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportInformation * SOAP_FMAC4 soap_get_tt__SupportInformation(struct soap *soap, tt__SupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__SystemLog::Binary = NULL;
	this->tt__SystemLog::String = NULL;
}

void tt__SystemLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__SystemLog::Binary);
	soap_serialize_PointerTostd__string(soap, &this->tt__SystemLog::String);
#endif
}

int tt__SystemLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLog(struct soap *soap, const char *tag, int id, const tt__SystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLog), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->tt__SystemLog::Binary, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:String", -1, &a->tt__SystemLog::String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemLog::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemLog(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLog * SOAP_FMAC4 soap_in_tt__SystemLog(struct soap *soap, const char *tag, tt__SystemLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemLog*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLog, sizeof(tt__SystemLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemLog)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemLog *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Binary1 = 1;
	size_t soap_flag_String1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->tt__SystemLog::Binary, "tt:AttachmentData"))
				{	soap_flag_Binary1--;
					continue;
				}
			}
			if (soap_flag_String1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:String", &a->tt__SystemLog::String, "xsd:string"))
				{	soap_flag_String1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLog, SOAP_TYPE_tt__SystemLog, sizeof(tt__SystemLog), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLog * SOAP_FMAC2 soap_instantiate_tt__SystemLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemLog *p;
	size_t k = sizeof(tt__SystemLog);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemLog, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemLog);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemLog, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemLog location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemLog(soap, tag ? tag : "tt:SystemLog", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLog(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLog * SOAP_FMAC4 soap_get_tt__SystemLog(struct soap *soap, tt__SystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsDeviceExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__AnalyticsDeviceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__AnalyticsDeviceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsDeviceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, int id, const tt__AnalyticsDeviceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsDeviceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsDeviceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, tt__AnalyticsDeviceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsDeviceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(tt__AnalyticsDeviceExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsDeviceExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsDeviceExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsDeviceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceExtension, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(tt__AnalyticsDeviceExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsDeviceExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsDeviceExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsDeviceExtension *p;
	size_t k = sizeof(tt__AnalyticsDeviceExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsDeviceExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsDeviceExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsDeviceExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsDeviceExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsDeviceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsDeviceExtension(soap, tag ? tag : "tt:AnalyticsDeviceExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsDeviceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsDeviceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsDeviceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__AnalyticsDeviceCapabilities::XAddr);
	this->tt__AnalyticsDeviceCapabilities::RuleSupport = NULL;
	this->tt__AnalyticsDeviceCapabilities::Extension = NULL;
}

void tt__AnalyticsDeviceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AnalyticsDeviceCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__AnalyticsDeviceCapabilities::XAddr);
	soap_serialize_PointerTobool(soap, &this->tt__AnalyticsDeviceCapabilities::RuleSupport);
	soap_serialize_PointerTott__AnalyticsDeviceExtension(soap, &this->tt__AnalyticsDeviceCapabilities::Extension);
#endif
}

int tt__AnalyticsDeviceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsDeviceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, int id, const tt__AnalyticsDeviceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__AnalyticsDeviceCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RuleSupport", -1, &a->tt__AnalyticsDeviceCapabilities::RuleSupport, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceExtension(soap, "tt:Extension", -1, &a->tt__AnalyticsDeviceCapabilities::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsDeviceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, tt__AnalyticsDeviceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsDeviceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(tt__AnalyticsDeviceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsDeviceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsDeviceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_RuleSupport1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__AnalyticsDeviceCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_RuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RuleSupport", &a->tt__AnalyticsDeviceCapabilities::RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceExtension(soap, "tt:Extension", &a->tt__AnalyticsDeviceCapabilities::Extension, "tt:AnalyticsDeviceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsDeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(tt__AnalyticsDeviceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsDeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsDeviceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsDeviceCapabilities *p;
	size_t k = sizeof(tt__AnalyticsDeviceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsDeviceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsDeviceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsDeviceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsDeviceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsDeviceCapabilities(soap, tag ? tag : "tt:AnalyticsDeviceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsDeviceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsDeviceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReceiverCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__ReceiverCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__ReceiverCapabilities::RTP_USCOREMulticast);
	soap_default_bool(soap, &this->tt__ReceiverCapabilities::RTP_USCORETCP);
	soap_default_bool(soap, &this->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP);
	soap_default_int(soap, &this->tt__ReceiverCapabilities::SupportedReceivers);
	soap_default_int(soap, &this->tt__ReceiverCapabilities::MaximumRTSPURILength);
}

void tt__ReceiverCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ReceiverCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ReceiverCapabilities::XAddr);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::RTP_USCOREMulticast, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::RTP_USCORETCP, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::SupportedReceivers, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::MaximumRTSPURILength, SOAP_TYPE_int);
#endif
}

int tt__ReceiverCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReceiverCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverCapabilities(struct soap *soap, const char *tag, int id, const tt__ReceiverCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__ReceiverCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RTP_Multicast", -1, &a->tt__ReceiverCapabilities::RTP_USCOREMulticast, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RTP_TCP", -1, &a->tt__ReceiverCapabilities::RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RTP_RTSP_TCP", -1, &a->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SupportedReceivers", -1, &a->tt__ReceiverCapabilities::SupportedReceivers, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumRTSPURILength", -1, &a->tt__ReceiverCapabilities::MaximumRTSPURILength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReceiverCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReceiverCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReceiverCapabilities * SOAP_FMAC4 soap_in_tt__ReceiverCapabilities(struct soap *soap, const char *tag, tt__ReceiverCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReceiverCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(tt__ReceiverCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReceiverCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReceiverCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_RTP_USCOREMulticast1 = 1;
	size_t soap_flag_RTP_USCORETCP1 = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP1 = 1;
	size_t soap_flag_SupportedReceivers1 = 1;
	size_t soap_flag_MaximumRTSPURILength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__ReceiverCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCOREMulticast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RTP_Multicast", &a->tt__ReceiverCapabilities::RTP_USCOREMulticast, "xsd:boolean"))
				{	soap_flag_RTP_USCOREMulticast1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RTP_TCP", &a->tt__ReceiverCapabilities::RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORERTSP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RTP_RTSP_TCP", &a->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_SupportedReceivers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:SupportedReceivers", &a->tt__ReceiverCapabilities::SupportedReceivers, "xsd:int"))
				{	soap_flag_SupportedReceivers1--;
					continue;
				}
			}
			if (soap_flag_MaximumRTSPURILength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumRTSPURILength", &a->tt__ReceiverCapabilities::MaximumRTSPURILength, "xsd:int"))
				{	soap_flag_MaximumRTSPURILength1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_RTP_USCOREMulticast1 > 0 || soap_flag_RTP_USCORETCP1 > 0 || soap_flag_RTP_USCORERTSP_USCORETCP1 > 0 || soap_flag_SupportedReceivers1 > 0 || soap_flag_MaximumRTSPURILength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ReceiverCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverCapabilities, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(tt__ReceiverCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReceiverCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReceiverCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReceiverCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReceiverCapabilities *p;
	size_t k = sizeof(tt__ReceiverCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReceiverCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReceiverCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReceiverCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReceiverCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReceiverCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReceiverCapabilities(soap, tag ? tag : "tt:ReceiverCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReceiverCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReceiverCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReceiverCapabilities * SOAP_FMAC4 soap_get_tt__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReplayCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__ReplayCapabilities::XAddr);
}

void tt__ReplayCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ReplayCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ReplayCapabilities::XAddr);
#endif
}

int tt__ReplayCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReplayCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReplayCapabilities(struct soap *soap, const char *tag, int id, const tt__ReplayCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReplayCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__ReplayCapabilities::XAddr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReplayCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReplayCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReplayCapabilities * SOAP_FMAC4 soap_in_tt__ReplayCapabilities(struct soap *soap, const char *tag, tt__ReplayCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReplayCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(tt__ReplayCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReplayCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReplayCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__ReplayCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ReplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayCapabilities, SOAP_TYPE_tt__ReplayCapabilities, sizeof(tt__ReplayCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReplayCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReplayCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReplayCapabilities *p;
	size_t k = sizeof(tt__ReplayCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReplayCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReplayCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReplayCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReplayCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReplayCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReplayCapabilities(soap, tag ? tag : "tt:ReplayCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReplayCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReplayCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReplayCapabilities * SOAP_FMAC4 soap_get_tt__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SearchCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__SearchCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__SearchCapabilities::MetadataSearch);
}

void tt__SearchCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SearchCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__SearchCapabilities::XAddr);
	soap_embedded(soap, &this->tt__SearchCapabilities::MetadataSearch, SOAP_TYPE_bool);
#endif
}

int tt__SearchCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SearchCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchCapabilities(struct soap *soap, const char *tag, int id, const tt__SearchCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__SearchCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:MetadataSearch", -1, &a->tt__SearchCapabilities::MetadataSearch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SearchCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SearchCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SearchCapabilities * SOAP_FMAC4 soap_in_tt__SearchCapabilities(struct soap *soap, const char *tag, tt__SearchCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SearchCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchCapabilities, sizeof(tt__SearchCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SearchCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SearchCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_MetadataSearch1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__SearchCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_MetadataSearch1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:MetadataSearch", &a->tt__SearchCapabilities::MetadataSearch, "xsd:boolean"))
				{	soap_flag_MetadataSearch1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_MetadataSearch1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SearchCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchCapabilities, SOAP_TYPE_tt__SearchCapabilities, sizeof(tt__SearchCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SearchCapabilities * SOAP_FMAC2 soap_instantiate_tt__SearchCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SearchCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SearchCapabilities *p;
	size_t k = sizeof(tt__SearchCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SearchCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SearchCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SearchCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SearchCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SearchCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SearchCapabilities(soap, tag ? tag : "tt:SearchCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SearchCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SearchCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SearchCapabilities * SOAP_FMAC4 soap_get_tt__SearchCapabilities(struct soap *soap, tt__SearchCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__RecordingCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::ReceiverSource);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::MediaProfileSource);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::DynamicRecordings);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::DynamicTracks);
	soap_default_int(soap, &this->tt__RecordingCapabilities::MaxStringLength);
}

void tt__RecordingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RecordingCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__RecordingCapabilities::XAddr);
	soap_embedded(soap, &this->tt__RecordingCapabilities::ReceiverSource, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::MediaProfileSource, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::DynamicRecordings, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::DynamicTracks, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::MaxStringLength, SOAP_TYPE_int);
#endif
}

int tt__RecordingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingCapabilities(struct soap *soap, const char *tag, int id, const tt__RecordingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__RecordingCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:ReceiverSource", -1, &a->tt__RecordingCapabilities::ReceiverSource, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:MediaProfileSource", -1, &a->tt__RecordingCapabilities::MediaProfileSource, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DynamicRecordings", -1, &a->tt__RecordingCapabilities::DynamicRecordings, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DynamicTracks", -1, &a->tt__RecordingCapabilities::DynamicTracks, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaxStringLength", -1, &a->tt__RecordingCapabilities::MaxStringLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingCapabilities * SOAP_FMAC4 soap_in_tt__RecordingCapabilities(struct soap *soap, const char *tag, tt__RecordingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(tt__RecordingCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_ReceiverSource1 = 1;
	size_t soap_flag_MediaProfileSource1 = 1;
	size_t soap_flag_DynamicRecordings1 = 1;
	size_t soap_flag_DynamicTracks1 = 1;
	size_t soap_flag_MaxStringLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__RecordingCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_ReceiverSource1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:ReceiverSource", &a->tt__RecordingCapabilities::ReceiverSource, "xsd:boolean"))
				{	soap_flag_ReceiverSource1--;
					continue;
				}
			}
			if (soap_flag_MediaProfileSource1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:MediaProfileSource", &a->tt__RecordingCapabilities::MediaProfileSource, "xsd:boolean"))
				{	soap_flag_MediaProfileSource1--;
					continue;
				}
			}
			if (soap_flag_DynamicRecordings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DynamicRecordings", &a->tt__RecordingCapabilities::DynamicRecordings, "xsd:boolean"))
				{	soap_flag_DynamicRecordings1--;
					continue;
				}
			}
			if (soap_flag_DynamicTracks1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DynamicTracks", &a->tt__RecordingCapabilities::DynamicTracks, "xsd:boolean"))
				{	soap_flag_DynamicTracks1--;
					continue;
				}
			}
			if (soap_flag_MaxStringLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaxStringLength", &a->tt__RecordingCapabilities::MaxStringLength, "xsd:int"))
				{	soap_flag_MaxStringLength1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_ReceiverSource1 > 0 || soap_flag_MediaProfileSource1 > 0 || soap_flag_DynamicRecordings1 > 0 || soap_flag_DynamicTracks1 > 0 || soap_flag_MaxStringLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingCapabilities, SOAP_TYPE_tt__RecordingCapabilities, sizeof(tt__RecordingCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RecordingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingCapabilities *p;
	size_t k = sizeof(tt__RecordingCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingCapabilities(soap, tag ? tag : "tt:RecordingCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingCapabilities * SOAP_FMAC4 soap_get_tt__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DisplayCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__DisplayCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__DisplayCapabilities::FixedLayout);
}

void tt__DisplayCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DisplayCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__DisplayCapabilities::XAddr);
	soap_embedded(soap, &this->tt__DisplayCapabilities::FixedLayout, SOAP_TYPE_bool);
#endif
}

int tt__DisplayCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DisplayCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DisplayCapabilities(struct soap *soap, const char *tag, int id, const tt__DisplayCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DisplayCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__DisplayCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:FixedLayout", -1, &a->tt__DisplayCapabilities::FixedLayout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DisplayCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DisplayCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__DisplayCapabilities * SOAP_FMAC4 soap_in_tt__DisplayCapabilities(struct soap *soap, const char *tag, tt__DisplayCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DisplayCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(tt__DisplayCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DisplayCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DisplayCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_FixedLayout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__DisplayCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_FixedLayout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FixedLayout", &a->tt__DisplayCapabilities::FixedLayout, "xsd:boolean"))
				{	soap_flag_FixedLayout1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_FixedLayout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DisplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DisplayCapabilities, SOAP_TYPE_tt__DisplayCapabilities, sizeof(tt__DisplayCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DisplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__DisplayCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DisplayCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DisplayCapabilities *p;
	size_t k = sizeof(tt__DisplayCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DisplayCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DisplayCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DisplayCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DisplayCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DisplayCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DisplayCapabilities(soap, tag ? tag : "tt:DisplayCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DisplayCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DisplayCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__DisplayCapabilities * SOAP_FMAC4 soap_get_tt__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceIOCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__DeviceIOCapabilities::XAddr);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::VideoSources);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::VideoOutputs);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::AudioSources);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::AudioOutputs);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::RelayOutputs);
}

void tt__DeviceIOCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__DeviceIOCapabilities::XAddr);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::VideoSources, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::VideoOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::AudioSources, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::AudioOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::RelayOutputs, SOAP_TYPE_int);
#endif
}

int tt__DeviceIOCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceIOCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, const tt__DeviceIOCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceIOCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__DeviceIOCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoSources", -1, &a->tt__DeviceIOCapabilities::VideoSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoOutputs", -1, &a->tt__DeviceIOCapabilities::VideoOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioSources", -1, &a->tt__DeviceIOCapabilities::AudioSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioOutputs", -1, &a->tt__DeviceIOCapabilities::AudioOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:RelayOutputs", -1, &a->tt__DeviceIOCapabilities::RelayOutputs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceIOCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceIOCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceIOCapabilities * SOAP_FMAC4 soap_in_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, tt__DeviceIOCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceIOCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(tt__DeviceIOCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceIOCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceIOCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_VideoSources1 = 1;
	size_t soap_flag_VideoOutputs1 = 1;
	size_t soap_flag_AudioSources1 = 1;
	size_t soap_flag_AudioOutputs1 = 1;
	size_t soap_flag_RelayOutputs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__DeviceIOCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_VideoSources1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:VideoSources", &a->tt__DeviceIOCapabilities::VideoSources, "xsd:int"))
				{	soap_flag_VideoSources1--;
					continue;
				}
			}
			if (soap_flag_VideoOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:VideoOutputs", &a->tt__DeviceIOCapabilities::VideoOutputs, "xsd:int"))
				{	soap_flag_VideoOutputs1--;
					continue;
				}
			}
			if (soap_flag_AudioSources1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:AudioSources", &a->tt__DeviceIOCapabilities::AudioSources, "xsd:int"))
				{	soap_flag_AudioSources1--;
					continue;
				}
			}
			if (soap_flag_AudioOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:AudioOutputs", &a->tt__DeviceIOCapabilities::AudioOutputs, "xsd:int"))
				{	soap_flag_AudioOutputs1--;
					continue;
				}
			}
			if (soap_flag_RelayOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:RelayOutputs", &a->tt__DeviceIOCapabilities::RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_VideoSources1 > 0 || soap_flag_VideoOutputs1 > 0 || soap_flag_AudioSources1 > 0 || soap_flag_AudioOutputs1 > 0 || soap_flag_RelayOutputs1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DeviceIOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceIOCapabilities, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(tt__DeviceIOCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceIOCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceIOCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceIOCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceIOCapabilities *p;
	size_t k = sizeof(tt__DeviceIOCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceIOCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceIOCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceIOCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceIOCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceIOCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceIOCapabilities(soap, tag ? tag : "tt:DeviceIOCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceIOCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceIOCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceIOCapabilities * SOAP_FMAC4 soap_get_tt__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__PTZCapabilities::XAddr);
}

void tt__PTZCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__PTZCapabilities::XAddr);
#endif
}

int tt__PTZCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZCapabilities(struct soap *soap, const char *tag, int id, const tt__PTZCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__PTZCapabilities::XAddr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZCapabilities * SOAP_FMAC4 soap_in_tt__PTZCapabilities(struct soap *soap, const char *tag, tt__PTZCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZCapabilities, sizeof(tt__PTZCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__PTZCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZCapabilities, SOAP_TYPE_tt__PTZCapabilities, sizeof(tt__PTZCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZCapabilities * SOAP_FMAC2 soap_instantiate_tt__PTZCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZCapabilities *p;
	size_t k = sizeof(tt__PTZCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZCapabilities(soap, tag ? tag : "tt:PTZCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZCapabilities * SOAP_FMAC4 soap_get_tt__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__ImagingCapabilities::XAddr);
}

void tt__ImagingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ImagingCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ImagingCapabilities::XAddr);
#endif
}

int tt__ImagingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingCapabilities(struct soap *soap, const char *tag, int id, const tt__ImagingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__ImagingCapabilities::XAddr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingCapabilities * SOAP_FMAC4 soap_in_tt__ImagingCapabilities(struct soap *soap, const char *tag, tt__ImagingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__ImagingCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImagingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingCapabilities, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingCapabilities * SOAP_FMAC2 soap_instantiate_tt__ImagingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingCapabilities *p;
	size_t k = sizeof(tt__ImagingCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingCapabilities(soap, tag ? tag : "tt:ImagingCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingCapabilities * SOAP_FMAC4 soap_get_tt__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OnvifVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__OnvifVersion::Major);
	soap_default_int(soap, &this->tt__OnvifVersion::Minor);
}

void tt__OnvifVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OnvifVersion::Major, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__OnvifVersion::Minor, SOAP_TYPE_int);
#endif
}

int tt__OnvifVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OnvifVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OnvifVersion(struct soap *soap, const char *tag, int id, const tt__OnvifVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OnvifVersion), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Major", -1, &a->tt__OnvifVersion::Major, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minor", -1, &a->tt__OnvifVersion::Minor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OnvifVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OnvifVersion(soap, tag, this, type);
}

SOAP_FMAC3 tt__OnvifVersion * SOAP_FMAC4 soap_in_tt__OnvifVersion(struct soap *soap, const char *tag, tt__OnvifVersion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OnvifVersion*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OnvifVersion, sizeof(tt__OnvifVersion), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OnvifVersion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OnvifVersion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Major1 = 1;
	size_t soap_flag_Minor1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Major1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Major", &a->tt__OnvifVersion::Major, "xsd:int"))
				{	soap_flag_Major1--;
					continue;
				}
			}
			if (soap_flag_Minor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Minor", &a->tt__OnvifVersion::Minor, "xsd:int"))
				{	soap_flag_Minor1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Major1 > 0 || soap_flag_Minor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_tt__OnvifVersion, sizeof(tt__OnvifVersion), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OnvifVersion * SOAP_FMAC2 soap_instantiate_tt__OnvifVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OnvifVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OnvifVersion *p;
	size_t k = sizeof(tt__OnvifVersion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OnvifVersion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OnvifVersion);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OnvifVersion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OnvifVersion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OnvifVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OnvifVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OnvifVersion(soap, this, tag, type);
}

SOAP_FMAC3 tt__OnvifVersion * SOAP_FMAC4 soap_get_tt__OnvifVersion(struct soap *soap, tt__OnvifVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemCapabilitiesExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__SystemCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__SystemCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(tt__SystemCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemCapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension2, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(tt__SystemCapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__SystemCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemCapabilitiesExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemCapabilitiesExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemCapabilitiesExtension2(soap, tag ? tag : "tt:SystemCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade = NULL;
	this->tt__SystemCapabilitiesExtension::HttpSystemBackup = NULL;
	this->tt__SystemCapabilitiesExtension::HttpSystemLogging = NULL;
	this->tt__SystemCapabilitiesExtension::HttpSupportInformation = NULL;
	this->tt__SystemCapabilitiesExtension::Extension = NULL;
}

void tt__SystemCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade);
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpSystemBackup);
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpSystemLogging);
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpSupportInformation);
	soap_serialize_PointerTott__SystemCapabilitiesExtension2(soap, &this->tt__SystemCapabilitiesExtension::Extension);
#endif
}

int tt__SystemCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__SystemCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpFirmwareUpgrade", -1, &a->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpSystemBackup", -1, &a->tt__SystemCapabilitiesExtension::HttpSystemBackup, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpSystemLogging", -1, &a->tt__SystemCapabilitiesExtension::HttpSystemLogging, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpSupportInformation", -1, &a->tt__SystemCapabilitiesExtension::HttpSupportInformation, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__SystemCapabilitiesExtension::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(tt__SystemCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HttpFirmwareUpgrade1 = 1;
	size_t soap_flag_HttpSystemBackup1 = 1;
	size_t soap_flag_HttpSystemLogging1 = 1;
	size_t soap_flag_HttpSupportInformation1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HttpFirmwareUpgrade1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpFirmwareUpgrade", &a->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_HttpFirmwareUpgrade1--;
					continue;
				}
			}
			if (soap_flag_HttpSystemBackup1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpSystemBackup", &a->tt__SystemCapabilitiesExtension::HttpSystemBackup, "xsd:boolean"))
				{	soap_flag_HttpSystemBackup1--;
					continue;
				}
			}
			if (soap_flag_HttpSystemLogging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpSystemLogging", &a->tt__SystemCapabilitiesExtension::HttpSystemLogging, "xsd:boolean"))
				{	soap_flag_HttpSystemLogging1--;
					continue;
				}
			}
			if (soap_flag_HttpSupportInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpSupportInformation", &a->tt__SystemCapabilitiesExtension::HttpSupportInformation, "xsd:boolean"))
				{	soap_flag_HttpSupportInformation1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", &a->tt__SystemCapabilitiesExtension::Extension, "tt:SystemCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(tt__SystemCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemCapabilitiesExtension *p;
	size_t k = sizeof(tt__SystemCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemCapabilitiesExtension(soap, tag ? tag : "tt:SystemCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__SystemCapabilities::DiscoveryResolve);
	soap_default_bool(soap, &this->tt__SystemCapabilities::DiscoveryBye);
	soap_default_bool(soap, &this->tt__SystemCapabilities::RemoteDiscovery);
	soap_default_bool(soap, &this->tt__SystemCapabilities::SystemBackup);
	soap_default_bool(soap, &this->tt__SystemCapabilities::SystemLogging);
	soap_default_bool(soap, &this->tt__SystemCapabilities::FirmwareUpgrade);
	soap_default_std__vectorTemplateOfPointerTott__OnvifVersion(soap, &this->tt__SystemCapabilities::SupportedVersions);
	this->tt__SystemCapabilities::Extension = NULL;
}

void tt__SystemCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SystemCapabilities::DiscoveryResolve, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::DiscoveryBye, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::RemoteDiscovery, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::SystemBackup, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::SystemLogging, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::FirmwareUpgrade, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__OnvifVersion(soap, &this->tt__SystemCapabilities::SupportedVersions);
	soap_serialize_PointerTott__SystemCapabilitiesExtension(soap, &this->tt__SystemCapabilities::Extension);
#endif
}

int tt__SystemCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilities(struct soap *soap, const char *tag, int id, const tt__SystemCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilities), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:DiscoveryResolve", -1, &a->tt__SystemCapabilities::DiscoveryResolve, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DiscoveryBye", -1, &a->tt__SystemCapabilities::DiscoveryBye, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RemoteDiscovery", -1, &a->tt__SystemCapabilities::RemoteDiscovery, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SystemBackup", -1, &a->tt__SystemCapabilities::SystemBackup, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SystemLogging", -1, &a->tt__SystemCapabilities::SystemLogging, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:FirmwareUpgrade", -1, &a->tt__SystemCapabilities::FirmwareUpgrade, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__OnvifVersion(soap, "tt:SupportedVersions", -1, &a->tt__SystemCapabilities::SupportedVersions, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__SystemCapabilities::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilities * SOAP_FMAC4 soap_in_tt__SystemCapabilities(struct soap *soap, const char *tag, tt__SystemCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilities, sizeof(tt__SystemCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DiscoveryResolve1 = 1;
	size_t soap_flag_DiscoveryBye1 = 1;
	size_t soap_flag_RemoteDiscovery1 = 1;
	size_t soap_flag_SystemBackup1 = 1;
	size_t soap_flag_SystemLogging1 = 1;
	size_t soap_flag_FirmwareUpgrade1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryResolve1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DiscoveryResolve", &a->tt__SystemCapabilities::DiscoveryResolve, "xsd:boolean"))
				{	soap_flag_DiscoveryResolve1--;
					continue;
				}
			}
			if (soap_flag_DiscoveryBye1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DiscoveryBye", &a->tt__SystemCapabilities::DiscoveryBye, "xsd:boolean"))
				{	soap_flag_DiscoveryBye1--;
					continue;
				}
			}
			if (soap_flag_RemoteDiscovery1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RemoteDiscovery", &a->tt__SystemCapabilities::RemoteDiscovery, "xsd:boolean"))
				{	soap_flag_RemoteDiscovery1--;
					continue;
				}
			}
			if (soap_flag_SystemBackup1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:SystemBackup", &a->tt__SystemCapabilities::SystemBackup, "xsd:boolean"))
				{	soap_flag_SystemBackup1--;
					continue;
				}
			}
			if (soap_flag_SystemLogging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:SystemLogging", &a->tt__SystemCapabilities::SystemLogging, "xsd:boolean"))
				{	soap_flag_SystemLogging1--;
					continue;
				}
			}
			if (soap_flag_FirmwareUpgrade1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FirmwareUpgrade", &a->tt__SystemCapabilities::FirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_FirmwareUpgrade1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__OnvifVersion(soap, "tt:SupportedVersions", &a->tt__SystemCapabilities::SupportedVersions, "tt:OnvifVersion"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", &a->tt__SystemCapabilities::Extension, "tt:SystemCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryResolve1 > 0 || soap_flag_DiscoveryBye1 > 0 || soap_flag_RemoteDiscovery1 > 0 || soap_flag_SystemBackup1 > 0 || soap_flag_SystemLogging1 > 0 || soap_flag_FirmwareUpgrade1 > 0 || a->tt__SystemCapabilities::SupportedVersions.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilities, SOAP_TYPE_tt__SystemCapabilities, sizeof(tt__SystemCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemCapabilities *p;
	size_t k = sizeof(tt__SystemCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemCapabilities(soap, tag ? tag : "tt:SystemCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilities * SOAP_FMAC4 soap_get_tt__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SecurityCapabilitiesExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__SecurityCapabilitiesExtension2::Dot1X);
	soap_default_std__vectorTemplateOfint(soap, &this->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod);
	soap_default_bool(soap, &this->tt__SecurityCapabilitiesExtension2::RemoteUserHandling);
}

void tt__SecurityCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SecurityCapabilitiesExtension2::Dot1X, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfint(soap, &this->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod);
	soap_embedded(soap, &this->tt__SecurityCapabilitiesExtension2::RemoteUserHandling, SOAP_TYPE_bool);
#endif
}

int tt__SecurityCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Dot1X", -1, &a->tt__SecurityCapabilitiesExtension2::Dot1X, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "tt:SupportedEAPMethod", -1, &a->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RemoteUserHandling", -1, &a->tt__SecurityCapabilitiesExtension2::RemoteUserHandling, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(tt__SecurityCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SecurityCapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SecurityCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1X1 = 1;
	size_t soap_flag_RemoteUserHandling1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1X1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Dot1X", &a->tt__SecurityCapabilitiesExtension2::Dot1X, "xsd:boolean"))
				{	soap_flag_Dot1X1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfint(soap, "tt:SupportedEAPMethod", &a->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod, "xsd:int"))
					continue;
			}
			if (soap_flag_RemoteUserHandling1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RemoteUserHandling", &a->tt__SecurityCapabilitiesExtension2::RemoteUserHandling, "xsd:boolean"))
				{	soap_flag_RemoteUserHandling1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1X1 > 0 || soap_flag_RemoteUserHandling1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(tt__SecurityCapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SecurityCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__SecurityCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SecurityCapabilitiesExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SecurityCapabilitiesExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SecurityCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SecurityCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SecurityCapabilitiesExtension2(soap, tag ? tag : "tt:SecurityCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SecurityCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__SecurityCapabilitiesExtension::TLS1_x002e0);
	this->tt__SecurityCapabilitiesExtension::Extension = NULL;
}

void tt__SecurityCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SecurityCapabilitiesExtension::TLS1_x002e0, SOAP_TYPE_bool);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension2(soap, &this->tt__SecurityCapabilitiesExtension::Extension);
#endif
}

int tt__SecurityCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.0", -1, &a->tt__SecurityCapabilitiesExtension::TLS1_x002e0, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__SecurityCapabilitiesExtension::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SecurityCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(tt__SecurityCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SecurityCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SecurityCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TLS1_x002e01 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TLS1.0", &a->tt__SecurityCapabilitiesExtension::TLS1_x002e0, "xsd:boolean"))
				{	soap_flag_TLS1_x002e01--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", &a->tt__SecurityCapabilitiesExtension::Extension, "tt:SecurityCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(tt__SecurityCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SecurityCapabilitiesExtension *p;
	size_t k = sizeof(tt__SecurityCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SecurityCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SecurityCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SecurityCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SecurityCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SecurityCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SecurityCapabilitiesExtension(soap, tag ? tag : "tt:SecurityCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SecurityCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__SecurityCapabilities::TLS1_x002e1);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::TLS1_x002e2);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::OnboardKeyGeneration);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::AccessPolicyConfig);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::X_x002e509Token);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::SAMLToken);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::KerberosToken);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::RELToken);
	this->tt__SecurityCapabilities::Extension = NULL;
}

void tt__SecurityCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SecurityCapabilities::TLS1_x002e1, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::TLS1_x002e2, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::OnboardKeyGeneration, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::AccessPolicyConfig, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::X_x002e509Token, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::SAMLToken, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::KerberosToken, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::RELToken, SOAP_TYPE_bool);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension(soap, &this->tt__SecurityCapabilities::Extension);
#endif
}

int tt__SecurityCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilities(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilities), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.1", -1, &a->tt__SecurityCapabilities::TLS1_x002e1, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.2", -1, &a->tt__SecurityCapabilities::TLS1_x002e2, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:OnboardKeyGeneration", -1, &a->tt__SecurityCapabilities::OnboardKeyGeneration, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AccessPolicyConfig", -1, &a->tt__SecurityCapabilities::AccessPolicyConfig, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:X.509Token", -1, &a->tt__SecurityCapabilities::X_x002e509Token, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SAMLToken", -1, &a->tt__SecurityCapabilities::SAMLToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:KerberosToken", -1, &a->tt__SecurityCapabilities::KerberosToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RELToken", -1, &a->tt__SecurityCapabilities::RELToken, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__SecurityCapabilities::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SecurityCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilities * SOAP_FMAC4 soap_in_tt__SecurityCapabilities(struct soap *soap, const char *tag, tt__SecurityCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(tt__SecurityCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SecurityCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SecurityCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TLS1_x002e11 = 1;
	size_t soap_flag_TLS1_x002e21 = 1;
	size_t soap_flag_OnboardKeyGeneration1 = 1;
	size_t soap_flag_AccessPolicyConfig1 = 1;
	size_t soap_flag_X_x002e509Token1 = 1;
	size_t soap_flag_SAMLToken1 = 1;
	size_t soap_flag_KerberosToken1 = 1;
	size_t soap_flag_RELToken1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TLS1.1", &a->tt__SecurityCapabilities::TLS1_x002e1, "xsd:boolean"))
				{	soap_flag_TLS1_x002e11--;
					continue;
				}
			}
			if (soap_flag_TLS1_x002e21 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TLS1.2", &a->tt__SecurityCapabilities::TLS1_x002e2, "xsd:boolean"))
				{	soap_flag_TLS1_x002e21--;
					continue;
				}
			}
			if (soap_flag_OnboardKeyGeneration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:OnboardKeyGeneration", &a->tt__SecurityCapabilities::OnboardKeyGeneration, "xsd:boolean"))
				{	soap_flag_OnboardKeyGeneration1--;
					continue;
				}
			}
			if (soap_flag_AccessPolicyConfig1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AccessPolicyConfig", &a->tt__SecurityCapabilities::AccessPolicyConfig, "xsd:boolean"))
				{	soap_flag_AccessPolicyConfig1--;
					continue;
				}
			}
			if (soap_flag_X_x002e509Token1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:X.509Token", &a->tt__SecurityCapabilities::X_x002e509Token, "xsd:boolean"))
				{	soap_flag_X_x002e509Token1--;
					continue;
				}
			}
			if (soap_flag_SAMLToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:SAMLToken", &a->tt__SecurityCapabilities::SAMLToken, "xsd:boolean"))
				{	soap_flag_SAMLToken1--;
					continue;
				}
			}
			if (soap_flag_KerberosToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:KerberosToken", &a->tt__SecurityCapabilities::KerberosToken, "xsd:boolean"))
				{	soap_flag_KerberosToken1--;
					continue;
				}
			}
			if (soap_flag_RELToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RELToken", &a->tt__SecurityCapabilities::RELToken, "xsd:boolean"))
				{	soap_flag_RELToken1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", &a->tt__SecurityCapabilities::Extension, "tt:SecurityCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e11 > 0 || soap_flag_TLS1_x002e21 > 0 || soap_flag_OnboardKeyGeneration1 > 0 || soap_flag_AccessPolicyConfig1 > 0 || soap_flag_X_x002e509Token1 > 0 || soap_flag_SAMLToken1 > 0 || soap_flag_KerberosToken1 > 0 || soap_flag_RELToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilities, SOAP_TYPE_tt__SecurityCapabilities, sizeof(tt__SecurityCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SecurityCapabilities *p;
	size_t k = sizeof(tt__SecurityCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SecurityCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SecurityCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SecurityCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SecurityCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SecurityCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SecurityCapabilities(soap, tag ? tag : "tt:SecurityCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilities * SOAP_FMAC4 soap_get_tt__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkCapabilitiesExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__NetworkCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__NetworkCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(tt__NetworkCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkCapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(tt__NetworkCapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__NetworkCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkCapabilitiesExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkCapabilitiesExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkCapabilitiesExtension2(soap, tag ? tag : "tt:NetworkCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__NetworkCapabilitiesExtension::Dot11Configuration = NULL;
	this->tt__NetworkCapabilitiesExtension::Extension = NULL;
}

void tt__NetworkCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilitiesExtension::Dot11Configuration);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension2(soap, &this->tt__NetworkCapabilitiesExtension::Extension);
#endif
}

int tt__NetworkCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Dot11Configuration", -1, &a->tt__NetworkCapabilitiesExtension::Dot11Configuration, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__NetworkCapabilitiesExtension::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(tt__NetworkCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot11Configuration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot11Configuration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Dot11Configuration", &a->tt__NetworkCapabilitiesExtension::Dot11Configuration, "xsd:boolean"))
				{	soap_flag_Dot11Configuration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", &a->tt__NetworkCapabilitiesExtension::Extension, "tt:NetworkCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(tt__NetworkCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkCapabilitiesExtension *p;
	size_t k = sizeof(tt__NetworkCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkCapabilitiesExtension(soap, tag ? tag : "tt:NetworkCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__NetworkCapabilities::IPFilter = NULL;
	this->tt__NetworkCapabilities::ZeroConfiguration = NULL;
	this->tt__NetworkCapabilities::IPVersion6 = NULL;
	this->tt__NetworkCapabilities::DynDNS = NULL;
	this->tt__NetworkCapabilities::Extension = NULL;
}

void tt__NetworkCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::IPFilter);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::ZeroConfiguration);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::IPVersion6);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::DynDNS);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension(soap, &this->tt__NetworkCapabilities::Extension);
#endif
}

int tt__NetworkCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilities(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilities), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:IPFilter", -1, &a->tt__NetworkCapabilities::IPFilter, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:ZeroConfiguration", -1, &a->tt__NetworkCapabilities::ZeroConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:IPVersion6", -1, &a->tt__NetworkCapabilities::IPVersion6, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:DynDNS", -1, &a->tt__NetworkCapabilities::DynDNS, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__NetworkCapabilities::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilities * SOAP_FMAC4 soap_in_tt__NetworkCapabilities(struct soap *soap, const char *tag, tt__NetworkCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(tt__NetworkCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPFilter1 = 1;
	size_t soap_flag_ZeroConfiguration1 = 1;
	size_t soap_flag_IPVersion61 = 1;
	size_t soap_flag_DynDNS1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:IPFilter", &a->tt__NetworkCapabilities::IPFilter, "xsd:boolean"))
				{	soap_flag_IPFilter1--;
					continue;
				}
			}
			if (soap_flag_ZeroConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:ZeroConfiguration", &a->tt__NetworkCapabilities::ZeroConfiguration, "xsd:boolean"))
				{	soap_flag_ZeroConfiguration1--;
					continue;
				}
			}
			if (soap_flag_IPVersion61 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:IPVersion6", &a->tt__NetworkCapabilities::IPVersion6, "xsd:boolean"))
				{	soap_flag_IPVersion61--;
					continue;
				}
			}
			if (soap_flag_DynDNS1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:DynDNS", &a->tt__NetworkCapabilities::DynDNS, "xsd:boolean"))
				{	soap_flag_DynDNS1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", &a->tt__NetworkCapabilities::Extension, "tt:NetworkCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilities, SOAP_TYPE_tt__NetworkCapabilities, sizeof(tt__NetworkCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkCapabilities *p;
	size_t k = sizeof(tt__NetworkCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkCapabilities(soap, tag ? tag : "tt:NetworkCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilities * SOAP_FMAC4 soap_get_tt__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ProfileCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__ProfileCapabilities::MaximumNumberOfProfiles);
}

void tt__ProfileCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ProfileCapabilities::MaximumNumberOfProfiles, SOAP_TYPE_int);
#endif
}

int tt__ProfileCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const tt__ProfileCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileCapabilities), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfProfiles", -1, &a->tt__ProfileCapabilities::MaximumNumberOfProfiles, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ProfileCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileCapabilities * SOAP_FMAC4 soap_in_tt__ProfileCapabilities(struct soap *soap, const char *tag, tt__ProfileCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(tt__ProfileCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ProfileCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ProfileCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MaximumNumberOfProfiles1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfProfiles1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfProfiles", &a->tt__ProfileCapabilities::MaximumNumberOfProfiles, "xsd:int"))
				{	soap_flag_MaximumNumberOfProfiles1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfProfiles1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileCapabilities, SOAP_TYPE_tt__ProfileCapabilities, sizeof(tt__ProfileCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_tt__ProfileCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ProfileCapabilities *p;
	size_t k = sizeof(tt__ProfileCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ProfileCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ProfileCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ProfileCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ProfileCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ProfileCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ProfileCapabilities(soap, tag ? tag : "tt:ProfileCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileCapabilities * SOAP_FMAC4 soap_get_tt__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RealTimeStreamingCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__RealTimeStreamingCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__RealTimeStreamingCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RealTimeStreamingCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RealTimeStreamingCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(tt__RealTimeStreamingCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RealTimeStreamingCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RealTimeStreamingCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(tt__RealTimeStreamingCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RealTimeStreamingCapabilitiesExtension *p;
	size_t k = sizeof(tt__RealTimeStreamingCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RealTimeStreamingCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RealTimeStreamingCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RealTimeStreamingCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RealTimeStreamingCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag ? tag : "tt:RealTimeStreamingCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RealTimeStreamingCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RealTimeStreamingCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RealTimeStreamingCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__RealTimeStreamingCapabilities::RTPMulticast = NULL;
	this->tt__RealTimeStreamingCapabilities::RTP_USCORETCP = NULL;
	this->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP = NULL;
	this->tt__RealTimeStreamingCapabilities::Extension = NULL;
}

void tt__RealTimeStreamingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTPMulticast);
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTP_USCORETCP);
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP);
	soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, &this->tt__RealTimeStreamingCapabilities::Extension);
#endif
}

int tt__RealTimeStreamingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RealTimeStreamingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, const tt__RealTimeStreamingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTPMulticast", -1, &a->tt__RealTimeStreamingCapabilities::RTPMulticast, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTP_TCP", -1, &a->tt__RealTimeStreamingCapabilities::RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTP_RTSP_TCP", -1, &a->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__RealTimeStreamingCapabilities::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RealTimeStreamingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RealTimeStreamingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RealTimeStreamingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(tt__RealTimeStreamingCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RealTimeStreamingCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RealTimeStreamingCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RTPMulticast1 = 1;
	size_t soap_flag_RTP_USCORETCP1 = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RTPMulticast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RTPMulticast", &a->tt__RealTimeStreamingCapabilities::RTPMulticast, "xsd:boolean"))
				{	soap_flag_RTPMulticast1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RTP_TCP", &a->tt__RealTimeStreamingCapabilities::RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORERTSP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RTP_RTSP_TCP", &a->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", &a->tt__RealTimeStreamingCapabilities::Extension, "tt:RealTimeStreamingCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RealTimeStreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilities, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(tt__RealTimeStreamingCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RealTimeStreamingCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RealTimeStreamingCapabilities *p;
	size_t k = sizeof(tt__RealTimeStreamingCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RealTimeStreamingCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RealTimeStreamingCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RealTimeStreamingCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RealTimeStreamingCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RealTimeStreamingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RealTimeStreamingCapabilities(soap, tag ? tag : "tt:RealTimeStreamingCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RealTimeStreamingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RealTimeStreamingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MediaCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__MediaCapabilitiesExtension::ProfileCapabilities = NULL;
}

void tt__MediaCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ProfileCapabilities(soap, &this->tt__MediaCapabilitiesExtension::ProfileCapabilities);
#endif
}

int tt__MediaCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__MediaCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension), type))
		return soap->error;
	if (!a->tt__MediaCapabilitiesExtension::ProfileCapabilities)
	{	if (soap_element_empty(soap, "tt:ProfileCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", -1, &a->tt__MediaCapabilitiesExtension::ProfileCapabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MediaCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MediaCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, tt__MediaCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(tt__MediaCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MediaCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MediaCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileCapabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", &a->tt__MediaCapabilitiesExtension::ProfileCapabilities, "tt:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__MediaCapabilitiesExtension::ProfileCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MediaCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilitiesExtension, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(tt__MediaCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MediaCapabilitiesExtension *p;
	size_t k = sizeof(tt__MediaCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MediaCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MediaCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MediaCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MediaCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MediaCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MediaCapabilitiesExtension(soap, tag ? tag : "tt:MediaCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MediaCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__MediaCapabilities::XAddr);
	this->tt__MediaCapabilities::StreamingCapabilities = NULL;
	this->tt__MediaCapabilities::Extension = NULL;
}

void tt__MediaCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__MediaCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__MediaCapabilities::XAddr);
	soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, &this->tt__MediaCapabilities::StreamingCapabilities);
	soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, &this->tt__MediaCapabilities::Extension);
#endif
}

int tt__MediaCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilities(struct soap *soap, const char *tag, int id, const tt__MediaCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__MediaCapabilities::XAddr, ""))
		return soap->error;
	if (!a->tt__MediaCapabilities::StreamingCapabilities)
	{	if (soap_element_empty(soap, "tt:StreamingCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", -1, &a->tt__MediaCapabilities::StreamingCapabilities, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__MediaCapabilities::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MediaCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MediaCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaCapabilities * SOAP_FMAC4 soap_in_tt__MediaCapabilities(struct soap *soap, const char *tag, tt__MediaCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilities, sizeof(tt__MediaCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MediaCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MediaCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_StreamingCapabilities1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__MediaCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_StreamingCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", &a->tt__MediaCapabilities::StreamingCapabilities, "tt:RealTimeStreamingCapabilities"))
				{	soap_flag_StreamingCapabilities1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", &a->tt__MediaCapabilities::Extension, "tt:MediaCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || !a->tt__MediaCapabilities::StreamingCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MediaCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilities, SOAP_TYPE_tt__MediaCapabilities, sizeof(tt__MediaCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaCapabilities * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MediaCapabilities *p;
	size_t k = sizeof(tt__MediaCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MediaCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MediaCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MediaCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MediaCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MediaCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MediaCapabilities(soap, tag ? tag : "tt:MediaCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaCapabilities * SOAP_FMAC4 soap_get_tt__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IOCapabilitiesExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__IOCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__IOCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__IOCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IOCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IOCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IOCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(tt__IOCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IOCapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IOCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IOCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension2, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(tt__IOCapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IOCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__IOCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IOCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IOCapabilitiesExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IOCapabilitiesExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IOCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IOCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IOCapabilitiesExtension2(soap, tag ? tag : "tt:IOCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IOCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__IOCapabilitiesExtension::Auxiliary = NULL;
	soap_default_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__IOCapabilitiesExtension::AuxiliaryCommands);
	this->tt__IOCapabilitiesExtension::Extension = NULL;
}

void tt__IOCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IOCapabilitiesExtension::Auxiliary);
	soap_serialize_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__IOCapabilitiesExtension::AuxiliaryCommands);
	soap_serialize_PointerTott__IOCapabilitiesExtension2(soap, &this->tt__IOCapabilitiesExtension::Extension);
#endif
}

int tt__IOCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__IOCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Auxiliary", -1, &a->tt__IOCapabilitiesExtension::Auxiliary, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", -1, &a->tt__IOCapabilitiesExtension::AuxiliaryCommands, ""))
		return soap->error;
	if (!a->tt__IOCapabilitiesExtension::Extension)
	{	if (soap_element_empty(soap, "tt:Extension", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__IOCapabilitiesExtension::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IOCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IOCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IOCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(tt__IOCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IOCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IOCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Auxiliary1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auxiliary1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Auxiliary", &a->tt__IOCapabilitiesExtension::Auxiliary, "xsd:boolean"))
				{	soap_flag_Auxiliary1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", &a->tt__IOCapabilitiesExtension::AuxiliaryCommands, "tt:AuxiliaryData"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", &a->tt__IOCapabilitiesExtension::Extension, "tt:IOCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__IOCapabilitiesExtension::Extension))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IOCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(tt__IOCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IOCapabilitiesExtension *p;
	size_t k = sizeof(tt__IOCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IOCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IOCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IOCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IOCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IOCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IOCapabilitiesExtension(soap, tag ? tag : "tt:IOCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IOCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__IOCapabilities::InputConnectors = NULL;
	this->tt__IOCapabilities::RelayOutputs = NULL;
	this->tt__IOCapabilities::Extension = NULL;
}

void tt__IOCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->tt__IOCapabilities::InputConnectors);
	soap_serialize_PointerToint(soap, &this->tt__IOCapabilities::RelayOutputs);
	soap_serialize_PointerTott__IOCapabilitiesExtension(soap, &this->tt__IOCapabilities::Extension);
#endif
}

int tt__IOCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilities(struct soap *soap, const char *tag, int id, const tt__IOCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilities), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:InputConnectors", -1, &a->tt__IOCapabilities::InputConnectors, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RelayOutputs", -1, &a->tt__IOCapabilities::RelayOutputs, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__IOCapabilities::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IOCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IOCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilities * SOAP_FMAC4 soap_in_tt__IOCapabilities(struct soap *soap, const char *tag, tt__IOCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IOCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilities, sizeof(tt__IOCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IOCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IOCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InputConnectors1 = 1;
	size_t soap_flag_RelayOutputs1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputConnectors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:InputConnectors", &a->tt__IOCapabilities::InputConnectors, "xsd:int"))
				{	soap_flag_InputConnectors1--;
					continue;
				}
			}
			if (soap_flag_RelayOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:RelayOutputs", &a->tt__IOCapabilities::RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", &a->tt__IOCapabilities::Extension, "tt:IOCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilities, SOAP_TYPE_tt__IOCapabilities, sizeof(tt__IOCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilities * SOAP_FMAC2 soap_instantiate_tt__IOCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IOCapabilities *p;
	size_t k = sizeof(tt__IOCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IOCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IOCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IOCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IOCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IOCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IOCapabilities(soap, tag ? tag : "tt:IOCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilities * SOAP_FMAC4 soap_get_tt__IOCapabilities(struct soap *soap, tt__IOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EventCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__EventCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSSubscriptionPolicySupport);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSPullPointSupport);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport);
}

void tt__EventCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__EventCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__EventCapabilities::XAddr);
	soap_embedded(soap, &this->tt__EventCapabilities::WSSubscriptionPolicySupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__EventCapabilities::WSPullPointSupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport, SOAP_TYPE_bool);
#endif
}

int tt__EventCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventCapabilities(struct soap *soap, const char *tag, int id, const tt__EventCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__EventCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSSubscriptionPolicySupport", -1, &a->tt__EventCapabilities::WSSubscriptionPolicySupport, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSPullPointSupport", -1, &a->tt__EventCapabilities::WSPullPointSupport, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", -1, &a->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EventCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EventCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventCapabilities * SOAP_FMAC4 soap_in_tt__EventCapabilities(struct soap *soap, const char *tag, tt__EventCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EventCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EventCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_WSSubscriptionPolicySupport1 = 1;
	size_t soap_flag_WSPullPointSupport1 = 1;
	size_t soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__EventCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_WSSubscriptionPolicySupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WSSubscriptionPolicySupport", &a->tt__EventCapabilities::WSSubscriptionPolicySupport, "xsd:boolean"))
				{	soap_flag_WSSubscriptionPolicySupport1--;
					continue;
				}
			}
			if (soap_flag_WSPullPointSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WSPullPointSupport", &a->tt__EventCapabilities::WSPullPointSupport, "xsd:boolean"))
				{	soap_flag_WSPullPointSupport1--;
					continue;
				}
			}
			if (soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", &a->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport, "xsd:boolean"))
				{	soap_flag_WSPausableSubscriptionManagerInterfaceSupport1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_WSSubscriptionPolicySupport1 > 0 || soap_flag_WSPullPointSupport1 > 0 || soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__EventCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventCapabilities, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EventCapabilities * SOAP_FMAC2 soap_instantiate_tt__EventCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EventCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EventCapabilities *p;
	size_t k = sizeof(tt__EventCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EventCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EventCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EventCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EventCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EventCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EventCapabilities(soap, tag ? tag : "tt:EventCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventCapabilities * SOAP_FMAC4 soap_get_tt__EventCapabilities(struct soap *soap, tt__EventCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__DeviceCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__DeviceCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__DeviceCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, tt__DeviceCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(tt__DeviceCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DeviceCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilitiesExtension, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(tt__DeviceCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceCapabilitiesExtension *p;
	size_t k = sizeof(tt__DeviceCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceCapabilitiesExtension(soap, tag ? tag : "tt:DeviceCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__DeviceCapabilities::XAddr);
	this->tt__DeviceCapabilities::Network = NULL;
	this->tt__DeviceCapabilities::System = NULL;
	this->tt__DeviceCapabilities::IO = NULL;
	this->tt__DeviceCapabilities::Security = NULL;
	this->tt__DeviceCapabilities::Extension = NULL;
}

void tt__DeviceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DeviceCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__DeviceCapabilities::XAddr);
	soap_serialize_PointerTott__NetworkCapabilities(soap, &this->tt__DeviceCapabilities::Network);
	soap_serialize_PointerTott__SystemCapabilities(soap, &this->tt__DeviceCapabilities::System);
	soap_serialize_PointerTott__IOCapabilities(soap, &this->tt__DeviceCapabilities::IO);
	soap_serialize_PointerTott__SecurityCapabilities(soap, &this->tt__DeviceCapabilities::Security);
	soap_serialize_PointerTott__DeviceCapabilitiesExtension(soap, &this->tt__DeviceCapabilities::Extension);
#endif
}

int tt__DeviceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilities(struct soap *soap, const char *tag, int id, const tt__DeviceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__DeviceCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilities(soap, "tt:Network", -1, &a->tt__DeviceCapabilities::Network, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilities(soap, "tt:System", -1, &a->tt__DeviceCapabilities::System, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilities(soap, "tt:IO", -1, &a->tt__DeviceCapabilities::IO, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilities(soap, "tt:Security", -1, &a->tt__DeviceCapabilities::Security, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__DeviceCapabilities::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceCapabilities * SOAP_FMAC4 soap_in_tt__DeviceCapabilities(struct soap *soap, const char *tag, tt__DeviceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_Network1 = 1;
	size_t soap_flag_System1 = 1;
	size_t soap_flag_IO1 = 1;
	size_t soap_flag_Security1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__DeviceCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_Network1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkCapabilities(soap, "tt:Network", &a->tt__DeviceCapabilities::Network, "tt:NetworkCapabilities"))
				{	soap_flag_Network1--;
					continue;
				}
			}
			if (soap_flag_System1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilities(soap, "tt:System", &a->tt__DeviceCapabilities::System, "tt:SystemCapabilities"))
				{	soap_flag_System1--;
					continue;
				}
			}
			if (soap_flag_IO1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IOCapabilities(soap, "tt:IO", &a->tt__DeviceCapabilities::IO, "tt:IOCapabilities"))
				{	soap_flag_IO1--;
					continue;
				}
			}
			if (soap_flag_Security1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SecurityCapabilities(soap, "tt:Security", &a->tt__DeviceCapabilities::Security, "tt:SecurityCapabilities"))
				{	soap_flag_Security1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", &a->tt__DeviceCapabilities::Extension, "tt:DeviceCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilities, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceCapabilities *p;
	size_t k = sizeof(tt__DeviceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceCapabilities(soap, tag ? tag : "tt:DeviceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceCapabilities * SOAP_FMAC4 soap_get_tt__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__AnalyticsCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__AnalyticsCapabilities::RuleSupport);
	soap_default_bool(soap, &this->tt__AnalyticsCapabilities::AnalyticsModuleSupport);
}

void tt__AnalyticsCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__AnalyticsCapabilities::XAddr);
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::RuleSupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::AnalyticsModuleSupport, SOAP_TYPE_bool);
#endif
}

int tt__AnalyticsCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, const tt__AnalyticsCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsCapabilities), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__AnalyticsCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RuleSupport", -1, &a->tt__AnalyticsCapabilities::RuleSupport, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AnalyticsModuleSupport", -1, &a->tt__AnalyticsCapabilities::AnalyticsModuleSupport, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, tt__AnalyticsCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_RuleSupport1 = 1;
	size_t soap_flag_AnalyticsModuleSupport1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__AnalyticsCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_RuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RuleSupport", &a->tt__AnalyticsCapabilities::RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport1--;
					continue;
				}
			}
			if (soap_flag_AnalyticsModuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AnalyticsModuleSupport", &a->tt__AnalyticsCapabilities::AnalyticsModuleSupport, "xsd:boolean"))
				{	soap_flag_AnalyticsModuleSupport1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr1 > 0 || soap_flag_RuleSupport1 > 0 || soap_flag_AnalyticsModuleSupport1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsCapabilities, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsCapabilities *p;
	size_t k = sizeof(tt__AnalyticsCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsCapabilities(soap, tag ? tag : "tt:AnalyticsCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CapabilitiesExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__CapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__CapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__CapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, tt__CapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(tt__CapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension2, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(tt__CapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CapabilitiesExtension2 *p;
	size_t k = sizeof(tt__CapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CapabilitiesExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CapabilitiesExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CapabilitiesExtension2(soap, tag ? tag : "tt:CapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__CapabilitiesExtension::DeviceIO = NULL;
	this->tt__CapabilitiesExtension::Display = NULL;
	this->tt__CapabilitiesExtension::Recording = NULL;
	this->tt__CapabilitiesExtension::Search = NULL;
	this->tt__CapabilitiesExtension::Replay = NULL;
	this->tt__CapabilitiesExtension::Receiver = NULL;
	this->tt__CapabilitiesExtension::AnalyticsDevice = NULL;
	this->tt__CapabilitiesExtension::Extensions = NULL;
}

void tt__CapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DeviceIOCapabilities(soap, &this->tt__CapabilitiesExtension::DeviceIO);
	soap_serialize_PointerTott__DisplayCapabilities(soap, &this->tt__CapabilitiesExtension::Display);
	soap_serialize_PointerTott__RecordingCapabilities(soap, &this->tt__CapabilitiesExtension::Recording);
	soap_serialize_PointerTott__SearchCapabilities(soap, &this->tt__CapabilitiesExtension::Search);
	soap_serialize_PointerTott__ReplayCapabilities(soap, &this->tt__CapabilitiesExtension::Replay);
	soap_serialize_PointerTott__ReceiverCapabilities(soap, &this->tt__CapabilitiesExtension::Receiver);
	soap_serialize_PointerTott__AnalyticsDeviceCapabilities(soap, &this->tt__CapabilitiesExtension::AnalyticsDevice);
	soap_serialize_PointerTott__CapabilitiesExtension2(soap, &this->tt__CapabilitiesExtension::Extensions);
#endif
}

int tt__CapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__CapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension), type))
		return soap->error;
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", -1, &a->tt__CapabilitiesExtension::DeviceIO, ""))
		return soap->error;
	if (soap_out_PointerTott__DisplayCapabilities(soap, "tt:Display", -1, &a->tt__CapabilitiesExtension::Display, ""))
		return soap->error;
	if (soap_out_PointerTott__RecordingCapabilities(soap, "tt:Recording", -1, &a->tt__CapabilitiesExtension::Recording, ""))
		return soap->error;
	if (soap_out_PointerTott__SearchCapabilities(soap, "tt:Search", -1, &a->tt__CapabilitiesExtension::Search, ""))
		return soap->error;
	if (soap_out_PointerTott__ReplayCapabilities(soap, "tt:Replay", -1, &a->tt__CapabilitiesExtension::Replay, ""))
		return soap->error;
	if (soap_out_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", -1, &a->tt__CapabilitiesExtension::Receiver, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", -1, &a->tt__CapabilitiesExtension::AnalyticsDevice, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", -1, &a->tt__CapabilitiesExtension::Extensions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension(struct soap *soap, const char *tag, tt__CapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(tt__CapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DeviceIO1 = 1;
	size_t soap_flag_Display1 = 1;
	size_t soap_flag_Recording1 = 1;
	size_t soap_flag_Search1 = 1;
	size_t soap_flag_Replay1 = 1;
	size_t soap_flag_Receiver1 = 1;
	size_t soap_flag_AnalyticsDevice1 = 1;
	size_t soap_flag_Extensions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeviceIO1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", &a->tt__CapabilitiesExtension::DeviceIO, "tt:DeviceIOCapabilities"))
				{	soap_flag_DeviceIO1--;
					continue;
				}
			}
			if (soap_flag_Display1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DisplayCapabilities(soap, "tt:Display", &a->tt__CapabilitiesExtension::Display, "tt:DisplayCapabilities"))
				{	soap_flag_Display1--;
					continue;
				}
			}
			if (soap_flag_Recording1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingCapabilities(soap, "tt:Recording", &a->tt__CapabilitiesExtension::Recording, "tt:RecordingCapabilities"))
				{	soap_flag_Recording1--;
					continue;
				}
			}
			if (soap_flag_Search1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SearchCapabilities(soap, "tt:Search", &a->tt__CapabilitiesExtension::Search, "tt:SearchCapabilities"))
				{	soap_flag_Search1--;
					continue;
				}
			}
			if (soap_flag_Replay1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReplayCapabilities(soap, "tt:Replay", &a->tt__CapabilitiesExtension::Replay, "tt:ReplayCapabilities"))
				{	soap_flag_Replay1--;
					continue;
				}
			}
			if (soap_flag_Receiver1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", &a->tt__CapabilitiesExtension::Receiver, "tt:ReceiverCapabilities"))
				{	soap_flag_Receiver1--;
					continue;
				}
			}
			if (soap_flag_AnalyticsDevice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", &a->tt__CapabilitiesExtension::AnalyticsDevice, "tt:AnalyticsDeviceCapabilities"))
				{	soap_flag_AnalyticsDevice1--;
					continue;
				}
			}
			if (soap_flag_Extensions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", &a->tt__CapabilitiesExtension::Extensions, "tt:CapabilitiesExtension2"))
				{	soap_flag_Extensions1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(tt__CapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CapabilitiesExtension *p;
	size_t k = sizeof(tt__CapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CapabilitiesExtension(soap, tag ? tag : "tt:CapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Capabilities::Analytics = NULL;
	this->tt__Capabilities::Device = NULL;
	this->tt__Capabilities::Events = NULL;
	this->tt__Capabilities::Imaging = NULL;
	this->tt__Capabilities::Media = NULL;
	this->tt__Capabilities::PTZ = NULL;
	this->tt__Capabilities::Extension = NULL;
}

void tt__Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsCapabilities(soap, &this->tt__Capabilities::Analytics);
	soap_serialize_PointerTott__DeviceCapabilities(soap, &this->tt__Capabilities::Device);
	soap_serialize_PointerTott__EventCapabilities(soap, &this->tt__Capabilities::Events);
	soap_serialize_PointerTott__ImagingCapabilities(soap, &this->tt__Capabilities::Imaging);
	soap_serialize_PointerTott__MediaCapabilities(soap, &this->tt__Capabilities::Media);
	soap_serialize_PointerTott__PTZCapabilities(soap, &this->tt__Capabilities::PTZ);
	soap_serialize_PointerTott__CapabilitiesExtension(soap, &this->tt__Capabilities::Extension);
#endif
}

int tt__Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Capabilities(struct soap *soap, const char *tag, int id, const tt__Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Capabilities), type))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", -1, &a->tt__Capabilities::Analytics, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilities(soap, "tt:Device", -1, &a->tt__Capabilities::Device, ""))
		return soap->error;
	if (soap_out_PointerTott__EventCapabilities(soap, "tt:Events", -1, &a->tt__Capabilities::Events, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingCapabilities(soap, "tt:Imaging", -1, &a->tt__Capabilities::Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilities(soap, "tt:Media", -1, &a->tt__Capabilities::Media, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZCapabilities(soap, "tt:PTZ", -1, &a->tt__Capabilities::PTZ, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__Capabilities::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__Capabilities * SOAP_FMAC4 soap_in_tt__Capabilities(struct soap *soap, const char *tag, tt__Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(tt__Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Analytics1 = 1;
	size_t soap_flag_Device1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Media1 = 1;
	size_t soap_flag_PTZ1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Analytics1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", &a->tt__Capabilities::Analytics, "tt:AnalyticsCapabilities"))
				{	soap_flag_Analytics1--;
					continue;
				}
			}
			if (soap_flag_Device1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceCapabilities(soap, "tt:Device", &a->tt__Capabilities::Device, "tt:DeviceCapabilities"))
				{	soap_flag_Device1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EventCapabilities(soap, "tt:Events", &a->tt__Capabilities::Events, "tt:EventCapabilities"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingCapabilities(soap, "tt:Imaging", &a->tt__Capabilities::Imaging, "tt:ImagingCapabilities"))
				{	soap_flag_Imaging1--;
					continue;
				}
			}
			if (soap_flag_Media1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaCapabilities(soap, "tt:Media", &a->tt__Capabilities::Media, "tt:MediaCapabilities"))
				{	soap_flag_Media1--;
					continue;
				}
			}
			if (soap_flag_PTZ1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZCapabilities(soap, "tt:PTZ", &a->tt__Capabilities::PTZ, "tt:PTZCapabilities"))
				{	soap_flag_PTZ1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CapabilitiesExtension(soap, "tt:Extension", &a->tt__Capabilities::Extension, "tt:CapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, SOAP_TYPE_tt__Capabilities, sizeof(tt__Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Capabilities * SOAP_FMAC2 soap_instantiate_tt__Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Capabilities *p;
	size_t k = sizeof(tt__Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Capabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Capabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__Capabilities * SOAP_FMAC4 soap_get_tt__Capabilities(struct soap *soap, tt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11AvailableNetworksExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__Dot11AvailableNetworksExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Dot11AvailableNetworksExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11AvailableNetworksExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, int id, const tt__Dot11AvailableNetworksExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11AvailableNetworksExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, tt__Dot11AvailableNetworksExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11AvailableNetworksExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(tt__Dot11AvailableNetworksExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11AvailableNetworksExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11AvailableNetworksExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot11AvailableNetworksExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(tt__Dot11AvailableNetworksExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11AvailableNetworksExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworksExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11AvailableNetworksExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11AvailableNetworksExtension *p;
	size_t k = sizeof(tt__Dot11AvailableNetworksExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11AvailableNetworksExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11AvailableNetworksExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11AvailableNetworksExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11AvailableNetworksExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11AvailableNetworksExtension(soap, tag ? tag : "tt:Dot11AvailableNetworksExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11AvailableNetworksExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11AvailableNetworksExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11AvailableNetworks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__Dot11SSIDType(soap, &this->tt__Dot11AvailableNetworks::SSID);
	this->tt__Dot11AvailableNetworks::BSSID = NULL;
	soap_default_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, &this->tt__Dot11AvailableNetworks::AuthAndMangementSuite);
	soap_default_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::PairCipher);
	soap_default_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::GroupCipher);
	this->tt__Dot11AvailableNetworks::SignalStrength = NULL;
	this->tt__Dot11AvailableNetworks::Extension = NULL;
}

void tt__Dot11AvailableNetworks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &this->tt__Dot11AvailableNetworks::SSID);
	soap_serialize_PointerTostd__string(soap, &this->tt__Dot11AvailableNetworks::BSSID);
	soap_serialize_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, &this->tt__Dot11AvailableNetworks::AuthAndMangementSuite);
	soap_serialize_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::PairCipher);
	soap_serialize_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::GroupCipher);
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &this->tt__Dot11AvailableNetworks::SignalStrength);
	soap_serialize_PointerTott__Dot11AvailableNetworksExtension(soap, &this->tt__Dot11AvailableNetworks::Extension);
#endif
}

int tt__Dot11AvailableNetworks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11AvailableNetworks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, const tt__Dot11AvailableNetworks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AvailableNetworks), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->tt__Dot11AvailableNetworks::SSID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:BSSID", -1, &a->tt__Dot11AvailableNetworks::BSSID, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", -1, &a->tt__Dot11AvailableNetworks::AuthAndMangementSuite, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:PairCipher", -1, &a->tt__Dot11AvailableNetworks::PairCipher, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:GroupCipher", -1, &a->tt__Dot11AvailableNetworks::GroupCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->tt__Dot11AvailableNetworks::SignalStrength, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", -1, &a->tt__Dot11AvailableNetworks::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11AvailableNetworks::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11AvailableNetworks(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, tt__Dot11AvailableNetworks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11AvailableNetworks*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11AvailableNetworks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11AvailableNetworks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SSID1 = 1;
	size_t soap_flag_BSSID1 = 1;
	size_t soap_flag_SignalStrength1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->tt__Dot11AvailableNetworks::SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID1--;
					continue;
				}
			}
			if (soap_flag_BSSID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:BSSID", &a->tt__Dot11AvailableNetworks::BSSID, "xsd:string"))
				{	soap_flag_BSSID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", &a->tt__Dot11AvailableNetworks::AuthAndMangementSuite, "tt:Dot11AuthAndMangementSuite"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:PairCipher", &a->tt__Dot11AvailableNetworks::PairCipher, "tt:Dot11Cipher"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:GroupCipher", &a->tt__Dot11AvailableNetworks::GroupCipher, "tt:Dot11Cipher"))
					continue;
			}
			if (soap_flag_SignalStrength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->tt__Dot11AvailableNetworks::SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", &a->tt__Dot11AvailableNetworks::Extension, "tt:Dot11AvailableNetworksExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11AvailableNetworks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworks, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11AvailableNetworks * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11AvailableNetworks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11AvailableNetworks *p;
	size_t k = sizeof(tt__Dot11AvailableNetworks);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11AvailableNetworks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11AvailableNetworks);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11AvailableNetworks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11AvailableNetworks location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11AvailableNetworks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11AvailableNetworks(soap, tag ? tag : "tt:Dot11AvailableNetworks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11AvailableNetworks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11AvailableNetworks(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__Dot11SSIDType(soap, &this->tt__Dot11Status::SSID);
	this->tt__Dot11Status::BSSID = NULL;
	this->tt__Dot11Status::PairCipher = NULL;
	this->tt__Dot11Status::GroupCipher = NULL;
	this->tt__Dot11Status::SignalStrength = NULL;
	soap_default_tt__ReferenceToken(soap, &this->tt__Dot11Status::ActiveConfigAlias);
}

void tt__Dot11Status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &this->tt__Dot11Status::SSID);
	soap_serialize_PointerTostd__string(soap, &this->tt__Dot11Status::BSSID);
	soap_serialize_PointerTott__Dot11Cipher(soap, &this->tt__Dot11Status::PairCipher);
	soap_serialize_PointerTott__Dot11Cipher(soap, &this->tt__Dot11Status::GroupCipher);
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &this->tt__Dot11Status::SignalStrength);
	soap_embedded(soap, &this->tt__Dot11Status::ActiveConfigAlias, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__Dot11Status::ActiveConfigAlias);
#endif
}

int tt__Dot11Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Status(struct soap *soap, const char *tag, int id, const tt__Dot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Status), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->tt__Dot11Status::SSID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:BSSID", -1, &a->tt__Dot11Status::BSSID, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:PairCipher", -1, &a->tt__Dot11Status::PairCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", -1, &a->tt__Dot11Status::GroupCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->tt__Dot11Status::SignalStrength, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", -1, &a->tt__Dot11Status::ActiveConfigAlias, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11Status::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11Status(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11Status * SOAP_FMAC4 soap_in_tt__Dot11Status(struct soap *soap, const char *tag, tt__Dot11Status *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11Status*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Status, sizeof(tt__Dot11Status), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11Status)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11Status *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SSID1 = 1;
	size_t soap_flag_BSSID1 = 1;
	size_t soap_flag_PairCipher1 = 1;
	size_t soap_flag_GroupCipher1 = 1;
	size_t soap_flag_SignalStrength1 = 1;
	size_t soap_flag_ActiveConfigAlias1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->tt__Dot11Status::SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID1--;
					continue;
				}
			}
			if (soap_flag_BSSID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:BSSID", &a->tt__Dot11Status::BSSID, "xsd:string"))
				{	soap_flag_BSSID1--;
					continue;
				}
			}
			if (soap_flag_PairCipher1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:PairCipher", &a->tt__Dot11Status::PairCipher, "tt:Dot11Cipher"))
				{	soap_flag_PairCipher1--;
					continue;
				}
			}
			if (soap_flag_GroupCipher1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", &a->tt__Dot11Status::GroupCipher, "tt:Dot11Cipher"))
				{	soap_flag_GroupCipher1--;
					continue;
				}
			}
			if (soap_flag_SignalStrength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->tt__Dot11Status::SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength1--;
					continue;
				}
			}
			if (soap_flag_ActiveConfigAlias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", &a->tt__Dot11Status::ActiveConfigAlias, "tt:ReferenceToken"))
				{	soap_flag_ActiveConfigAlias1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID1 > 0 || soap_flag_ActiveConfigAlias1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Status, SOAP_TYPE_tt__Dot11Status, sizeof(tt__Dot11Status), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Status * SOAP_FMAC2 soap_instantiate_tt__Dot11Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11Status(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11Status *p;
	size_t k = sizeof(tt__Dot11Status);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11Status, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11Status);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11Status, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11Status location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11Status(soap, tag ? tag : "tt:Dot11Status", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11Status(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11Status * SOAP_FMAC4 soap_get_tt__Dot11Status(struct soap *soap, tt__Dot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__Dot11Capabilities::TKIP);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::ScanAvailableNetworks);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::MultipleConfiguration);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::AdHocStationMode);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::WEP);
}

void tt__Dot11Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Dot11Capabilities::TKIP, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::ScanAvailableNetworks, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::MultipleConfiguration, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::AdHocStationMode, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::WEP, SOAP_TYPE_bool);
#endif
}

int tt__Dot11Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Capabilities(struct soap *soap, const char *tag, int id, const tt__Dot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Capabilities), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:TKIP", -1, &a->tt__Dot11Capabilities::TKIP, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:ScanAvailableNetworks", -1, &a->tt__Dot11Capabilities::ScanAvailableNetworks, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:MultipleConfiguration", -1, &a->tt__Dot11Capabilities::MultipleConfiguration, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AdHocStationMode", -1, &a->tt__Dot11Capabilities::AdHocStationMode, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WEP", -1, &a->tt__Dot11Capabilities::WEP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11Capabilities * SOAP_FMAC4 soap_in_tt__Dot11Capabilities(struct soap *soap, const char *tag, tt__Dot11Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(tt__Dot11Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_TKIP1 = 1;
	size_t soap_flag_ScanAvailableNetworks1 = 1;
	size_t soap_flag_MultipleConfiguration1 = 1;
	size_t soap_flag_AdHocStationMode1 = 1;
	size_t soap_flag_WEP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TKIP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TKIP", &a->tt__Dot11Capabilities::TKIP, "xsd:boolean"))
				{	soap_flag_TKIP1--;
					continue;
				}
			}
			if (soap_flag_ScanAvailableNetworks1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:ScanAvailableNetworks", &a->tt__Dot11Capabilities::ScanAvailableNetworks, "xsd:boolean"))
				{	soap_flag_ScanAvailableNetworks1--;
					continue;
				}
			}
			if (soap_flag_MultipleConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:MultipleConfiguration", &a->tt__Dot11Capabilities::MultipleConfiguration, "xsd:boolean"))
				{	soap_flag_MultipleConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AdHocStationMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AdHocStationMode", &a->tt__Dot11Capabilities::AdHocStationMode, "xsd:boolean"))
				{	soap_flag_AdHocStationMode1--;
					continue;
				}
			}
			if (soap_flag_WEP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WEP", &a->tt__Dot11Capabilities::WEP, "xsd:boolean"))
				{	soap_flag_WEP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TKIP1 > 0 || soap_flag_ScanAvailableNetworks1 > 0 || soap_flag_MultipleConfiguration1 > 0 || soap_flag_AdHocStationMode1 > 0 || soap_flag_WEP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Capabilities, SOAP_TYPE_tt__Dot11Capabilities, sizeof(tt__Dot11Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Capabilities * SOAP_FMAC2 soap_instantiate_tt__Dot11Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11Capabilities *p;
	size_t k = sizeof(tt__Dot11Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11Capabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11Capabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11Capabilities(soap, tag ? tag : "tt:Dot11Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11Capabilities * SOAP_FMAC4 soap_get_tt__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceSetConfigurationExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__NetworkInterfaceSetConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__NetworkInterfaceSetConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceSetConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceSetConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(tt__NetworkInterfaceSetConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceSetConfigurationExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceSetConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(tt__NetworkInterfaceSetConfigurationExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceSetConfigurationExtension2 *p;
	size_t k = sizeof(tt__NetworkInterfaceSetConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceSetConfigurationExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceSetConfigurationExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceSetConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceSetConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11PSKSetExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__Dot11PSKSetExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Dot11PSKSetExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11PSKSetExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, const tt__Dot11PSKSetExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSetExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11PSKSetExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11PSKSetExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_in_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, tt__Dot11PSKSetExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11PSKSetExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(tt__Dot11PSKSetExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11PSKSetExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11PSKSetExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot11PSKSetExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSetExtension, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(tt__Dot11PSKSetExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11PSKSetExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSetExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11PSKSetExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11PSKSetExtension *p;
	size_t k = sizeof(tt__Dot11PSKSetExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11PSKSetExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11PSKSetExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11PSKSetExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11PSKSetExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11PSKSetExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11PSKSetExtension(soap, tag ? tag : "tt:Dot11PSKSetExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11PSKSetExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11PSKSetExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_get_tt__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11PSKSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Dot11PSKSet::Key = NULL;
	this->tt__Dot11PSKSet::Passphrase = NULL;
	this->tt__Dot11PSKSet::Extension = NULL;
}

void tt__Dot11PSKSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11PSK(soap, &this->tt__Dot11PSKSet::Key);
	soap_serialize_PointerTott__Dot11PSKPassphrase(soap, &this->tt__Dot11PSKSet::Passphrase);
	soap_serialize_PointerTott__Dot11PSKSetExtension(soap, &this->tt__Dot11PSKSet::Extension);
#endif
}

int tt__Dot11PSKSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11PSKSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSet(struct soap *soap, const char *tag, int id, const tt__Dot11PSKSet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSet), type))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSK(soap, "tt:Key", -1, &a->tt__Dot11PSKSet::Key, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKPassphrase(soap, "tt:Passphrase", -1, &a->tt__Dot11PSKSet::Passphrase, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", -1, &a->tt__Dot11PSKSet::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11PSKSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11PSKSet(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11PSKSet * SOAP_FMAC4 soap_in_tt__Dot11PSKSet(struct soap *soap, const char *tag, tt__Dot11PSKSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11PSKSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(tt__Dot11PSKSet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11PSKSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11PSKSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Passphrase1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11PSK(soap, "tt:Key", &a->tt__Dot11PSKSet::Key, "tt:Dot11PSK"))
				{	soap_flag_Key1--;
					continue;
				}
			}
			if (soap_flag_Passphrase1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__Dot11PSKPassphrase(soap, "tt:Passphrase", &a->tt__Dot11PSKSet::Passphrase, "tt:Dot11PSKPassphrase"))
				{	soap_flag_Passphrase1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", &a->tt__Dot11PSKSet::Extension, "tt:Dot11PSKSetExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot11PSKSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSet, SOAP_TYPE_tt__Dot11PSKSet, sizeof(tt__Dot11PSKSet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11PSKSet * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11PSKSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11PSKSet *p;
	size_t k = sizeof(tt__Dot11PSKSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11PSKSet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11PSKSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11PSKSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11PSKSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11PSKSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11PSKSet(soap, tag ? tag : "tt:Dot11PSKSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11PSKSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11PSKSet(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11PSKSet * SOAP_FMAC4 soap_get_tt__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11SecurityConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__Dot11SecurityConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Dot11SecurityConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11SecurityConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11SecurityConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(tt__Dot11SecurityConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11SecurityConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11SecurityConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot11SecurityConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(tt__Dot11SecurityConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11SecurityConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11SecurityConfigurationExtension *p;
	size_t k = sizeof(tt__Dot11SecurityConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11SecurityConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11SecurityConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11SecurityConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11SecurityConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag ? tag : "tt:Dot11SecurityConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11SecurityConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11SecurityConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11SecurityConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__Dot11SecurityMode(soap, &this->tt__Dot11SecurityConfiguration::Mode);
	this->tt__Dot11SecurityConfiguration::Algorithm = NULL;
	this->tt__Dot11SecurityConfiguration::PSK = NULL;
	this->tt__Dot11SecurityConfiguration::Dot1X = NULL;
	this->tt__Dot11SecurityConfiguration::Extension = NULL;
}

void tt__Dot11SecurityConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Cipher(soap, &this->tt__Dot11SecurityConfiguration::Algorithm);
	soap_serialize_PointerTott__Dot11PSKSet(soap, &this->tt__Dot11SecurityConfiguration::PSK);
	soap_serialize_PointerTott__ReferenceToken(soap, &this->tt__Dot11SecurityConfiguration::Dot1X);
	soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(soap, &this->tt__Dot11SecurityConfiguration::Extension);
#endif
}

int tt__Dot11SecurityConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11SecurityConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, const tt__Dot11SecurityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration), type))
		return soap->error;
	if (soap_out_tt__Dot11SecurityMode(soap, "tt:Mode", -1, &a->tt__Dot11SecurityConfiguration::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:Algorithm", -1, &a->tt__Dot11SecurityConfiguration::Algorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSet(soap, "tt:PSK", -1, &a->tt__Dot11SecurityConfiguration::PSK, ""))
		return soap->error;
	if (soap_out_PointerTott__ReferenceToken(soap, "tt:Dot1X", -1, &a->tt__Dot11SecurityConfiguration::Dot1X, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", -1, &a->tt__Dot11SecurityConfiguration::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11SecurityConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11SecurityConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, tt__Dot11SecurityConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11SecurityConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(tt__Dot11SecurityConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11SecurityConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11SecurityConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Algorithm1 = 1;
	size_t soap_flag_PSK1 = 1;
	size_t soap_flag_Dot1X1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SecurityMode(soap, "tt:Mode", &a->tt__Dot11SecurityConfiguration::Mode, "tt:Dot11SecurityMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Algorithm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:Algorithm", &a->tt__Dot11SecurityConfiguration::Algorithm, "tt:Dot11Cipher"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			}
			if (soap_flag_PSK1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11PSKSet(soap, "tt:PSK", &a->tt__Dot11SecurityConfiguration::PSK, "tt:Dot11PSKSet"))
				{	soap_flag_PSK1--;
					continue;
				}
			}
			if (soap_flag_Dot1X1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__ReferenceToken(soap, "tt:Dot1X", &a->tt__Dot11SecurityConfiguration::Dot1X, "tt:ReferenceToken"))
				{	soap_flag_Dot1X1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", &a->tt__Dot11SecurityConfiguration::Extension, "tt:Dot11SecurityConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11SecurityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfiguration, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(tt__Dot11SecurityConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11SecurityConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11SecurityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11SecurityConfiguration *p;
	size_t k = sizeof(tt__Dot11SecurityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11SecurityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11SecurityConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11SecurityConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11SecurityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11SecurityConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11SecurityConfiguration(soap, tag ? tag : "tt:Dot11SecurityConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11SecurityConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11SecurityConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__Dot11SSIDType(soap, &this->tt__Dot11Configuration::SSID);
	soap_default_tt__Dot11StationMode(soap, &this->tt__Dot11Configuration::Mode);
	soap_default_tt__Name(soap, &this->tt__Dot11Configuration::Alias);
	soap_default_tt__NetworkInterfaceConfigPriority(soap, &this->tt__Dot11Configuration::Priority);
	this->tt__Dot11Configuration::Security = NULL;
}

void tt__Dot11Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &this->tt__Dot11Configuration::SSID);
	soap_serialize_tt__Name(soap, &this->tt__Dot11Configuration::Alias);
	soap_serialize_tt__NetworkInterfaceConfigPriority(soap, &this->tt__Dot11Configuration::Priority);
	soap_serialize_PointerTott__Dot11SecurityConfiguration(soap, &this->tt__Dot11Configuration::Security);
#endif
}

int tt__Dot11Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Configuration(struct soap *soap, const char *tag, int id, const tt__Dot11Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Configuration), type))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->tt__Dot11Configuration::SSID, ""))
		return soap->error;
	if (soap_out_tt__Dot11StationMode(soap, "tt:Mode", -1, &a->tt__Dot11Configuration::Mode, ""))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Alias", -1, &a->tt__Dot11Configuration::Alias, ""))
		return soap->error;
	if (soap_out_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", -1, &a->tt__Dot11Configuration::Priority, ""))
		return soap->error;
	if (!a->tt__Dot11Configuration::Security)
	{	if (soap_element_empty(soap, "tt:Security", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", -1, &a->tt__Dot11Configuration::Security, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11Configuration * SOAP_FMAC4 soap_in_tt__Dot11Configuration(struct soap *soap, const char *tag, tt__Dot11Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Configuration, sizeof(tt__Dot11Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SSID1 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Alias1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Security1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->tt__Dot11Configuration::SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID1--;
					continue;
				}
			}
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11StationMode(soap, "tt:Mode", &a->tt__Dot11Configuration::Mode, "tt:Dot11StationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Alias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Alias", &a->tt__Dot11Configuration::Alias, "tt:Name"))
				{	soap_flag_Alias1--;
					continue;
				}
			}
			if (soap_flag_Priority1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", &a->tt__Dot11Configuration::Priority, "tt:NetworkInterfaceConfigPriority"))
				{	soap_flag_Priority1--;
					continue;
				}
			}
			if (soap_flag_Security1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", &a->tt__Dot11Configuration::Security, "tt:Dot11SecurityConfiguration"))
				{	soap_flag_Security1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SSID1 > 0 || soap_flag_Mode1 > 0 || soap_flag_Alias1 > 0 || soap_flag_Priority1 > 0 || !a->tt__Dot11Configuration::Security))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Configuration, SOAP_TYPE_tt__Dot11Configuration, sizeof(tt__Dot11Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot11Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11Configuration *p;
	size_t k = sizeof(tt__Dot11Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11Configuration(soap, tag ? tag : "tt:Dot11Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11Configuration * SOAP_FMAC4 soap_get_tt__Dot11Configuration(struct soap *soap, tt__Dot11Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddressFilterExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__IPAddressFilterExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__IPAddressFilterExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddressFilterExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, const tt__IPAddressFilterExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilterExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddressFilterExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddressFilterExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddressFilterExtension * SOAP_FMAC4 soap_in_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, tt__IPAddressFilterExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddressFilterExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(tt__IPAddressFilterExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddressFilterExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPAddressFilterExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPAddressFilterExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilterExtension, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(tt__IPAddressFilterExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddressFilterExtension * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddressFilterExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddressFilterExtension *p;
	size_t k = sizeof(tt__IPAddressFilterExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddressFilterExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddressFilterExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddressFilterExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddressFilterExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddressFilterExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddressFilterExtension(soap, tag ? tag : "tt:IPAddressFilterExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddressFilterExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddressFilterExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddressFilterExtension * SOAP_FMAC4 soap_get_tt__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__IPAddressFilterType(soap, &this->tt__IPAddressFilter::Type);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPAddressFilter::IPv4Address);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPAddressFilter::IPv6Address);
	this->tt__IPAddressFilter::Extension = NULL;
}

void tt__IPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPAddressFilter::IPv4Address);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPAddressFilter::IPv6Address);
	soap_serialize_PointerTott__IPAddressFilterExtension(soap, &this->tt__IPAddressFilter::Extension);
#endif
}

int tt__IPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilter(struct soap *soap, const char *tag, int id, const tt__IPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilter), type))
		return soap->error;
	if (soap_out_tt__IPAddressFilterType(soap, "tt:Type", -1, &a->tt__IPAddressFilter::Type, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:IPv4Address", -1, &a->tt__IPAddressFilter::IPv4Address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:IPv6Address", -1, &a->tt__IPAddressFilter::IPv6Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", -1, &a->tt__IPAddressFilter::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddressFilter * SOAP_FMAC4 soap_in_tt__IPAddressFilter(struct soap *soap, const char *tag, tt__IPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilter, sizeof(tt__IPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPAddressFilterType(soap, "tt:Type", &a->tt__IPAddressFilter::Type, "tt:IPAddressFilterType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:IPv4Address", &a->tt__IPAddressFilter::IPv4Address, "tt:PrefixedIPv4Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:IPv6Address", &a->tt__IPAddressFilter::IPv6Address, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", &a->tt__IPAddressFilter::Extension, "tt:IPAddressFilterExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilter, SOAP_TYPE_tt__IPAddressFilter, sizeof(tt__IPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddressFilter * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddressFilter *p;
	size_t k = sizeof(tt__IPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddressFilter(soap, tag ? tag : "tt:IPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddressFilter * SOAP_FMAC4 soap_get_tt__IPAddressFilter(struct soap *soap, tt__IPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkZeroConfigurationExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__NetworkZeroConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__NetworkZeroConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkZeroConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkZeroConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(tt__NetworkZeroConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkZeroConfigurationExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkZeroConfigurationExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkZeroConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(tt__NetworkZeroConfigurationExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkZeroConfigurationExtension2 *p;
	size_t k = sizeof(tt__NetworkZeroConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkZeroConfigurationExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkZeroConfigurationExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkZeroConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkZeroConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkZeroConfigurationExtension2(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkZeroConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, &this->tt__NetworkZeroConfigurationExtension::Additional);
	this->tt__NetworkZeroConfigurationExtension::Extension = NULL;
}

void tt__NetworkZeroConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, &this->tt__NetworkZeroConfigurationExtension::Additional);
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension2(soap, &this->tt__NetworkZeroConfigurationExtension::Extension);
#endif
}

int tt__NetworkZeroConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, "tt:Additional", -1, &a->tt__NetworkZeroConfigurationExtension::Additional, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__NetworkZeroConfigurationExtension::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkZeroConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkZeroConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(tt__NetworkZeroConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkZeroConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkZeroConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, "tt:Additional", &a->tt__NetworkZeroConfigurationExtension::Additional, "tt:NetworkZeroConfiguration"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfigurationExtension2(soap, "tt:Extension", &a->tt__NetworkZeroConfigurationExtension::Extension, "tt:NetworkZeroConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkZeroConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(tt__NetworkZeroConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkZeroConfigurationExtension *p;
	size_t k = sizeof(tt__NetworkZeroConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkZeroConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkZeroConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkZeroConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkZeroConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkZeroConfigurationExtension(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken);
	soap_default_bool(soap, &this->tt__NetworkZeroConfiguration::Enabled);
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkZeroConfiguration::Addresses);
	this->tt__NetworkZeroConfiguration::Extension = NULL;
}

void tt__NetworkZeroConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken);
	soap_embedded(soap, &this->tt__NetworkZeroConfiguration::Enabled, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkZeroConfiguration::Addresses);
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension(soap, &this->tt__NetworkZeroConfiguration::Extension);
#endif
}

int tt__NetworkZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:InterfaceToken", -1, &a->tt__NetworkZeroConfiguration::InterfaceToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__NetworkZeroConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tt:Addresses", -1, &a->tt__NetworkZeroConfiguration::Addresses, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", -1, &a->tt__NetworkZeroConfiguration::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_in_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, tt__NetworkZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkZeroConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkZeroConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:InterfaceToken", &a->tt__NetworkZeroConfiguration::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__NetworkZeroConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tt:Addresses", &a->tt__NetworkZeroConfiguration::Addresses, "tt:IPv4Address"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", &a->tt__NetworkZeroConfiguration::Extension, "tt:NetworkZeroConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0 || soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfiguration, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkZeroConfiguration *p;
	size_t k = sizeof(tt__NetworkZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkZeroConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkZeroConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkZeroConfiguration(soap, tag ? tag : "tt:NetworkZeroConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_get_tt__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkGateway::IPv4Address);
	soap_default_std__vectorTemplateOftt__IPv6Address(soap, &this->tt__NetworkGateway::IPv6Address);
}

void tt__NetworkGateway::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkGateway::IPv4Address);
	soap_serialize_std__vectorTemplateOftt__IPv6Address(soap, &this->tt__NetworkGateway::IPv6Address);
#endif
}

int tt__NetworkGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkGateway(struct soap *soap, const char *tag, int id, const tt__NetworkGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkGateway), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tt:IPv4Address", -1, &a->tt__NetworkGateway::IPv4Address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv6Address(soap, "tt:IPv6Address", -1, &a->tt__NetworkGateway::IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkGateway(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkGateway * SOAP_FMAC4 soap_in_tt__NetworkGateway(struct soap *soap, const char *tag, tt__NetworkGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkGateway, sizeof(tt__NetworkGateway), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkGateway)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkGateway *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tt:IPv4Address", &a->tt__NetworkGateway::IPv4Address, "tt:IPv4Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv6Address(soap, "tt:IPv6Address", &a->tt__NetworkGateway::IPv6Address, "tt:IPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkGateway, SOAP_TYPE_tt__NetworkGateway, sizeof(tt__NetworkGateway), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkGateway * SOAP_FMAC2 soap_instantiate_tt__NetworkGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkGateway *p;
	size_t k = sizeof(tt__NetworkGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkGateway);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkGateway, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkGateway(soap, tag ? tag : "tt:NetworkGateway", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkGateway(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkGateway * SOAP_FMAC4 soap_get_tt__NetworkGateway(struct soap *soap, tt__NetworkGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__IPv4NetworkInterfaceSetConfiguration::Enabled = NULL;
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Manual);
	this->tt__IPv4NetworkInterfaceSetConfiguration::DHCP = NULL;
}

void tt__IPv4NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Manual);
	soap_serialize_PointerTobool(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::DHCP);
#endif
}

int tt__IPv4NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &a->tt__IPv4NetworkInterfaceSetConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", -1, &a->tt__IPv4NetworkInterfaceSetConfiguration::Manual, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:DHCP", -1, &a->tt__IPv4NetworkInterfaceSetConfiguration::DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4NetworkInterfaceSetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv4NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Enabled", &a->tt__IPv4NetworkInterfaceSetConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", &a->tt__IPv4NetworkInterfaceSetConfiguration::Manual, "tt:PrefixedIPv4Address"))
					continue;
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:DHCP", &a->tt__IPv4NetworkInterfaceSetConfiguration::DHCP, "xsd:boolean"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4NetworkInterfaceSetConfiguration *p;
	size_t k = sizeof(tt__IPv4NetworkInterfaceSetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4NetworkInterfaceSetConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4NetworkInterfaceSetConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4NetworkInterfaceSetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv4NetworkInterfaceSetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__IPv6NetworkInterfaceSetConfiguration::Enabled = NULL;
	this->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert = NULL;
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Manual);
	this->tt__IPv6NetworkInterfaceSetConfiguration::DHCP = NULL;
}

void tt__IPv6NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_PointerTobool(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Manual);
	soap_serialize_PointerTott__IPv6DHCPConfiguration(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::DHCP);
#endif
}

int tt__IPv6NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:AcceptRouterAdvert", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::Manual, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6NetworkInterfaceSetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_AcceptRouterAdvert1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Enabled", &a->tt__IPv6NetworkInterfaceSetConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_AcceptRouterAdvert1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:AcceptRouterAdvert", &a->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", &a->tt__IPv6NetworkInterfaceSetConfiguration::Manual, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->tt__IPv6NetworkInterfaceSetConfiguration::DHCP, "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6NetworkInterfaceSetConfiguration *p;
	size_t k = sizeof(tt__IPv6NetworkInterfaceSetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6NetworkInterfaceSetConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6NetworkInterfaceSetConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6NetworkInterfaceSetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv6NetworkInterfaceSetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceSetConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot3);
	soap_default_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot11);
	this->tt__NetworkInterfaceSetConfigurationExtension::Extension = NULL;
}

void tt__NetworkInterfaceSetConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot3);
	soap_serialize_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot11);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Extension);
#endif
}

int tt__NetworkInterfaceSetConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", -1, &a->tt__NetworkInterfaceSetConfigurationExtension::Dot3, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", -1, &a->tt__NetworkInterfaceSetConfigurationExtension::Dot11, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__NetworkInterfaceSetConfigurationExtension::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceSetConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceSetConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(tt__NetworkInterfaceSetConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceSetConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", &a->tt__NetworkInterfaceSetConfigurationExtension::Dot3, "tt:Dot3Configuration"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", &a->tt__NetworkInterfaceSetConfigurationExtension::Dot11, "tt:Dot11Configuration"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", &a->tt__NetworkInterfaceSetConfigurationExtension::Extension, "tt:NetworkInterfaceSetConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceSetConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(tt__NetworkInterfaceSetConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceSetConfigurationExtension *p;
	size_t k = sizeof(tt__NetworkInterfaceSetConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceSetConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceSetConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceSetConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceSetConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__NetworkInterfaceSetConfiguration::Enabled = NULL;
	this->tt__NetworkInterfaceSetConfiguration::Link = NULL;
	this->tt__NetworkInterfaceSetConfiguration::MTU = NULL;
	this->tt__NetworkInterfaceSetConfiguration::IPv4 = NULL;
	this->tt__NetworkInterfaceSetConfiguration::IPv6 = NULL;
	this->tt__NetworkInterfaceSetConfiguration::Extension = NULL;
}

void tt__NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceSetConfiguration::Link);
	soap_serialize_PointerToint(soap, &this->tt__NetworkInterfaceSetConfiguration::MTU);
	soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, &this->tt__NetworkInterfaceSetConfiguration::IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, &this->tt__NetworkInterfaceSetConfiguration::IPv6);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, &this->tt__NetworkInterfaceSetConfiguration::Extension);
#endif
}

int tt__NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &a->tt__NetworkInterfaceSetConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", -1, &a->tt__NetworkInterfaceSetConfiguration::Link, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->tt__NetworkInterfaceSetConfiguration::MTU, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", -1, &a->tt__NetworkInterfaceSetConfiguration::IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", -1, &a->tt__NetworkInterfaceSetConfiguration::IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", -1, &a->tt__NetworkInterfaceSetConfiguration::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceSetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(tt__NetworkInterfaceSetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceSetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Link1 = 1;
	size_t soap_flag_MTU1 = 1;
	size_t soap_flag_IPv41 = 1;
	size_t soap_flag_IPv61 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Enabled", &a->tt__NetworkInterfaceSetConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Link1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", &a->tt__NetworkInterfaceSetConfiguration::Link, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_Link1--;
					continue;
				}
			}
			if (soap_flag_MTU1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:MTU", &a->tt__NetworkInterfaceSetConfiguration::MTU, "xsd:int"))
				{	soap_flag_MTU1--;
					continue;
				}
			}
			if (soap_flag_IPv41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", &a->tt__NetworkInterfaceSetConfiguration::IPv4, "tt:IPv4NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv41--;
					continue;
				}
			}
			if (soap_flag_IPv61 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", &a->tt__NetworkInterfaceSetConfiguration::IPv6, "tt:IPv6NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv61--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", &a->tt__NetworkInterfaceSetConfiguration::Extension, "tt:NetworkInterfaceSetConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(tt__NetworkInterfaceSetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceSetConfiguration *p;
	size_t k = sizeof(tt__NetworkInterfaceSetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceSetConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceSetConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceSetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:NetworkInterfaceSetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DynamicDNSInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__DynamicDNSInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__DynamicDNSInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DynamicDNSInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, const tt__DynamicDNSInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DynamicDNSInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DynamicDNSInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_in_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, tt__DynamicDNSInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DynamicDNSInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(tt__DynamicDNSInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DynamicDNSInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DynamicDNSInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DynamicDNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformationExtension, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(tt__DynamicDNSInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DynamicDNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DynamicDNSInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DynamicDNSInformationExtension *p;
	size_t k = sizeof(tt__DynamicDNSInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DynamicDNSInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DynamicDNSInformationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DynamicDNSInformationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DynamicDNSInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DynamicDNSInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DynamicDNSInformationExtension(soap, tag ? tag : "tt:DynamicDNSInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DynamicDNSInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DynamicDNSInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_get_tt__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DynamicDNSInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DynamicDNSType(soap, &this->tt__DynamicDNSInformation::Type);
	this->tt__DynamicDNSInformation::Name = NULL;
	this->tt__DynamicDNSInformation::TTL = NULL;
	this->tt__DynamicDNSInformation::Extension = NULL;
}

void tt__DynamicDNSInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSName(soap, &this->tt__DynamicDNSInformation::Name);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__DynamicDNSInformation::TTL);
	soap_serialize_PointerTott__DynamicDNSInformationExtension(soap, &this->tt__DynamicDNSInformation::Extension);
#endif
}

int tt__DynamicDNSInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DynamicDNSInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformation(struct soap *soap, const char *tag, int id, const tt__DynamicDNSInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformation), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tt:Type", -1, &a->tt__DynamicDNSInformation::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:Name", -1, &a->tt__DynamicDNSInformation::Name, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:TTL", -1, &a->tt__DynamicDNSInformation::TTL, ""))
		return soap->error;
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", -1, &a->tt__DynamicDNSInformation::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DynamicDNSInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DynamicDNSInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__DynamicDNSInformation * SOAP_FMAC4 soap_in_tt__DynamicDNSInformation(struct soap *soap, const char *tag, tt__DynamicDNSInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DynamicDNSInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(tt__DynamicDNSInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DynamicDNSInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DynamicDNSInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TTL1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DynamicDNSType(soap, "tt:Type", &a->tt__DynamicDNSInformation::Type, "tt:DynamicDNSType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__DNSName(soap, "tt:Name", &a->tt__DynamicDNSInformation::Name, "tt:DNSName"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_TTL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tt:TTL", &a->tt__DynamicDNSInformation::TTL, "xsd:duration"))
				{	soap_flag_TTL1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", &a->tt__DynamicDNSInformation::Extension, "tt:DynamicDNSInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DynamicDNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformation, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(tt__DynamicDNSInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DynamicDNSInformation * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DynamicDNSInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DynamicDNSInformation *p;
	size_t k = sizeof(tt__DynamicDNSInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DynamicDNSInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DynamicDNSInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DynamicDNSInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DynamicDNSInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DynamicDNSInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DynamicDNSInformation(soap, tag ? tag : "tt:DynamicDNSInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DynamicDNSInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DynamicDNSInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__DynamicDNSInformation * SOAP_FMAC4 soap_get_tt__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NTPInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__NTPInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__NTPInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NTPInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformationExtension(struct soap *soap, const char *tag, int id, const tt__NTPInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NTPInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NTPInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NTPInformationExtension * SOAP_FMAC4 soap_in_tt__NTPInformationExtension(struct soap *soap, const char *tag, tt__NTPInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NTPInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(tt__NTPInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NTPInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NTPInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NTPInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformationExtension, SOAP_TYPE_tt__NTPInformationExtension, sizeof(tt__NTPInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NTPInformationExtension * SOAP_FMAC2 soap_instantiate_tt__NTPInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NTPInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NTPInformationExtension *p;
	size_t k = sizeof(tt__NTPInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NTPInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NTPInformationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NTPInformationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NTPInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NTPInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NTPInformationExtension(soap, tag ? tag : "tt:NTPInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NTPInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NTPInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NTPInformationExtension * SOAP_FMAC4 soap_get_tt__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NTPInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__NTPInformation::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPFromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPManual);
	this->tt__NTPInformation::Extension = NULL;
}

void tt__NTPInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NTPInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPFromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPManual);
	soap_serialize_PointerTott__NTPInformationExtension(soap, &this->tt__NTPInformation::Extension);
#endif
}

int tt__NTPInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NTPInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformation(struct soap *soap, const char *tag, int id, const tt__NTPInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformation), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &a->tt__NTPInformation::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPFromDHCP", -1, &a->tt__NTPInformation::NTPFromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPManual", -1, &a->tt__NTPInformation::NTPManual, ""))
		return soap->error;
	if (soap_out_PointerTott__NTPInformationExtension(soap, "tt:Extension", -1, &a->tt__NTPInformation::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NTPInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NTPInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__NTPInformation * SOAP_FMAC4 soap_in_tt__NTPInformation(struct soap *soap, const char *tag, tt__NTPInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NTPInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformation, sizeof(tt__NTPInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NTPInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NTPInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FromDHCP", &a->tt__NTPInformation::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPFromDHCP", &a->tt__NTPInformation::NTPFromDHCP, "tt:NetworkHost"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPManual", &a->tt__NTPInformation::NTPManual, "tt:NetworkHost"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NTPInformationExtension(soap, "tt:Extension", &a->tt__NTPInformation::Extension, "tt:NTPInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NTPInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformation, SOAP_TYPE_tt__NTPInformation, sizeof(tt__NTPInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NTPInformation * SOAP_FMAC2 soap_instantiate_tt__NTPInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NTPInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NTPInformation *p;
	size_t k = sizeof(tt__NTPInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NTPInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NTPInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NTPInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NTPInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NTPInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NTPInformation(soap, tag ? tag : "tt:NTPInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NTPInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NTPInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__NTPInformation * SOAP_FMAC4 soap_get_tt__NTPInformation(struct soap *soap, tt__NTPInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DNSInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__DNSInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__DNSInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DNSInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformationExtension(struct soap *soap, const char *tag, int id, const tt__DNSInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DNSInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DNSInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DNSInformationExtension * SOAP_FMAC4 soap_in_tt__DNSInformationExtension(struct soap *soap, const char *tag, tt__DNSInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DNSInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(tt__DNSInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DNSInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DNSInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DNSInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformationExtension, SOAP_TYPE_tt__DNSInformationExtension, sizeof(tt__DNSInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DNSInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DNSInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DNSInformationExtension *p;
	size_t k = sizeof(tt__DNSInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DNSInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DNSInformationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DNSInformationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DNSInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DNSInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DNSInformationExtension(soap, tag ? tag : "tt:DNSInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DNSInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DNSInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DNSInformationExtension * SOAP_FMAC4 soap_get_tt__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DNSInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__DNSInformation::FromDHCP);
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->tt__DNSInformation::SearchDomain);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSFromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSManual);
	this->tt__DNSInformation::Extension = NULL;
}

void tt__DNSInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DNSInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->tt__DNSInformation::SearchDomain);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSFromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSManual);
	soap_serialize_PointerTott__DNSInformationExtension(soap, &this->tt__DNSInformation::Extension);
#endif
}

int tt__DNSInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DNSInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformation(struct soap *soap, const char *tag, int id, const tt__DNSInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformation), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &a->tt__DNSInformation::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tt:SearchDomain", -1, &a->tt__DNSInformation::SearchDomain, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSFromDHCP", -1, &a->tt__DNSInformation::DNSFromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSManual", -1, &a->tt__DNSInformation::DNSManual, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSInformationExtension(soap, "tt:Extension", -1, &a->tt__DNSInformation::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DNSInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DNSInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__DNSInformation * SOAP_FMAC4 soap_in_tt__DNSInformation(struct soap *soap, const char *tag, tt__DNSInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DNSInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformation, sizeof(tt__DNSInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DNSInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DNSInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FromDHCP", &a->tt__DNSInformation::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tt:SearchDomain", &a->tt__DNSInformation::SearchDomain, "xsd:token"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSFromDHCP", &a->tt__DNSInformation::DNSFromDHCP, "tt:IPAddress"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSManual", &a->tt__DNSInformation::DNSManual, "tt:IPAddress"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DNSInformationExtension(soap, "tt:Extension", &a->tt__DNSInformation::Extension, "tt:DNSInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformation, SOAP_TYPE_tt__DNSInformation, sizeof(tt__DNSInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DNSInformation * SOAP_FMAC2 soap_instantiate_tt__DNSInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DNSInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DNSInformation *p;
	size_t k = sizeof(tt__DNSInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DNSInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DNSInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DNSInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DNSInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DNSInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DNSInformation(soap, tag ? tag : "tt:DNSInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DNSInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DNSInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__DNSInformation * SOAP_FMAC4 soap_get_tt__DNSInformation(struct soap *soap, tt__DNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__HostnameInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__HostnameInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__HostnameInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__HostnameInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformationExtension(struct soap *soap, const char *tag, int id, const tt__HostnameInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__HostnameInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__HostnameInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__HostnameInformationExtension * SOAP_FMAC4 soap_in_tt__HostnameInformationExtension(struct soap *soap, const char *tag, tt__HostnameInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__HostnameInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(tt__HostnameInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__HostnameInformationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__HostnameInformationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__HostnameInformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformationExtension, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(tt__HostnameInformationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__HostnameInformationExtension * SOAP_FMAC2 soap_instantiate_tt__HostnameInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__HostnameInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__HostnameInformationExtension *p;
	size_t k = sizeof(tt__HostnameInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__HostnameInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__HostnameInformationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__HostnameInformationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__HostnameInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__HostnameInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__HostnameInformationExtension(soap, tag ? tag : "tt:HostnameInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__HostnameInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__HostnameInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__HostnameInformationExtension * SOAP_FMAC4 soap_get_tt__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__HostnameInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__HostnameInformation::FromDHCP);
	this->tt__HostnameInformation::Name = NULL;
	this->tt__HostnameInformation::Extension = NULL;
}

void tt__HostnameInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__HostnameInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_PointerToxsd__token(soap, &this->tt__HostnameInformation::Name);
	soap_serialize_PointerTott__HostnameInformationExtension(soap, &this->tt__HostnameInformation::Extension);
#endif
}

int tt__HostnameInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__HostnameInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformation(struct soap *soap, const char *tag, int id, const tt__HostnameInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformation), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &a->tt__HostnameInformation::FromDHCP, ""))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:Name", -1, &a->tt__HostnameInformation::Name, ""))
		return soap->error;
	if (soap_out_PointerTott__HostnameInformationExtension(soap, "tt:Extension", -1, &a->tt__HostnameInformation::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__HostnameInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__HostnameInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__HostnameInformation * SOAP_FMAC4 soap_in_tt__HostnameInformation(struct soap *soap, const char *tag, tt__HostnameInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__HostnameInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformation, sizeof(tt__HostnameInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__HostnameInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__HostnameInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FromDHCP", &a->tt__HostnameInformation::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tt:Name", &a->tt__HostnameInformation::Name, "xsd:token"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__HostnameInformationExtension(soap, "tt:Extension", &a->tt__HostnameInformation::Extension, "tt:HostnameInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__HostnameInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformation, SOAP_TYPE_tt__HostnameInformation, sizeof(tt__HostnameInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__HostnameInformation * SOAP_FMAC2 soap_instantiate_tt__HostnameInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__HostnameInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__HostnameInformation *p;
	size_t k = sizeof(tt__HostnameInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__HostnameInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__HostnameInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__HostnameInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__HostnameInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__HostnameInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__HostnameInformation(soap, tag ? tag : "tt:HostnameInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__HostnameInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__HostnameInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__HostnameInformation * SOAP_FMAC4 soap_get_tt__HostnameInformation(struct soap *soap, tt__HostnameInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PrefixedIPv6Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__IPv6Address(soap, &this->tt__PrefixedIPv6Address::Address);
	soap_default_int(soap, &this->tt__PrefixedIPv6Address::PrefixLength);
}

void tt__PrefixedIPv6Address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PrefixedIPv6Address::Address, SOAP_TYPE_tt__IPv6Address);
	soap_serialize_tt__IPv6Address(soap, &this->tt__PrefixedIPv6Address::Address);
	soap_embedded(soap, &this->tt__PrefixedIPv6Address::PrefixLength, SOAP_TYPE_int);
#endif
}

int tt__PrefixedIPv6Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PrefixedIPv6Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const tt__PrefixedIPv6Address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv6Address), type))
		return soap->error;
	if (soap_out_tt__IPv6Address(soap, "tt:Address", -1, &a->tt__PrefixedIPv6Address::Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->tt__PrefixedIPv6Address::PrefixLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PrefixedIPv6Address::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PrefixedIPv6Address(soap, tag, this, type);
}

SOAP_FMAC3 tt__PrefixedIPv6Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, tt__PrefixedIPv6Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PrefixedIPv6Address*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PrefixedIPv6Address)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PrefixedIPv6Address *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_PrefixLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv6Address(soap, "tt:Address", &a->tt__PrefixedIPv6Address::Address, "tt:IPv6Address"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_PrefixLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:PrefixLength", &a->tt__PrefixedIPv6Address::PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address1 > 0 || soap_flag_PrefixLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PrefixedIPv6Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv6Address, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PrefixedIPv6Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PrefixedIPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PrefixedIPv6Address *p;
	size_t k = sizeof(tt__PrefixedIPv6Address);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PrefixedIPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PrefixedIPv6Address);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PrefixedIPv6Address, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PrefixedIPv6Address location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PrefixedIPv6Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PrefixedIPv6Address(soap, tag ? tag : "tt:PrefixedIPv6Address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PrefixedIPv6Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PrefixedIPv6Address(soap, this, tag, type);
}

SOAP_FMAC3 tt__PrefixedIPv6Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PrefixedIPv4Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__IPv4Address(soap, &this->tt__PrefixedIPv4Address::Address);
	soap_default_int(soap, &this->tt__PrefixedIPv4Address::PrefixLength);
}

void tt__PrefixedIPv4Address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PrefixedIPv4Address::Address, SOAP_TYPE_tt__IPv4Address);
	soap_serialize_tt__IPv4Address(soap, &this->tt__PrefixedIPv4Address::Address);
	soap_embedded(soap, &this->tt__PrefixedIPv4Address::PrefixLength, SOAP_TYPE_int);
#endif
}

int tt__PrefixedIPv4Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PrefixedIPv4Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const tt__PrefixedIPv4Address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv4Address), type))
		return soap->error;
	if (soap_out_tt__IPv4Address(soap, "tt:Address", -1, &a->tt__PrefixedIPv4Address::Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->tt__PrefixedIPv4Address::PrefixLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PrefixedIPv4Address::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PrefixedIPv4Address(soap, tag, this, type);
}

SOAP_FMAC3 tt__PrefixedIPv4Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, tt__PrefixedIPv4Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PrefixedIPv4Address*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PrefixedIPv4Address)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PrefixedIPv4Address *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_PrefixLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv4Address(soap, "tt:Address", &a->tt__PrefixedIPv4Address::Address, "tt:IPv4Address"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_PrefixLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:PrefixLength", &a->tt__PrefixedIPv4Address::PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address1 > 0 || soap_flag_PrefixLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PrefixedIPv4Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv4Address, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PrefixedIPv4Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PrefixedIPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PrefixedIPv4Address *p;
	size_t k = sizeof(tt__PrefixedIPv4Address);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PrefixedIPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PrefixedIPv4Address);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PrefixedIPv4Address, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PrefixedIPv4Address location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PrefixedIPv4Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PrefixedIPv4Address(soap, tag ? tag : "tt:PrefixedIPv4Address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PrefixedIPv4Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PrefixedIPv4Address(soap, this, tag, type);
}

SOAP_FMAC3 tt__PrefixedIPv4Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddress::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__IPType(soap, &this->tt__IPAddress::Type);
	this->tt__IPAddress::IPv4Address = NULL;
	this->tt__IPAddress::IPv6Address = NULL;
}

void tt__IPAddress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPv4Address(soap, &this->tt__IPAddress::IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &this->tt__IPAddress::IPv6Address);
#endif
}

int tt__IPAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap *soap, const char *tag, int id, const tt__IPAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddress), type))
		return soap->error;
	if (soap_out_tt__IPType(soap, "tt:Type", -1, &a->tt__IPAddress::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->tt__IPAddress::IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->tt__IPAddress::IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddress(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap *soap, const char *tag, tt__IPAddress *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddress*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddress)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPAddress *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_IPv4Address1 = 1;
	size_t soap_flag_IPv6Address1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPType(soap, "tt:Type", &a->tt__IPAddress::Type, "tt:IPType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_IPv4Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->tt__IPAddress::IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address1--;
					continue;
				}
			}
			if (soap_flag_IPv6Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->tt__IPAddress::IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 soap_instantiate_tt__IPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddress *p;
	size_t k = sizeof(tt__IPAddress);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddress);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddress, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddress location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddress(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap *soap, tt__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkHostExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__NetworkHostExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__NetworkHostExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkHostExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostExtension(struct soap *soap, const char *tag, int id, const tt__NetworkHostExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHostExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkHostExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkHostExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkHostExtension * SOAP_FMAC4 soap_in_tt__NetworkHostExtension(struct soap *soap, const char *tag, tt__NetworkHostExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkHostExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(tt__NetworkHostExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkHostExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkHostExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkHostExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHostExtension, SOAP_TYPE_tt__NetworkHostExtension, sizeof(tt__NetworkHostExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkHostExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkHostExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkHostExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkHostExtension *p;
	size_t k = sizeof(tt__NetworkHostExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkHostExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkHostExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkHostExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkHostExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkHostExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkHostExtension(soap, tag ? tag : "tt:NetworkHostExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkHostExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkHostExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkHostExtension * SOAP_FMAC4 soap_get_tt__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkHost::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__NetworkHostType(soap, &this->tt__NetworkHost::Type);
	this->tt__NetworkHost::IPv4Address = NULL;
	this->tt__NetworkHost::IPv6Address = NULL;
	this->tt__NetworkHost::DNSname = NULL;
	this->tt__NetworkHost::Extension = NULL;
}

void tt__NetworkHost::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPv4Address(soap, &this->tt__NetworkHost::IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &this->tt__NetworkHost::IPv6Address);
	soap_serialize_PointerTott__DNSName(soap, &this->tt__NetworkHost::DNSname);
	soap_serialize_PointerTott__NetworkHostExtension(soap, &this->tt__NetworkHost::Extension);
#endif
}

int tt__NetworkHost::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkHost(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHost(struct soap *soap, const char *tag, int id, const tt__NetworkHost *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHost), type))
		return soap->error;
	if (soap_out_tt__NetworkHostType(soap, "tt:Type", -1, &a->tt__NetworkHost::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->tt__NetworkHost::IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->tt__NetworkHost::IPv6Address, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:DNSname", -1, &a->tt__NetworkHost::DNSname, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkHostExtension(soap, "tt:Extension", -1, &a->tt__NetworkHost::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkHost::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkHost(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkHost * SOAP_FMAC4 soap_in_tt__NetworkHost(struct soap *soap, const char *tag, tt__NetworkHost *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkHost*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHost, sizeof(tt__NetworkHost), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkHost)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkHost *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_IPv4Address1 = 1;
	size_t soap_flag_IPv6Address1 = 1;
	size_t soap_flag_DNSname1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__NetworkHostType(soap, "tt:Type", &a->tt__NetworkHost::Type, "tt:NetworkHostType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_IPv4Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->tt__NetworkHost::IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address1--;
					continue;
				}
			}
			if (soap_flag_IPv6Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->tt__NetworkHost::IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address1--;
					continue;
				}
			}
			if (soap_flag_DNSname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__DNSName(soap, "tt:DNSname", &a->tt__NetworkHost::DNSname, "tt:DNSName"))
				{	soap_flag_DNSname1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkHostExtension(soap, "tt:Extension", &a->tt__NetworkHost::Extension, "tt:NetworkHostExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_tt__NetworkHost, sizeof(tt__NetworkHost), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkHost * SOAP_FMAC2 soap_instantiate_tt__NetworkHost(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkHost(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkHost *p;
	size_t k = sizeof(tt__NetworkHost);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkHost, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkHost);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkHost, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkHost location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkHost::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkHost(soap, tag ? tag : "tt:NetworkHost", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkHost::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkHost(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkHost * SOAP_FMAC4 soap_get_tt__NetworkHost(struct soap *soap, tt__NetworkHost *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkProtocolExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__NetworkProtocolExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__NetworkProtocolExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkProtocolExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, const tt__NetworkProtocolExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocolExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkProtocolExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkProtocolExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkProtocolExtension * SOAP_FMAC4 soap_in_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, tt__NetworkProtocolExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkProtocolExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(tt__NetworkProtocolExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkProtocolExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkProtocolExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkProtocolExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocolExtension, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(tt__NetworkProtocolExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkProtocolExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkProtocolExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkProtocolExtension *p;
	size_t k = sizeof(tt__NetworkProtocolExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkProtocolExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkProtocolExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkProtocolExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkProtocolExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkProtocolExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkProtocolExtension(soap, tag ? tag : "tt:NetworkProtocolExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkProtocolExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkProtocolExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkProtocolExtension * SOAP_FMAC4 soap_get_tt__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkProtocol::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__NetworkProtocolType(soap, &this->tt__NetworkProtocol::Name);
	soap_default_bool(soap, &this->tt__NetworkProtocol::Enabled);
	soap_default_std__vectorTemplateOfint(soap, &this->tt__NetworkProtocol::Port);
	this->tt__NetworkProtocol::Extension = NULL;
}

void tt__NetworkProtocol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkProtocol::Enabled, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfint(soap, &this->tt__NetworkProtocol::Port);
	soap_serialize_PointerTott__NetworkProtocolExtension(soap, &this->tt__NetworkProtocol::Extension);
#endif
}

int tt__NetworkProtocol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkProtocol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocol(struct soap *soap, const char *tag, int id, const tt__NetworkProtocol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocol), type))
		return soap->error;
	if (soap_out_tt__NetworkProtocolType(soap, "tt:Name", -1, &a->tt__NetworkProtocol::Name, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__NetworkProtocol::Enabled, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "tt:Port", -1, &a->tt__NetworkProtocol::Port, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", -1, &a->tt__NetworkProtocol::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkProtocol::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkProtocol(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkProtocol * SOAP_FMAC4 soap_in_tt__NetworkProtocol(struct soap *soap, const char *tag, tt__NetworkProtocol *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkProtocol*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocol, sizeof(tt__NetworkProtocol), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkProtocol)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkProtocol *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__NetworkProtocolType(soap, "tt:Name", &a->tt__NetworkProtocol::Name, "tt:NetworkProtocolType"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__NetworkProtocol::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfint(soap, "tt:Port", &a->tt__NetworkProtocol::Port, "xsd:int"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", &a->tt__NetworkProtocol::Extension, "tt:NetworkProtocolExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_Enabled1 > 0 || a->tt__NetworkProtocol::Port.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocol, SOAP_TYPE_tt__NetworkProtocol, sizeof(tt__NetworkProtocol), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkProtocol * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkProtocol(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkProtocol *p;
	size_t k = sizeof(tt__NetworkProtocol);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkProtocol, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkProtocol);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkProtocol, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkProtocol location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkProtocol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkProtocol(soap, tag ? tag : "tt:NetworkProtocol", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkProtocol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkProtocol(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkProtocol * SOAP_FMAC4 soap_get_tt__NetworkProtocol(struct soap *soap, tt__NetworkProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6ConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__IPv6ConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__IPv6ConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6ConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__IPv6ConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6ConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6ConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_in_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, tt__IPv6ConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6ConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(tt__IPv6ConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6ConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6ConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv6ConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6ConfigurationExtension, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(tt__IPv6ConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6ConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__IPv6ConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6ConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6ConfigurationExtension *p;
	size_t k = sizeof(tt__IPv6ConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6ConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6ConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6ConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6ConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6ConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6ConfigurationExtension(soap, tag ? tag : "tt:IPv6ConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6ConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6ConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_get_tt__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__IPv6Configuration::AcceptRouterAdvert = NULL;
	soap_default_tt__IPv6DHCPConfiguration(soap, &this->tt__IPv6Configuration::DHCP);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::Manual);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::LinkLocal);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromRA);
	this->tt__IPv6Configuration::Extension = NULL;
}

void tt__IPv6Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IPv6Configuration::AcceptRouterAdvert);
	soap_embedded(soap, &this->tt__IPv6Configuration::DHCP, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::Manual);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::LinkLocal);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromRA);
	soap_serialize_PointerTott__IPv6ConfigurationExtension(soap, &this->tt__IPv6Configuration::Extension);
#endif
}

int tt__IPv6Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Configuration(struct soap *soap, const char *tag, int id, const tt__IPv6Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6Configuration), type))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:AcceptRouterAdvert", -1, &a->tt__IPv6Configuration::AcceptRouterAdvert, ""))
		return soap->error;
	if (soap_out_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->tt__IPv6Configuration::DHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", -1, &a->tt__IPv6Configuration::Manual, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:LinkLocal", -1, &a->tt__IPv6Configuration::LinkLocal, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromDHCP", -1, &a->tt__IPv6Configuration::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromRA", -1, &a->tt__IPv6Configuration::FromRA, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", -1, &a->tt__IPv6Configuration::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6Configuration * SOAP_FMAC4 soap_in_tt__IPv6Configuration(struct soap *soap, const char *tag, tt__IPv6Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6Configuration, sizeof(tt__IPv6Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AcceptRouterAdvert1 = 1;
	size_t soap_flag_DHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcceptRouterAdvert1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:AcceptRouterAdvert", &a->tt__IPv6Configuration::AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert1--;
					continue;
				}
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->tt__IPv6Configuration::DHCP, "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", &a->tt__IPv6Configuration::Manual, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:LinkLocal", &a->tt__IPv6Configuration::LinkLocal, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromDHCP", &a->tt__IPv6Configuration::FromDHCP, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromRA", &a->tt__IPv6Configuration::FromRA, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", &a->tt__IPv6Configuration::Extension, "tt:IPv6ConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv6Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6Configuration, SOAP_TYPE_tt__IPv6Configuration, sizeof(tt__IPv6Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv6Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6Configuration *p;
	size_t k = sizeof(tt__IPv6Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6Configuration(soap, tag ? tag : "tt:IPv6Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6Configuration * SOAP_FMAC4 soap_get_tt__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::Manual);
	this->tt__IPv4Configuration::LinkLocal = NULL;
	this->tt__IPv4Configuration::FromDHCP = NULL;
	soap_default_bool(soap, &this->tt__IPv4Configuration::DHCP);
}

void tt__IPv4Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::Manual);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::LinkLocal);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::FromDHCP);
	soap_embedded(soap, &this->tt__IPv4Configuration::DHCP, SOAP_TYPE_bool);
#endif
}

int tt__IPv4Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Configuration(struct soap *soap, const char *tag, int id, const tt__IPv4Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4Configuration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", -1, &a->tt__IPv4Configuration::Manual, ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", -1, &a->tt__IPv4Configuration::LinkLocal, ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", -1, &a->tt__IPv4Configuration::FromDHCP, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DHCP", -1, &a->tt__IPv4Configuration::DHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4Configuration * SOAP_FMAC4 soap_in_tt__IPv4Configuration(struct soap *soap, const char *tag, tt__IPv4Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4Configuration, sizeof(tt__IPv4Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv4Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LinkLocal1 = 1;
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", &a->tt__IPv4Configuration::Manual, "tt:PrefixedIPv4Address"))
					continue;
			}
			if (soap_flag_LinkLocal1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", &a->tt__IPv4Configuration::LinkLocal, "tt:PrefixedIPv4Address"))
				{	soap_flag_LinkLocal1--;
					continue;
				}
			}
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", &a->tt__IPv4Configuration::FromDHCP, "tt:PrefixedIPv4Address"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DHCP", &a->tt__IPv4Configuration::DHCP, "xsd:boolean"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4Configuration, SOAP_TYPE_tt__IPv4Configuration, sizeof(tt__IPv4Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv4Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4Configuration *p;
	size_t k = sizeof(tt__IPv4Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4Configuration(soap, tag ? tag : "tt:IPv4Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4Configuration * SOAP_FMAC4 soap_get_tt__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4NetworkInterface::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__IPv4NetworkInterface::Enabled);
	this->tt__IPv4NetworkInterface::Config = NULL;
}

void tt__IPv4NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv4NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__IPv4Configuration(soap, &this->tt__IPv4NetworkInterface::Config);
#endif
}

int tt__IPv4NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, const tt__IPv4NetworkInterface *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterface), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__IPv4NetworkInterface::Enabled, ""))
		return soap->error;
	if (!a->tt__IPv4NetworkInterface::Config)
	{	if (soap_element_empty(soap, "tt:Config", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPv4Configuration(soap, "tt:Config", -1, &a->tt__IPv4NetworkInterface::Config, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, tt__IPv4NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4NetworkInterface*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4NetworkInterface)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv4NetworkInterface *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Config1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__IPv4NetworkInterface::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4Configuration(soap, "tt:Config", &a->tt__IPv4NetworkInterface::Config, "tt:IPv4Configuration"))
				{	soap_flag_Config1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0 || !a->tt__IPv4NetworkInterface::Config))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv4NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterface, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4NetworkInterface *p;
	size_t k = sizeof(tt__IPv4NetworkInterface);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4NetworkInterface);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4NetworkInterface, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4NetworkInterface location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4NetworkInterface(soap, tag ? tag : "tt:IPv4NetworkInterface", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6NetworkInterface::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__IPv6NetworkInterface::Enabled);
	this->tt__IPv6NetworkInterface::Config = NULL;
}

void tt__IPv6NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv6NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__IPv6Configuration(soap, &this->tt__IPv6NetworkInterface::Config);
#endif
}

int tt__IPv6NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, const tt__IPv6NetworkInterface *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterface), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__IPv6NetworkInterface::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Configuration(soap, "tt:Config", -1, &a->tt__IPv6NetworkInterface::Config, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, tt__IPv6NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6NetworkInterface*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6NetworkInterface)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6NetworkInterface *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Config1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__IPv6NetworkInterface::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6Configuration(soap, "tt:Config", &a->tt__IPv6NetworkInterface::Config, "tt:IPv6Configuration"))
				{	soap_flag_Config1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv6NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterface, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6NetworkInterface *p;
	size_t k = sizeof(tt__IPv6NetworkInterface);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6NetworkInterface);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6NetworkInterface, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6NetworkInterface location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6NetworkInterface(soap, tag ? tag : "tt:IPv6NetworkInterface", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__NetworkInterfaceInfo::Name = NULL;
	soap_default_tt__HwAddress(soap, &this->tt__NetworkInterfaceInfo::HwAddress);
	this->tt__NetworkInterfaceInfo::MTU = NULL;
}

void tt__NetworkInterfaceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->tt__NetworkInterfaceInfo::Name);
	soap_serialize_tt__HwAddress(soap, &this->tt__NetworkInterfaceInfo::HwAddress);
	soap_serialize_PointerToint(soap, &this->tt__NetworkInterfaceInfo::MTU);
#endif
}

int tt__NetworkInterfaceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceInfo), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Name", -1, &a->tt__NetworkInterfaceInfo::Name, ""))
		return soap->error;
	if (soap_out_tt__HwAddress(soap, "tt:HwAddress", -1, &a->tt__NetworkInterfaceInfo::HwAddress, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->tt__NetworkInterfaceInfo::MTU, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceInfo(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_in_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, tt__NetworkInterfaceInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_HwAddress1 = 1;
	size_t soap_flag_MTU1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Name", &a->tt__NetworkInterfaceInfo::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_HwAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__HwAddress(soap, "tt:HwAddress", &a->tt__NetworkInterfaceInfo::HwAddress, "tt:HwAddress"))
				{	soap_flag_HwAddress1--;
					continue;
				}
			}
			if (soap_flag_MTU1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:MTU", &a->tt__NetworkInterfaceInfo::MTU, "xsd:int"))
				{	soap_flag_MTU1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HwAddress1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceInfo, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceInfo * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceInfo *p;
	size_t k = sizeof(tt__NetworkInterfaceInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceInfo(soap, tag ? tag : "tt:NetworkInterfaceInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceInfo(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_get_tt__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceConnectionSetting::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__NetworkInterfaceConnectionSetting::AutoNegotiation);
	soap_default_int(soap, &this->tt__NetworkInterfaceConnectionSetting::Speed);
	soap_default_tt__Duplex(soap, &this->tt__NetworkInterfaceConnectionSetting::Duplex);
}

void tt__NetworkInterfaceConnectionSetting::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkInterfaceConnectionSetting::AutoNegotiation, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__NetworkInterfaceConnectionSetting::Speed, SOAP_TYPE_int);
#endif
}

int tt__NetworkInterfaceConnectionSetting::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoNegotiation", -1, &a->tt__NetworkInterfaceConnectionSetting::AutoNegotiation, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Speed", -1, &a->tt__NetworkInterfaceConnectionSetting::Speed, ""))
		return soap->error;
	if (soap_out_tt__Duplex(soap, "tt:Duplex", -1, &a->tt__NetworkInterfaceConnectionSetting::Duplex, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceConnectionSetting::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_in_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceConnectionSetting*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(tt__NetworkInterfaceConnectionSetting), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceConnectionSetting)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceConnectionSetting *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AutoNegotiation1 = 1;
	size_t soap_flag_Speed1 = 1;
	size_t soap_flag_Duplex1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoNegotiation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoNegotiation", &a->tt__NetworkInterfaceConnectionSetting::AutoNegotiation, "xsd:boolean"))
				{	soap_flag_AutoNegotiation1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Speed", &a->tt__NetworkInterfaceConnectionSetting::Speed, "xsd:int"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_Duplex1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Duplex(soap, "tt:Duplex", &a->tt__NetworkInterfaceConnectionSetting::Duplex, "tt:Duplex"))
				{	soap_flag_Duplex1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoNegotiation1 > 0 || soap_flag_Speed1 > 0 || soap_flag_Duplex1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceConnectionSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(tt__NetworkInterfaceConnectionSetting), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConnectionSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceConnectionSetting(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceConnectionSetting *p;
	size_t k = sizeof(tt__NetworkInterfaceConnectionSetting);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceConnectionSetting);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceConnectionSetting, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceConnectionSetting location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceConnectionSetting::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag ? tag : "tt:NetworkInterfaceConnectionSetting", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceConnectionSetting::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceConnectionSetting(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_get_tt__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__NetworkInterfaceLink::AdminSettings = NULL;
	this->tt__NetworkInterfaceLink::OperSettings = NULL;
	soap_default_tt__IANA_IfTypes(soap, &this->tt__NetworkInterfaceLink::InterfaceType);
}

void tt__NetworkInterfaceLink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceLink::AdminSettings);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceLink::OperSettings);
#endif
}

int tt__NetworkInterfaceLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceLink), type))
		return soap->error;
	if (!a->tt__NetworkInterfaceLink::AdminSettings)
	{	if (soap_element_empty(soap, "tt:AdminSettings", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", -1, &a->tt__NetworkInterfaceLink::AdminSettings, ""))
		return soap->error;
	if (!a->tt__NetworkInterfaceLink::OperSettings)
	{	if (soap_element_empty(soap, "tt:OperSettings", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", -1, &a->tt__NetworkInterfaceLink::OperSettings, ""))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->tt__NetworkInterfaceLink::InterfaceType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceLink::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceLink(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceLink * SOAP_FMAC4 soap_in_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, tt__NetworkInterfaceLink *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceLink*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceLink)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceLink *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AdminSettings1 = 1;
	size_t soap_flag_OperSettings1 = 1;
	size_t soap_flag_InterfaceType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AdminSettings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", &a->tt__NetworkInterfaceLink::AdminSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_AdminSettings1--;
					continue;
				}
			}
			if (soap_flag_OperSettings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", &a->tt__NetworkInterfaceLink::OperSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_OperSettings1--;
					continue;
				}
			}
			if (soap_flag_InterfaceType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->tt__NetworkInterfaceLink::InterfaceType, "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__NetworkInterfaceLink::AdminSettings || !a->tt__NetworkInterfaceLink::OperSettings || soap_flag_InterfaceType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceLink, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceLink * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceLink *p;
	size_t k = sizeof(tt__NetworkInterfaceLink);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceLink, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceLink);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceLink, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceLink location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceLink(soap, tag ? tag : "tt:NetworkInterfaceLink", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceLink(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceLink * SOAP_FMAC4 soap_get_tt__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__NetworkInterfaceExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__NetworkInterfaceExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(tt__NetworkInterfaceExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension2, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(tt__NetworkInterfaceExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceExtension2 *p;
	size_t k = sizeof(tt__NetworkInterfaceExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceExtension2(soap, tag ? tag : "tt:NetworkInterfaceExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot3Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__Dot3Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Dot3Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot3Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot3Configuration(struct soap *soap, const char *tag, int id, const tt__Dot3Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot3Configuration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot3Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot3Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot3Configuration * SOAP_FMAC4 soap_in_tt__Dot3Configuration(struct soap *soap, const char *tag, tt__Dot3Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot3Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot3Configuration, sizeof(tt__Dot3Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot3Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot3Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot3Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot3Configuration, SOAP_TYPE_tt__Dot3Configuration, sizeof(tt__Dot3Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot3Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot3Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot3Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot3Configuration *p;
	size_t k = sizeof(tt__Dot3Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot3Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot3Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot3Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot3Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot3Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot3Configuration(soap, tag ? tag : "tt:Dot3Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot3Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot3Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot3Configuration * SOAP_FMAC4 soap_get_tt__Dot3Configuration(struct soap *soap, tt__Dot3Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__IANA_IfTypes(soap, &this->tt__NetworkInterfaceExtension::InterfaceType);
	soap_default_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot3);
	soap_default_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot11);
	this->tt__NetworkInterfaceExtension::Extension = NULL;
}

void tt__NetworkInterfaceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot3);
	soap_serialize_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot11);
	soap_serialize_PointerTott__NetworkInterfaceExtension2(soap, &this->tt__NetworkInterfaceExtension::Extension);
#endif
}

int tt__NetworkInterfaceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension), type))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->tt__NetworkInterfaceExtension::InterfaceType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", -1, &a->tt__NetworkInterfaceExtension::Dot3, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", -1, &a->tt__NetworkInterfaceExtension::Dot11, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", -1, &a->tt__NetworkInterfaceExtension::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceType1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->tt__NetworkInterfaceExtension::InterfaceType, "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", &a->tt__NetworkInterfaceExtension::Dot3, "tt:Dot3Configuration"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", &a->tt__NetworkInterfaceExtension::Dot11, "tt:Dot11Configuration"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", &a->tt__NetworkInterfaceExtension::Extension, "tt:NetworkInterfaceExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceExtension *p;
	size_t k = sizeof(tt__NetworkInterfaceExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceExtension(soap, tag ? tag : "tt:NetworkInterfaceExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterface::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	soap_default_bool(soap, &this->tt__NetworkInterface::Enabled);
	this->tt__NetworkInterface::Info = NULL;
	this->tt__NetworkInterface::Link = NULL;
	this->tt__NetworkInterface::IPv4 = NULL;
	this->tt__NetworkInterface::IPv6 = NULL;
	this->tt__NetworkInterface::Extension = NULL;
}

void tt__NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__NetworkInterfaceInfo(soap, &this->tt__NetworkInterface::Info);
	soap_serialize_PointerTott__NetworkInterfaceLink(soap, &this->tt__NetworkInterface::Link);
	soap_serialize_PointerTott__IPv4NetworkInterface(soap, &this->tt__NetworkInterface::IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterface(soap, &this->tt__NetworkInterface::IPv6);
	soap_serialize_PointerTott__NetworkInterfaceExtension(soap, &this->tt__NetworkInterface::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterface(struct soap *soap, const char *tag, int id, const tt__NetworkInterface *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterface), type ? type : "tt:NetworkInterface"))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__NetworkInterface::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", -1, &a->tt__NetworkInterface::Info, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, "tt:Link", -1, &a->tt__NetworkInterface::Link, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", -1, &a->tt__NetworkInterface::IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", -1, &a->tt__NetworkInterface::IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", -1, &a->tt__NetworkInterface::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterface * SOAP_FMAC4 soap_in_tt__NetworkInterface(struct soap *soap, const char *tag, tt__NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterface*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterface, sizeof(tt__NetworkInterface), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterface)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterface *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Info1 = 1;
	size_t soap_flag_Link1 = 1;
	size_t soap_flag_IPv41 = 1;
	size_t soap_flag_IPv61 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__NetworkInterface::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Info1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", &a->tt__NetworkInterface::Info, "tt:NetworkInterfaceInfo"))
				{	soap_flag_Info1--;
					continue;
				}
			}
			if (soap_flag_Link1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceLink(soap, "tt:Link", &a->tt__NetworkInterface::Link, "tt:NetworkInterfaceLink"))
				{	soap_flag_Link1--;
					continue;
				}
			}
			if (soap_flag_IPv41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", &a->tt__NetworkInterface::IPv4, "tt:IPv4NetworkInterface"))
				{	soap_flag_IPv41--;
					continue;
				}
			}
			if (soap_flag_IPv61 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", &a->tt__NetworkInterface::IPv6, "tt:IPv6NetworkInterface"))
				{	soap_flag_IPv61--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", &a->tt__NetworkInterface::Extension, "tt:NetworkInterfaceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterface, SOAP_TYPE_tt__NetworkInterface, sizeof(tt__NetworkInterface), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterface *p;
	size_t k = sizeof(tt__NetworkInterface);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterface);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterface, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterface location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterface(soap, tag ? tag : "tt:NetworkInterface", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterface * SOAP_FMAC4 soap_get_tt__NetworkInterface(struct soap *soap, tt__NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Scope::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ScopeDefinition(soap, &this->tt__Scope::ScopeDef);
	soap_default_xsd__anyURI(soap, &this->tt__Scope::ScopeItem);
}

void tt__Scope::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Scope::ScopeItem, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Scope::ScopeItem);
#endif
}

int tt__Scope::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Scope(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Scope(struct soap *soap, const char *tag, int id, const tt__Scope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Scope), type))
		return soap->error;
	if (soap_out_tt__ScopeDefinition(soap, "tt:ScopeDef", -1, &a->tt__Scope::ScopeDef, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:ScopeItem", -1, &a->tt__Scope::ScopeItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Scope::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Scope(soap, tag, this, type);
}

SOAP_FMAC3 tt__Scope * SOAP_FMAC4 soap_in_tt__Scope(struct soap *soap, const char *tag, tt__Scope *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Scope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Scope, sizeof(tt__Scope), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Scope)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Scope *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ScopeDef1 = 1;
	size_t soap_flag_ScopeItem1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScopeDef1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ScopeDefinition(soap, "tt:ScopeDef", &a->tt__Scope::ScopeDef, "tt:ScopeDefinition"))
				{	soap_flag_ScopeDef1--;
					continue;
				}
			}
			if (soap_flag_ScopeItem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:ScopeItem", &a->tt__Scope::ScopeItem, "xsd:anyURI"))
				{	soap_flag_ScopeItem1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScopeDef1 > 0 || soap_flag_ScopeItem1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Scope, SOAP_TYPE_tt__Scope, sizeof(tt__Scope), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Scope * SOAP_FMAC2 soap_instantiate_tt__Scope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Scope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Scope *p;
	size_t k = sizeof(tt__Scope);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Scope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Scope);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Scope, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Scope location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Scope::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Scope(soap, tag ? tag : "tt:Scope", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Scope::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Scope(soap, this, tag, type);
}

SOAP_FMAC3 tt__Scope * SOAP_FMAC4 soap_get_tt__Scope(struct soap *soap, tt__Scope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
}

void tt__DeviceEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__DeviceEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceEntity(struct soap *soap, const char *tag, int id, const tt__DeviceEntity *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceEntity), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_in_tt__DeviceEntity(struct soap *soap, const char *tag, tt__DeviceEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceEntity, sizeof(tt__DeviceEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DeviceEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceEntity, SOAP_TYPE_tt__DeviceEntity, sizeof(tt__DeviceEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tds:StorageConfiguration"))
		return soap_instantiate_tds__StorageConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterface"))
		return soap_instantiate_tt__NetworkInterface(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelayOutput"))
		return soap_instantiate_tt__RelayOutput(soap, n, NULL, NULL, size);
	tt__DeviceEntity *p;
	size_t k = sizeof(tt__DeviceEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceEntity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceEntity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceEntity(soap, tag ? tag : "tt:DeviceEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_get_tt__DeviceEntity(struct soap *soap, tt__DeviceEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteGeoLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteGeoLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteGeoLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteGeoLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteGeoLocationResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteGeoLocationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteGeoLocationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteGeoLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteGeoLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocationResponse * SOAP_FMAC4 soap_in__tds__DeleteGeoLocationResponse(struct soap *soap, const char *tag, _tds__DeleteGeoLocationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteGeoLocationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteGeoLocationResponse, sizeof(_tds__DeleteGeoLocationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteGeoLocationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteGeoLocationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteGeoLocationResponse, SOAP_TYPE__tds__DeleteGeoLocationResponse, sizeof(_tds__DeleteGeoLocationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteGeoLocationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteGeoLocationResponse *p;
	size_t k = sizeof(_tds__DeleteGeoLocationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteGeoLocationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteGeoLocationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteGeoLocationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteGeoLocationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteGeoLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteGeoLocationResponse(soap, tag ? tag : "tds:DeleteGeoLocationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteGeoLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteGeoLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocationResponse * SOAP_FMAC4 soap_get__tds__DeleteGeoLocationResponse(struct soap *soap, _tds__DeleteGeoLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteGeoLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteGeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__DeleteGeoLocation::Location);
}

void _tds__DeleteGeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__DeleteGeoLocation::Location);
#endif
}

int _tds__DeleteGeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteGeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteGeoLocation(struct soap *soap, const char *tag, int id, const _tds__DeleteGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteGeoLocation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", -1, &a->_tds__DeleteGeoLocation::Location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteGeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteGeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocation * SOAP_FMAC4 soap_in__tds__DeleteGeoLocation(struct soap *soap, const char *tag, _tds__DeleteGeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteGeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(_tds__DeleteGeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteGeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteGeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", &a->_tds__DeleteGeoLocation::Location, "tt:LocationEntity"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__DeleteGeoLocation::Location.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteGeoLocation, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(_tds__DeleteGeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteGeoLocation *p;
	size_t k = sizeof(_tds__DeleteGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteGeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteGeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteGeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteGeoLocation(soap, tag ? tag : "tds:DeleteGeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteGeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteGeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocation * SOAP_FMAC4 soap_get__tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetGeoLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetGeoLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetGeoLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetGeoLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetGeoLocationResponse(struct soap *soap, const char *tag, int id, const _tds__SetGeoLocationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetGeoLocationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetGeoLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetGeoLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetGeoLocationResponse * SOAP_FMAC4 soap_in__tds__SetGeoLocationResponse(struct soap *soap, const char *tag, _tds__SetGeoLocationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetGeoLocationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetGeoLocationResponse, sizeof(_tds__SetGeoLocationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetGeoLocationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetGeoLocationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetGeoLocationResponse, SOAP_TYPE__tds__SetGeoLocationResponse, sizeof(_tds__SetGeoLocationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetGeoLocationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetGeoLocationResponse *p;
	size_t k = sizeof(_tds__SetGeoLocationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetGeoLocationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetGeoLocationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetGeoLocationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetGeoLocationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetGeoLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetGeoLocationResponse(soap, tag ? tag : "tds:SetGeoLocationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetGeoLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetGeoLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetGeoLocationResponse * SOAP_FMAC4 soap_get__tds__SetGeoLocationResponse(struct soap *soap, _tds__SetGeoLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetGeoLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetGeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__SetGeoLocation::Location);
}

void _tds__SetGeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__SetGeoLocation::Location);
#endif
}

int _tds__SetGeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetGeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetGeoLocation(struct soap *soap, const char *tag, int id, const _tds__SetGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetGeoLocation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", -1, &a->_tds__SetGeoLocation::Location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetGeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetGeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetGeoLocation * SOAP_FMAC4 soap_in__tds__SetGeoLocation(struct soap *soap, const char *tag, _tds__SetGeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetGeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetGeoLocation, sizeof(_tds__SetGeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetGeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetGeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", &a->_tds__SetGeoLocation::Location, "tt:LocationEntity"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__SetGeoLocation::Location.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetGeoLocation, SOAP_TYPE__tds__SetGeoLocation, sizeof(_tds__SetGeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetGeoLocation *p;
	size_t k = sizeof(_tds__SetGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetGeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetGeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetGeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetGeoLocation(soap, tag ? tag : "tds:SetGeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetGeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetGeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetGeoLocation * SOAP_FMAC4 soap_get__tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetGeoLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__GetGeoLocationResponse::Location);
}

void _tds__GetGeoLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__GetGeoLocationResponse::Location);
#endif
}

int _tds__GetGeoLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetGeoLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetGeoLocationResponse(struct soap *soap, const char *tag, int id, const _tds__GetGeoLocationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetGeoLocationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Location");
	if (soap_out_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", -1, &a->_tds__GetGeoLocationResponse::Location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetGeoLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetGeoLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetGeoLocationResponse * SOAP_FMAC4 soap_in__tds__GetGeoLocationResponse(struct soap *soap, const char *tag, _tds__GetGeoLocationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetGeoLocationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetGeoLocationResponse, sizeof(_tds__GetGeoLocationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetGeoLocationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetGeoLocationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", &a->_tds__GetGeoLocationResponse::Location, "tt:LocationEntity"))
					continue;
			}
			soap_check_result(soap, "tds:Location");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetGeoLocationResponse, SOAP_TYPE__tds__GetGeoLocationResponse, sizeof(_tds__GetGeoLocationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetGeoLocationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetGeoLocationResponse *p;
	size_t k = sizeof(_tds__GetGeoLocationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetGeoLocationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetGeoLocationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetGeoLocationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetGeoLocationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetGeoLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetGeoLocationResponse(soap, tag ? tag : "tds:GetGeoLocationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetGeoLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetGeoLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetGeoLocationResponse * SOAP_FMAC4 soap_get__tds__GetGeoLocationResponse(struct soap *soap, _tds__GetGeoLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetGeoLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetGeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetGeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetGeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetGeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetGeoLocation(struct soap *soap, const char *tag, int id, const _tds__GetGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetGeoLocation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetGeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetGeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetGeoLocation * SOAP_FMAC4 soap_in__tds__GetGeoLocation(struct soap *soap, const char *tag, _tds__GetGeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetGeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetGeoLocation, sizeof(_tds__GetGeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetGeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetGeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetGeoLocation, SOAP_TYPE__tds__GetGeoLocation, sizeof(_tds__GetGeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetGeoLocation *p;
	size_t k = sizeof(_tds__GetGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetGeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetGeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetGeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetGeoLocation(soap, tag ? tag : "tds:GetGeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetGeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetGeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetGeoLocation * SOAP_FMAC4 soap_get__tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__DeleteStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(_tds__DeleteStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(_tds__DeleteStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__DeleteStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteStorageConfigurationResponse(soap, tag ? tag : "tds:DeleteStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteStorageConfigurationResponse(struct soap *soap, _tds__DeleteStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__DeleteStorageConfiguration::Token);
}

void _tds__DeleteStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__DeleteStorageConfiguration::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__DeleteStorageConfiguration::Token);
#endif
}

int _tds__DeleteStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__DeleteStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteStorageConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, &a->_tds__DeleteStorageConfiguration::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_in__tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, _tds__DeleteStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(_tds__DeleteStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", &a->_tds__DeleteStorageConfiguration::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteStorageConfiguration, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(_tds__DeleteStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteStorageConfiguration *p;
	size_t k = sizeof(_tds__DeleteStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteStorageConfiguration(soap, tag ? tag : "tds:DeleteStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_get__tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetStorageConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__SetStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(_tds__SetStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetStorageConfigurationResponse, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(_tds__SetStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__SetStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetStorageConfigurationResponse(soap, tag ? tag : "tds:SetStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetStorageConfigurationResponse(struct soap *soap, _tds__SetStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetStorageConfiguration::StorageConfiguration = NULL;
}

void _tds__SetStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfiguration(soap, &this->_tds__SetStorageConfiguration::StorageConfiguration);
#endif
}

int _tds__SetStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetStorageConfiguration), type))
		return soap->error;
	if (!a->_tds__SetStorageConfiguration::StorageConfiguration)
	{	if (soap_element_empty(soap, "tds:StorageConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", -1, &a->_tds__SetStorageConfiguration::StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetStorageConfiguration * SOAP_FMAC4 soap_in__tds__SetStorageConfiguration(struct soap *soap, const char *tag, _tds__SetStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(_tds__SetStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StorageConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", &a->_tds__SetStorageConfiguration::StorageConfiguration, "tds:StorageConfiguration"))
				{	soap_flag_StorageConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__SetStorageConfiguration::StorageConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetStorageConfiguration, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(_tds__SetStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetStorageConfiguration *p;
	size_t k = sizeof(_tds__SetStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetStorageConfiguration(soap, tag ? tag : "tds:SetStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetStorageConfiguration * SOAP_FMAC4 soap_get__tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetStorageConfigurationResponse::StorageConfiguration = NULL;
}

void _tds__GetStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfiguration(soap, &this->_tds__GetStorageConfigurationResponse::StorageConfiguration);
#endif
}

int _tds__GetStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurationResponse), type))
		return soap->error;
	if (a->StorageConfiguration)
		soap_element_result(soap, "tds:StorageConfiguration");
	if (!a->_tds__GetStorageConfigurationResponse::StorageConfiguration)
	{	if (soap_element_empty(soap, "tds:StorageConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", -1, &a->_tds__GetStorageConfigurationResponse::StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__GetStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(_tds__GetStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StorageConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", &a->_tds__GetStorageConfigurationResponse::StorageConfiguration, "tds:StorageConfiguration"))
				{	soap_flag_StorageConfiguration1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:StorageConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetStorageConfigurationResponse::StorageConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationResponse, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(_tds__GetStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__GetStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfigurationResponse(soap, tag ? tag : "tds:GetStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetStorageConfigurationResponse(struct soap *soap, _tds__GetStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetStorageConfiguration::Token);
}

void _tds__GetStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetStorageConfiguration::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetStorageConfiguration::Token);
#endif
}

int _tds__GetStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, &a->_tds__GetStorageConfiguration::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfiguration * SOAP_FMAC4 soap_in__tds__GetStorageConfiguration(struct soap *soap, const char *tag, _tds__GetStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(_tds__GetStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", &a->_tds__GetStorageConfiguration::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfiguration, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(_tds__GetStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfiguration *p;
	size_t k = sizeof(_tds__GetStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfiguration(soap, tag ? tag : "tds:GetStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfiguration * SOAP_FMAC4 soap_get__tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__CreateStorageConfigurationResponse::Token);
}

void _tds__CreateStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__CreateStorageConfigurationResponse::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__CreateStorageConfigurationResponse::Token);
#endif
}

int _tds__CreateStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__CreateStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Token");
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, &a->_tds__CreateStorageConfigurationResponse::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__CreateStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(_tds__CreateStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", &a->_tds__CreateStorageConfigurationResponse::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Token");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfigurationResponse, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(_tds__CreateStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__CreateStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateStorageConfigurationResponse(soap, tag ? tag : "tds:CreateStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateStorageConfigurationResponse(struct soap *soap, _tds__CreateStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateStorageConfiguration::StorageConfiguration = NULL;
}

void _tds__CreateStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfigurationData(soap, &this->_tds__CreateStorageConfiguration::StorageConfiguration);
#endif
}

int _tds__CreateStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__CreateStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateStorageConfiguration), type))
		return soap->error;
	if (!a->_tds__CreateStorageConfiguration::StorageConfiguration)
	{	if (soap_element_empty(soap, "tds:StorageConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfigurationData(soap, "tds:StorageConfiguration", -1, &a->_tds__CreateStorageConfiguration::StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_in__tds__CreateStorageConfiguration(struct soap *soap, const char *tag, _tds__CreateStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(_tds__CreateStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StorageConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfigurationData(soap, "tds:StorageConfiguration", &a->_tds__CreateStorageConfiguration::StorageConfiguration, "tds:StorageConfigurationData"))
				{	soap_flag_StorageConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__CreateStorageConfiguration::StorageConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfiguration, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(_tds__CreateStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateStorageConfiguration *p;
	size_t k = sizeof(_tds__CreateStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateStorageConfiguration(soap, tag ? tag : "tds:CreateStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_get__tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, &this->_tds__GetStorageConfigurationsResponse::StorageConfigurations);
}

void _tds__GetStorageConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, &this->_tds__GetStorageConfigurationsResponse::StorageConfigurations);
#endif
}

int _tds__GetStorageConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurationsResponse(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:StorageConfigurations");
	if (soap_out_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, "tds:StorageConfigurations", -1, &a->_tds__GetStorageConfigurationsResponse::StorageConfigurations, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetStorageConfigurationsResponse(struct soap *soap, const char *tag, _tds__GetStorageConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(_tds__GetStorageConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, "tds:StorageConfigurations", &a->_tds__GetStorageConfigurationsResponse::StorageConfigurations, "tds:StorageConfiguration"))
					continue;
			}
			soap_check_result(soap, "tds:StorageConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetStorageConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationsResponse, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(_tds__GetStorageConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfigurationsResponse *p;
	size_t k = sizeof(_tds__GetStorageConfigurationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfigurationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfigurationsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfigurationsResponse(soap, tag ? tag : "tds:GetStorageConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetStorageConfigurationsResponse(struct soap *soap, _tds__GetStorageConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetStorageConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetStorageConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurations(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurations * SOAP_FMAC4 soap_in__tds__GetStorageConfigurations(struct soap *soap, const char *tag, _tds__GetStorageConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(_tds__GetStorageConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetStorageConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurations, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(_tds__GetStorageConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfigurations *p;
	size_t k = sizeof(_tds__GetStorageConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfigurations(soap, tag ? tag : "tds:GetStorageConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurations * SOAP_FMAC4 soap_get__tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHashingAlgorithmResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetHashingAlgorithmResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetHashingAlgorithmResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHashingAlgorithmResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHashingAlgorithmResponse(struct soap *soap, const char *tag, int id, const _tds__SetHashingAlgorithmResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHashingAlgorithmResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHashingAlgorithmResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHashingAlgorithmResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHashingAlgorithmResponse * SOAP_FMAC4 soap_in__tds__SetHashingAlgorithmResponse(struct soap *soap, const char *tag, _tds__SetHashingAlgorithmResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHashingAlgorithmResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHashingAlgorithmResponse, sizeof(_tds__SetHashingAlgorithmResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHashingAlgorithmResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHashingAlgorithmResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetHashingAlgorithmResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHashingAlgorithmResponse, SOAP_TYPE__tds__SetHashingAlgorithmResponse, sizeof(_tds__SetHashingAlgorithmResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHashingAlgorithmResponse * SOAP_FMAC2 soap_instantiate__tds__SetHashingAlgorithmResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHashingAlgorithmResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHashingAlgorithmResponse *p;
	size_t k = sizeof(_tds__SetHashingAlgorithmResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHashingAlgorithmResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHashingAlgorithmResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHashingAlgorithmResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHashingAlgorithmResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHashingAlgorithmResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHashingAlgorithmResponse(soap, tag ? tag : "tds:SetHashingAlgorithmResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHashingAlgorithmResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHashingAlgorithmResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHashingAlgorithmResponse * SOAP_FMAC4 soap_get__tds__SetHashingAlgorithmResponse(struct soap *soap, _tds__SetHashingAlgorithmResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHashingAlgorithmResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHashingAlgorithm::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__StringList(soap, &this->_tds__SetHashingAlgorithm::Algorithm);
}

void _tds__SetHashingAlgorithm::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHashingAlgorithm::Algorithm, SOAP_TYPE_tt__StringList);
	soap_serialize_tt__StringList(soap, &this->_tds__SetHashingAlgorithm::Algorithm);
#endif
}

int _tds__SetHashingAlgorithm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHashingAlgorithm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHashingAlgorithm(struct soap *soap, const char *tag, int id, const _tds__SetHashingAlgorithm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHashingAlgorithm), type))
		return soap->error;
	if (soap_out_tt__StringList(soap, "tds:Algorithm", -1, &a->_tds__SetHashingAlgorithm::Algorithm, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHashingAlgorithm::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHashingAlgorithm(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHashingAlgorithm * SOAP_FMAC4 soap_in__tds__SetHashingAlgorithm(struct soap *soap, const char *tag, _tds__SetHashingAlgorithm *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHashingAlgorithm*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHashingAlgorithm, sizeof(_tds__SetHashingAlgorithm), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHashingAlgorithm)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHashingAlgorithm *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Algorithm1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Algorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__StringList(soap, "tds:Algorithm", &a->_tds__SetHashingAlgorithm::Algorithm, "tt:StringList"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Algorithm1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHashingAlgorithm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHashingAlgorithm, SOAP_TYPE__tds__SetHashingAlgorithm, sizeof(_tds__SetHashingAlgorithm), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHashingAlgorithm * SOAP_FMAC2 soap_instantiate__tds__SetHashingAlgorithm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHashingAlgorithm(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHashingAlgorithm *p;
	size_t k = sizeof(_tds__SetHashingAlgorithm);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHashingAlgorithm, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHashingAlgorithm);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHashingAlgorithm, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHashingAlgorithm location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHashingAlgorithm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHashingAlgorithm(soap, tag ? tag : "tds:SetHashingAlgorithm", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHashingAlgorithm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHashingAlgorithm(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHashingAlgorithm * SOAP_FMAC4 soap_get__tds__SetHashingAlgorithm(struct soap *soap, _tds__SetHashingAlgorithm *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHashingAlgorithm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartSystemRestoreResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__StartSystemRestoreResponse::UploadUri);
	soap_default_xsd__duration(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime);
}

void _tds__StartSystemRestoreResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__StartSystemRestoreResponse::UploadUri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->_tds__StartSystemRestoreResponse::UploadUri);
	soap_embedded(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime);
#endif
}

int _tds__StartSystemRestoreResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartSystemRestoreResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, const _tds__StartSystemRestoreResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestoreResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:UploadUri");
	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, &a->_tds__StartSystemRestoreResponse::UploadUri, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &a->_tds__StartSystemRestoreResponse::ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartSystemRestoreResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartSystemRestoreResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_in__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, _tds__StartSystemRestoreResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartSystemRestoreResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(_tds__StartSystemRestoreResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartSystemRestoreResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartSystemRestoreResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UploadUri1 = 1;
	size_t soap_flag_ExpectedDownTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:UploadUri", &a->_tds__StartSystemRestoreResponse::UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri1--;
					continue;
				}
			}
			if (soap_flag_ExpectedDownTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &a->_tds__StartSystemRestoreResponse::ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri1 > 0 || soap_flag_ExpectedDownTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__StartSystemRestoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestoreResponse, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(_tds__StartSystemRestoreResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartSystemRestoreResponse * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestoreResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartSystemRestoreResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartSystemRestoreResponse *p;
	size_t k = sizeof(_tds__StartSystemRestoreResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartSystemRestoreResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartSystemRestoreResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartSystemRestoreResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartSystemRestoreResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartSystemRestoreResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartSystemRestoreResponse(soap, tag ? tag : "tds:StartSystemRestoreResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartSystemRestoreResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartSystemRestoreResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_get__tds__StartSystemRestoreResponse(struct soap *soap, _tds__StartSystemRestoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartSystemRestore::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__StartSystemRestore::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__StartSystemRestore::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartSystemRestore(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const _tds__StartSystemRestore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestore), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartSystemRestore::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartSystemRestore(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartSystemRestore * SOAP_FMAC4 soap_in__tds__StartSystemRestore(struct soap *soap, const char *tag, _tds__StartSystemRestore *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartSystemRestore*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestore, sizeof(_tds__StartSystemRestore), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartSystemRestore)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartSystemRestore *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StartSystemRestore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestore, SOAP_TYPE__tds__StartSystemRestore, sizeof(_tds__StartSystemRestore), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartSystemRestore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartSystemRestore *p;
	size_t k = sizeof(_tds__StartSystemRestore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartSystemRestore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartSystemRestore);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartSystemRestore, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartSystemRestore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartSystemRestore::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartSystemRestore(soap, tag ? tag : "tds:StartSystemRestore", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartSystemRestore::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartSystemRestore(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartSystemRestore * SOAP_FMAC4 soap_get__tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartFirmwareUpgradeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri);
	soap_default_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay);
	soap_default_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime);
}

void _tds__StartFirmwareUpgradeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri);
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay);
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime);
#endif
}

int _tds__StartFirmwareUpgradeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartFirmwareUpgradeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, const _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:UploadUri");
	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, &a->_tds__StartFirmwareUpgradeResponse::UploadUri, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:UploadDelay", -1, &a->_tds__StartFirmwareUpgradeResponse::UploadDelay, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &a->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartFirmwareUpgradeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartFirmwareUpgradeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(_tds__StartFirmwareUpgradeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartFirmwareUpgradeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartFirmwareUpgradeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UploadUri1 = 1;
	size_t soap_flag_UploadDelay1 = 1;
	size_t soap_flag_ExpectedDownTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:UploadUri", &a->_tds__StartFirmwareUpgradeResponse::UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri1--;
					continue;
				}
			}
			if (soap_flag_UploadDelay1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tds:UploadDelay", &a->_tds__StartFirmwareUpgradeResponse::UploadDelay, "xsd:duration"))
				{	soap_flag_UploadDelay1--;
					continue;
				}
			}
			if (soap_flag_ExpectedDownTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &a->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri1 > 0 || soap_flag_UploadDelay1 > 0 || soap_flag_ExpectedDownTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__StartFirmwareUpgradeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(_tds__StartFirmwareUpgradeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgradeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartFirmwareUpgradeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartFirmwareUpgradeResponse *p;
	size_t k = sizeof(_tds__StartFirmwareUpgradeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartFirmwareUpgradeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartFirmwareUpgradeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartFirmwareUpgradeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartFirmwareUpgradeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartFirmwareUpgradeResponse(soap, tag ? tag : "tds:StartFirmwareUpgradeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartFirmwareUpgradeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartFirmwareUpgradeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgradeResponse(struct soap *soap, _tds__StartFirmwareUpgradeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartFirmwareUpgrade::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__StartFirmwareUpgrade::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__StartFirmwareUpgrade::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartFirmwareUpgrade(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const _tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgrade), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartFirmwareUpgrade::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartFirmwareUpgrade(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, _tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartFirmwareUpgrade*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(_tds__StartFirmwareUpgrade), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartFirmwareUpgrade)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartFirmwareUpgrade *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StartFirmwareUpgrade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgrade, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(_tds__StartFirmwareUpgrade), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgrade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartFirmwareUpgrade(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartFirmwareUpgrade *p;
	size_t k = sizeof(_tds__StartFirmwareUpgrade);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartFirmwareUpgrade, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartFirmwareUpgrade);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartFirmwareUpgrade, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartFirmwareUpgrade location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartFirmwareUpgrade::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartFirmwareUpgrade(soap, tag ? tag : "tds:StartFirmwareUpgrade", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartFirmwareUpgrade::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartFirmwareUpgrade(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemUrisResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetSystemUrisResponse::SystemLogUris = NULL;
	this->_tds__GetSystemUrisResponse::SupportInfoUri = NULL;
	this->_tds__GetSystemUrisResponse::SystemBackupUri = NULL;
	this->_tds__GetSystemUrisResponse::Extension = NULL;
}

void _tds__GetSystemUrisResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemLogUriList(soap, &this->_tds__GetSystemUrisResponse::SystemLogUris);
	soap_serialize_PointerToxsd__anyURI(soap, &this->_tds__GetSystemUrisResponse::SupportInfoUri);
	soap_serialize_PointerToxsd__anyURI(soap, &this->_tds__GetSystemUrisResponse::SystemBackupUri);
	soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(soap, &this->_tds__GetSystemUrisResponse::Extension);
#endif
}

int _tds__GetSystemUrisResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemUrisResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemUrisResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse), type))
		return soap->error;
	if (a->SystemLogUris)
		soap_element_result(soap, "tds:SystemLogUris");
	if (soap_out_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", -1, &a->_tds__GetSystemUrisResponse::SystemLogUris, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tds:SupportInfoUri", -1, &a->_tds__GetSystemUrisResponse::SupportInfoUri, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tds:SystemBackupUri", -1, &a->_tds__GetSystemUrisResponse::SystemBackupUri, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", -1, &a->_tds__GetSystemUrisResponse::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemUrisResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemUrisResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, _tds__GetSystemUrisResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemUrisResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(_tds__GetSystemUrisResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemUrisResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemUrisResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SystemLogUris1 = 1;
	size_t soap_flag_SupportInfoUri1 = 1;
	size_t soap_flag_SystemBackupUri1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLogUris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", &a->_tds__GetSystemUrisResponse::SystemLogUris, "tt:SystemLogUriList"))
				{	soap_flag_SystemLogUris1--;
					continue;
				}
			}
			if (soap_flag_SupportInfoUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tds:SupportInfoUri", &a->_tds__GetSystemUrisResponse::SupportInfoUri, "xsd:anyURI"))
				{	soap_flag_SupportInfoUri1--;
					continue;
				}
			}
			if (soap_flag_SystemBackupUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tds:SystemBackupUri", &a->_tds__GetSystemUrisResponse::SystemBackupUri, "xsd:anyURI"))
				{	soap_flag_SystemBackupUri1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", &a->_tds__GetSystemUrisResponse::Extension, ""))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemLogUris");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemUrisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(_tds__GetSystemUrisResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemUrisResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemUrisResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemUrisResponse *p;
	size_t k = sizeof(_tds__GetSystemUrisResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemUrisResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemUrisResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemUrisResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemUrisResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemUrisResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemUrisResponse(soap, tag ? tag : "tds:GetSystemUrisResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemUrisResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemUrisResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse(struct soap *soap, _tds__GetSystemUrisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemUris::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetSystemUris::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemUris::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemUris(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUris(struct soap *soap, const char *tag, int id, const _tds__GetSystemUris *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUris), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemUris::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemUris(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemUris * SOAP_FMAC4 soap_in__tds__GetSystemUris(struct soap *soap, const char *tag, _tds__GetSystemUris *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemUris*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUris, sizeof(_tds__GetSystemUris), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemUris)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemUris *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemUris *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUris, SOAP_TYPE__tds__GetSystemUris, sizeof(_tds__GetSystemUris), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemUris * SOAP_FMAC2 soap_instantiate__tds__GetSystemUris(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemUris(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemUris *p;
	size_t k = sizeof(_tds__GetSystemUris);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemUris, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemUris);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemUris, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemUris location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemUris::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemUris(soap, tag ? tag : "tds:GetSystemUris", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemUris::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemUris(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemUris * SOAP_FMAC4 soap_get__tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__ScanAvailableDot11NetworksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, &this->_tds__ScanAvailableDot11NetworksResponse::Networks);
}

void _tds__ScanAvailableDot11NetworksResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, &this->_tds__ScanAvailableDot11NetworksResponse::Networks);
#endif
}

int _tds__ScanAvailableDot11NetworksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, const _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Networks");
	if (soap_out_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, "tds:Networks", -1, &a->_tds__ScanAvailableDot11NetworksResponse::Networks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__ScanAvailableDot11NetworksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__ScanAvailableDot11NetworksResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(_tds__ScanAvailableDot11NetworksResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__ScanAvailableDot11NetworksResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, "tds:Networks", &a->_tds__ScanAvailableDot11NetworksResponse::Networks, "tt:Dot11AvailableNetworks"))
					continue;
			}
			soap_check_result(soap, "tds:Networks");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__ScanAvailableDot11NetworksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(_tds__ScanAvailableDot11NetworksResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__ScanAvailableDot11NetworksResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__ScanAvailableDot11NetworksResponse *p;
	size_t k = sizeof(_tds__ScanAvailableDot11NetworksResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__ScanAvailableDot11NetworksResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__ScanAvailableDot11NetworksResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__ScanAvailableDot11NetworksResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__ScanAvailableDot11NetworksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag ? tag : "tds:ScanAvailableDot11NetworksResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__ScanAvailableDot11NetworksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__ScanAvailableDot11NetworksResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, _tds__ScanAvailableDot11NetworksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__ScanAvailableDot11Networks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken);
}

void _tds__ScanAvailableDot11Networks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken);
#endif
}

int _tds__ScanAvailableDot11Networks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__ScanAvailableDot11Networks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const _tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__ScanAvailableDot11Networks::InterfaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__ScanAvailableDot11Networks::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__ScanAvailableDot11Networks(soap, tag, this, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, _tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__ScanAvailableDot11Networks*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(_tds__ScanAvailableDot11Networks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__ScanAvailableDot11Networks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__ScanAvailableDot11Networks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__ScanAvailableDot11Networks::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__ScanAvailableDot11Networks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11Networks, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(_tds__ScanAvailableDot11Networks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11Networks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__ScanAvailableDot11Networks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__ScanAvailableDot11Networks *p;
	size_t k = sizeof(_tds__ScanAvailableDot11Networks);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__ScanAvailableDot11Networks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__ScanAvailableDot11Networks);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__ScanAvailableDot11Networks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__ScanAvailableDot11Networks location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__ScanAvailableDot11Networks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__ScanAvailableDot11Networks(soap, tag ? tag : "tds:ScanAvailableDot11Networks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__ScanAvailableDot11Networks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__ScanAvailableDot11Networks(soap, this, tag, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11StatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot11StatusResponse::Status = NULL;
}

void _tds__GetDot11StatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Status(soap, &this->_tds__GetDot11StatusResponse::Status);
#endif
}

int _tds__GetDot11StatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11StatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot11StatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11StatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "tds:Status");
	if (!a->_tds__GetDot11StatusResponse::Status)
	{	if (soap_element_empty(soap, "tds:Status", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11Status(soap, "tds:Status", -1, &a->_tds__GetDot11StatusResponse::Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11StatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11StatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_in__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, _tds__GetDot11StatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11StatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(_tds__GetDot11StatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11StatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11StatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Status1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Status(soap, "tds:Status", &a->_tds__GetDot11StatusResponse::Status, "tt:Dot11Status"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetDot11StatusResponse::Status))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot11StatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11StatusResponse, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(_tds__GetDot11StatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11StatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11StatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11StatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11StatusResponse *p;
	size_t k = sizeof(_tds__GetDot11StatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11StatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11StatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11StatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11StatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11StatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11StatusResponse(soap, tag ? tag : "tds:GetDot11StatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11StatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11StatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_get__tds__GetDot11StatusResponse(struct soap *soap, _tds__GetDot11StatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetDot11Status::InterfaceToken);
}

void _tds__GetDot11Status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetDot11Status::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetDot11Status::InterfaceToken);
#endif
}

int _tds__GetDot11Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Status(struct soap *soap, const char *tag, int id, const _tds__GetDot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Status), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__GetDot11Status::InterfaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11Status::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11Status(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11Status * SOAP_FMAC4 soap_in__tds__GetDot11Status(struct soap *soap, const char *tag, _tds__GetDot11Status *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11Status*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Status, sizeof(_tds__GetDot11Status), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11Status)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11Status *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__GetDot11Status::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Status, SOAP_TYPE__tds__GetDot11Status, sizeof(_tds__GetDot11Status), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11Status * SOAP_FMAC2 soap_instantiate__tds__GetDot11Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11Status(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11Status *p;
	size_t k = sizeof(_tds__GetDot11Status);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11Status, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11Status);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11Status, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11Status location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11Status(soap, tag ? tag : "tds:GetDot11Status", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11Status(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11Status * SOAP_FMAC4 soap_get__tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11CapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot11CapabilitiesResponse::Capabilities = NULL;
}

void _tds__GetDot11CapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Capabilities(soap, &this->_tds__GetDot11CapabilitiesResponse::Capabilities);
#endif
}

int _tds__GetDot11CapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11CapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->_tds__GetDot11CapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", -1, &a->_tds__GetDot11CapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11CapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11CapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(_tds__GetDot11CapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11CapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11CapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", &a->_tds__GetDot11CapabilitiesResponse::Capabilities, "tt:Dot11Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetDot11CapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot11CapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(_tds__GetDot11CapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11CapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11CapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11CapabilitiesResponse *p;
	size_t k = sizeof(_tds__GetDot11CapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11CapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11CapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11CapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11CapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11CapabilitiesResponse(soap, tag ? tag : "tds:GetDot11CapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11CapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11CapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetDot11CapabilitiesResponse(struct soap *soap, _tds__GetDot11CapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDot11Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDot11Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const _tds__GetDot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11Capabilities * SOAP_FMAC4 soap_in__tds__GetDot11Capabilities(struct soap *soap, const char *tag, _tds__GetDot11Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(_tds__GetDot11Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Capabilities, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(_tds__GetDot11Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate__tds__GetDot11Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11Capabilities *p;
	size_t k = sizeof(_tds__GetDot11Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11Capabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11Capabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11Capabilities(soap, tag ? tag : "tds:GetDot11Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11Capabilities * SOAP_FMAC4 soap_get__tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SendAuxiliaryCommandResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse = NULL;
}

void _tds__SendAuxiliaryCommandResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse);
#endif
}

int _tds__SendAuxiliaryCommandResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SendAuxiliaryCommandResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryCommandResponse)
		soap_element_result(soap, "tds:AuxiliaryCommandResponse");
	if (soap_out_PointerTott__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", -1, &a->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SendAuxiliaryCommandResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SendAuxiliaryCommandResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(_tds__SendAuxiliaryCommandResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SendAuxiliaryCommandResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SendAuxiliaryCommandResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AuxiliaryCommandResponse1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommandResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", &a->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommandResponse1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:AuxiliaryCommandResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(_tds__SendAuxiliaryCommandResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SendAuxiliaryCommandResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SendAuxiliaryCommandResponse *p;
	size_t k = sizeof(_tds__SendAuxiliaryCommandResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SendAuxiliaryCommandResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SendAuxiliaryCommandResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SendAuxiliaryCommandResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SendAuxiliaryCommandResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SendAuxiliaryCommandResponse(soap, tag ? tag : "tds:SendAuxiliaryCommandResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SendAuxiliaryCommandResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SendAuxiliaryCommandResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommandResponse(struct soap *soap, _tds__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SendAuxiliaryCommand::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand);
}

void _tds__SendAuxiliaryCommand::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand, SOAP_TYPE_tt__AuxiliaryData);
	soap_serialize_tt__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand);
#endif
}

int _tds__SendAuxiliaryCommand::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SendAuxiliaryCommand(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const _tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommand), type))
		return soap->error;
	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", -1, &a->_tds__SendAuxiliaryCommand::AuxiliaryCommand, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SendAuxiliaryCommand::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SendAuxiliaryCommand(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SendAuxiliaryCommand*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(_tds__SendAuxiliaryCommand), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SendAuxiliaryCommand)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SendAuxiliaryCommand *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AuxiliaryCommand1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommand1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", &a->_tds__SendAuxiliaryCommand::AuxiliaryCommand, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommand1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuxiliaryCommand1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommand, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(_tds__SendAuxiliaryCommand), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SendAuxiliaryCommand(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SendAuxiliaryCommand *p;
	size_t k = sizeof(_tds__SendAuxiliaryCommand);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SendAuxiliaryCommand, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SendAuxiliaryCommand);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SendAuxiliaryCommand, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SendAuxiliaryCommand location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SendAuxiliaryCommand::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SendAuxiliaryCommand(soap, tag ? tag : "tds:SendAuxiliaryCommand", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SendAuxiliaryCommand::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SendAuxiliaryCommand(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetRelayOutputStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRelayOutputStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, _tds__SetRelayOutputStateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputStateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(_tds__SetRelayOutputStateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputStateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputStateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputStateResponse, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(_tds__SetRelayOutputStateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputStateResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputStateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputStateResponse *p;
	size_t k = sizeof(_tds__SetRelayOutputStateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputStateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputStateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputStateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputStateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputStateResponse(soap, tag ? tag : "tds:SetRelayOutputStateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputStateResponse(struct soap *soap, _tds__SetRelayOutputStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputState::RelayOutputToken);
	soap_default_tt__RelayLogicalState(soap, &this->_tds__SetRelayOutputState::LogicalState);
}

void _tds__SetRelayOutputState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetRelayOutputState::RelayOutputToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputState::RelayOutputToken);
#endif
}

int _tds__SetRelayOutputState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputState), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->_tds__SetRelayOutputState::RelayOutputToken, ""))
		return soap->error;
	if (soap_out_tt__RelayLogicalState(soap, "tds:LogicalState", -1, &a->_tds__SetRelayOutputState::LogicalState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputState::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputState(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputState * SOAP_FMAC4 soap_in__tds__SetRelayOutputState(struct soap *soap, const char *tag, _tds__SetRelayOutputState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(_tds__SetRelayOutputState), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputState)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputState *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RelayOutputToken1 = 1;
	size_t soap_flag_LogicalState1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->_tds__SetRelayOutputState::RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken1--;
					continue;
				}
			}
			if (soap_flag_LogicalState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayLogicalState(soap, "tds:LogicalState", &a->_tds__SetRelayOutputState::LogicalState, "tt:RelayLogicalState"))
				{	soap_flag_LogicalState1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken1 > 0 || soap_flag_LogicalState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputState, SOAP_TYPE__tds__SetRelayOutputState, sizeof(_tds__SetRelayOutputState), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputState *p;
	size_t k = sizeof(_tds__SetRelayOutputState);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputState, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputState);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputState, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputState location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputState(soap, tag ? tag : "tds:SetRelayOutputState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputState(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputState * SOAP_FMAC4 soap_get__tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputSettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetRelayOutputSettingsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRelayOutputSettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputSettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputSettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputSettingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(_tds__SetRelayOutputSettingsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputSettingsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputSettingsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(_tds__SetRelayOutputSettingsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputSettingsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputSettingsResponse *p;
	size_t k = sizeof(_tds__SetRelayOutputSettingsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputSettingsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputSettingsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputSettingsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputSettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputSettingsResponse(soap, tag ? tag : "tds:SetRelayOutputSettingsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputSettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputSettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettingsResponse(struct soap *soap, _tds__SetRelayOutputSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken);
	this->_tds__SetRelayOutputSettings::Properties = NULL;
}

void _tds__SetRelayOutputSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken);
	soap_serialize_PointerTott__RelayOutputSettings(soap, &this->_tds__SetRelayOutputSettings::Properties);
#endif
}

int _tds__SetRelayOutputSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettings), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->_tds__SetRelayOutputSettings::RelayOutputToken, ""))
		return soap->error;
	if (!a->_tds__SetRelayOutputSettings::Properties)
	{	if (soap_element_empty(soap, "tds:Properties", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RelayOutputSettings(soap, "tds:Properties", -1, &a->_tds__SetRelayOutputSettings::Properties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputSettings(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, _tds__SetRelayOutputSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(_tds__SetRelayOutputSettings), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputSettings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputSettings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RelayOutputToken1 = 1;
	size_t soap_flag_Properties1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->_tds__SetRelayOutputSettings::RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken1--;
					continue;
				}
			}
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelayOutputSettings(soap, "tds:Properties", &a->_tds__SetRelayOutputSettings::Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken1 > 0 || !a->_tds__SetRelayOutputSettings::Properties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettings, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(_tds__SetRelayOutputSettings), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputSettings *p;
	size_t k = sizeof(_tds__SetRelayOutputSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputSettings);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputSettings, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputSettings(soap, tag ? tag : "tds:SetRelayOutputSettings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputSettings(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRelayOutputsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__RelayOutput(soap, &this->_tds__GetRelayOutputsResponse::RelayOutputs);
}

void _tds__GetRelayOutputsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__RelayOutput(soap, &this->_tds__GetRelayOutputsResponse::RelayOutputs);
#endif
}

int _tds__GetRelayOutputsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRelayOutputsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, const _tds__GetRelayOutputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RelayOutputs");
	if (soap_out_std__vectorTemplateOfPointerTott__RelayOutput(soap, "tds:RelayOutputs", -1, &a->_tds__GetRelayOutputsResponse::RelayOutputs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRelayOutputsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRelayOutputsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_in__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, _tds__GetRelayOutputsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRelayOutputsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(_tds__GetRelayOutputsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRelayOutputsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRelayOutputsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__RelayOutput(soap, "tds:RelayOutputs", &a->_tds__GetRelayOutputsResponse::RelayOutputs, "tt:RelayOutput"))
					continue;
			}
			soap_check_result(soap, "tds:RelayOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRelayOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputsResponse, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(_tds__GetRelayOutputsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRelayOutputsResponse * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRelayOutputsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRelayOutputsResponse *p;
	size_t k = sizeof(_tds__GetRelayOutputsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRelayOutputsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRelayOutputsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRelayOutputsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRelayOutputsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRelayOutputsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRelayOutputsResponse(soap, tag ? tag : "tds:GetRelayOutputsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRelayOutputsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRelayOutputsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_get__tds__GetRelayOutputsResponse(struct soap *soap, _tds__GetRelayOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRelayOutputs::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetRelayOutputs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetRelayOutputs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRelayOutputs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const _tds__GetRelayOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRelayOutputs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRelayOutputs(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRelayOutputs * SOAP_FMAC4 soap_in__tds__GetRelayOutputs(struct soap *soap, const char *tag, _tds__GetRelayOutputs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRelayOutputs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(_tds__GetRelayOutputs), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRelayOutputs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRelayOutputs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRelayOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputs, SOAP_TYPE__tds__GetRelayOutputs, sizeof(_tds__GetRelayOutputs), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRelayOutputs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRelayOutputs *p;
	size_t k = sizeof(_tds__GetRelayOutputs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRelayOutputs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRelayOutputs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRelayOutputs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRelayOutputs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRelayOutputs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRelayOutputs(soap, tag ? tag : "tds:GetRelayOutputs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRelayOutputs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRelayOutputs(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRelayOutputs * SOAP_FMAC4 soap_get__tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(_tds__DeleteDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(_tds__DeleteDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__DeleteDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag ? tag : "tds:DeleteDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfigurationResponse(struct soap *soap, _tds__DeleteDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken);
}

void _tds__DeleteDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken);
#endif
}

int _tds__DeleteDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, &a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, _tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(_tds__DeleteDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", &a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken, "tt:ReferenceToken"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfiguration, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(_tds__DeleteDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteDot1XConfiguration *p;
	size_t k = sizeof(_tds__DeleteDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteDot1XConfiguration(soap, tag ? tag : "tds:DeleteDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, &this->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration);
}

void _tds__GetDot1XConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, &this->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration);
#endif
}

int _tds__GetDot1XConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Dot1XConfiguration");
	if (soap_out_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(_tds__GetDot1XConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration, "tt:Dot1XConfiguration"))
					continue;
			}
			soap_check_result(soap, "tds:Dot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(_tds__GetDot1XConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfigurationsResponse *p;
	size_t k = sizeof(_tds__GetDot1XConfigurationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfigurationsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfigurationsResponse(soap, tag ? tag : "tds:GetDot1XConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationsResponse(struct soap *soap, _tds__GetDot1XConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDot1XConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDot1XConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, _tds__GetDot1XConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(_tds__GetDot1XConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurations, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(_tds__GetDot1XConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfigurations *p;
	size_t k = sizeof(_tds__GetDot1XConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfigurations(soap, tag ? tag : "tds:GetDot1XConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration = NULL;
}

void _tds__GetDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration);
#endif
}

int _tds__GetDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse), type))
		return soap->error;
	if (a->Dot1XConfiguration)
		soap_element_result(soap, "tds:Dot1XConfiguration");
	if (!a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(_tds__GetDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Dot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationResponse, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(_tds__GetDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__GetDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfigurationResponse(soap, tag ? tag : "tds:GetDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationResponse(struct soap *soap, _tds__GetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken);
}

void _tds__GetDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken);
#endif
}

int _tds__GetDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, &a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, _tds__GetDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(_tds__GetDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfigurationToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", &a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfigurationToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfiguration, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(_tds__GetDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfiguration *p;
	size_t k = sizeof(_tds__GetDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfiguration(soap, tag ? tag : "tds:GetDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(_tds__SetDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfigurationResponse, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(_tds__SetDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__SetDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDot1XConfigurationResponse(soap, tag ? tag : "tds:SetDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetDot1XConfigurationResponse(struct soap *soap, _tds__SetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetDot1XConfiguration::Dot1XConfiguration = NULL;
}

void _tds__SetDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__SetDot1XConfiguration::Dot1XConfiguration);
#endif
}

int _tds__SetDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfiguration), type))
		return soap->error;
	if (!a->_tds__SetDot1XConfiguration::Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__SetDot1XConfiguration::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, _tds__SetDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(_tds__SetDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__SetDot1XConfiguration::Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__SetDot1XConfiguration::Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfiguration, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(_tds__SetDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDot1XConfiguration *p;
	size_t k = sizeof(_tds__SetDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDot1XConfiguration(soap, tag ? tag : "tds:SetDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__CreateDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__CreateDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(_tds__CreateDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(_tds__CreateDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__CreateDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateDot1XConfigurationResponse(soap, tag ? tag : "tds:CreateDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateDot1XConfigurationResponse(struct soap *soap, _tds__CreateDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateDot1XConfiguration::Dot1XConfiguration = NULL;
}

void _tds__CreateDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__CreateDot1XConfiguration::Dot1XConfiguration);
#endif
}

int _tds__CreateDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfiguration), type))
		return soap->error;
	if (!a->_tds__CreateDot1XConfiguration::Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__CreateDot1XConfiguration::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_in__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, _tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(_tds__CreateDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__CreateDot1XConfiguration::Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__CreateDot1XConfiguration::Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfiguration, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(_tds__CreateDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateDot1XConfiguration *p;
	size_t k = sizeof(_tds__CreateDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateDot1XConfiguration(soap, tag ? tag : "tds:CreateDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_get__tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCACertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__LoadCACertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__LoadCACertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCACertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCACertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCACertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCACertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, _tds__LoadCACertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCACertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(_tds__LoadCACertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCACertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCACertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificatesResponse, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(_tds__LoadCACertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCACertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCACertificatesResponse *p;
	size_t k = sizeof(_tds__LoadCACertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCACertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCACertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCACertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCACertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCACertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCACertificatesResponse(soap, tag ? tag : "tds:LoadCACertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCACertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCACertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCACertificatesResponse(struct soap *soap, _tds__LoadCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCACertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCACertificates::CACertificate);
}

void _tds__LoadCACertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCACertificates::CACertificate);
#endif
}

int _tds__LoadCACertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCACertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificates(struct soap *soap, const char *tag, int id, const _tds__LoadCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", -1, &a->_tds__LoadCACertificates::CACertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCACertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCACertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCACertificates * SOAP_FMAC4 soap_in__tds__LoadCACertificates(struct soap *soap, const char *tag, _tds__LoadCACertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCACertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificates, sizeof(_tds__LoadCACertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCACertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCACertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", &a->_tds__LoadCACertificates::CACertificate, "tt:Certificate"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__LoadCACertificates::CACertificate.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__LoadCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificates, SOAP_TYPE__tds__LoadCACertificates, sizeof(_tds__LoadCACertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCACertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCACertificates *p;
	size_t k = sizeof(_tds__LoadCACertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCACertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCACertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCACertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCACertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCACertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCACertificates(soap, tag ? tag : "tds:LoadCACertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCACertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCACertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCACertificates * SOAP_FMAC4 soap_get__tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificateInformationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCertificateInformationResponse::CertificateInformation = NULL;
}

void _tds__GetCertificateInformationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__CertificateInformation(soap, &this->_tds__GetCertificateInformationResponse::CertificateInformation);
#endif
}

int _tds__GetCertificateInformationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificateInformationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificateInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformationResponse), type))
		return soap->error;
	if (a->CertificateInformation)
		soap_element_result(soap, "tds:CertificateInformation");
	if (!a->_tds__GetCertificateInformationResponse::CertificateInformation)
	{	if (soap_element_empty(soap, "tds:CertificateInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", -1, &a->_tds__GetCertificateInformationResponse::CertificateInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificateInformationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificateInformationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_in__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, _tds__GetCertificateInformationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificateInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(_tds__GetCertificateInformationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificateInformationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificateInformationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", &a->_tds__GetCertificateInformationResponse::CertificateInformation, "tt:CertificateInformation"))
				{	soap_flag_CertificateInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:CertificateInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetCertificateInformationResponse::CertificateInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetCertificateInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformationResponse, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(_tds__GetCertificateInformationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificateInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificateInformationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificateInformationResponse *p;
	size_t k = sizeof(_tds__GetCertificateInformationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificateInformationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificateInformationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificateInformationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificateInformationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificateInformationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificateInformationResponse(soap, tag ? tag : "tds:GetCertificateInformationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificateInformationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificateInformationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_get__tds__GetCertificateInformationResponse(struct soap *soap, _tds__GetCertificateInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificateInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__GetCertificateInformation::CertificateID);
}

void _tds__GetCertificateInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetCertificateInformation::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->_tds__GetCertificateInformation::CertificateID);
#endif
}

int _tds__GetCertificateInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificateInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, const _tds__GetCertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformation), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->_tds__GetCertificateInformation::CertificateID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificateInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificateInformation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificateInformation * SOAP_FMAC4 soap_in__tds__GetCertificateInformation(struct soap *soap, const char *tag, _tds__GetCertificateInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(_tds__GetCertificateInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificateInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificateInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:CertificateID", &a->_tds__GetCertificateInformation::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetCertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformation, SOAP_TYPE__tds__GetCertificateInformation, sizeof(_tds__GetCertificateInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificateInformation *p;
	size_t k = sizeof(_tds__GetCertificateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificateInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificateInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificateInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificateInformation(soap, tag ? tag : "tds:GetCertificateInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificateInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificateInformation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificateInformation * SOAP_FMAC4 soap_get__tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificateWithPrivateKeyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__LoadCertificateWithPrivateKeyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__LoadCertificateWithPrivateKeyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificateWithPrivateKeyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificateWithPrivateKeyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(_tds__LoadCertificateWithPrivateKeyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificateWithPrivateKeyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCertificateWithPrivateKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(_tds__LoadCertificateWithPrivateKeyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificateWithPrivateKeyResponse *p;
	size_t k = sizeof(_tds__LoadCertificateWithPrivateKeyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificateWithPrivateKeyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificateWithPrivateKeyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificateWithPrivateKeyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificateWithPrivateKeyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag ? tag : "tds:LoadCertificateWithPrivateKeyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificateWithPrivateKeyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificateWithPrivateKeyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, _tds__LoadCertificateWithPrivateKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificateWithPrivateKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, &this->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey);
}

void _tds__LoadCertificateWithPrivateKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, &this->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey);
#endif
}

int _tds__LoadCertificateWithPrivateKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificateWithPrivateKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", -1, &a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificateWithPrivateKey::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificateWithPrivateKey*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(_tds__LoadCertificateWithPrivateKey), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificateWithPrivateKey)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificateWithPrivateKey *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", &a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey, "tt:CertificateWithPrivateKey"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__LoadCertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(_tds__LoadCertificateWithPrivateKey), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificateWithPrivateKey *p;
	size_t k = sizeof(_tds__LoadCertificateWithPrivateKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificateWithPrivateKey);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificateWithPrivateKey, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificateWithPrivateKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificateWithPrivateKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificateWithPrivateKey(soap, tag ? tag : "tds:LoadCertificateWithPrivateKey", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificateWithPrivateKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificateWithPrivateKey(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCACertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCACertificatesResponse::CACertificate);
}

void _tds__GetCACertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCACertificatesResponse::CACertificate);
#endif
}

int _tds__GetCACertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCACertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCACertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:CACertificate");
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", -1, &a->_tds__GetCACertificatesResponse::CACertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCACertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCACertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, _tds__GetCACertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCACertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(_tds__GetCACertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCACertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCACertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", &a->_tds__GetCACertificatesResponse::CACertificate, "tt:Certificate"))
					continue;
			}
			soap_check_result(soap, "tds:CACertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificatesResponse, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(_tds__GetCACertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCACertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCACertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCACertificatesResponse *p;
	size_t k = sizeof(_tds__GetCACertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCACertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCACertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCACertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCACertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCACertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCACertificatesResponse(soap, tag ? tag : "tds:GetCACertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCACertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCACertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCACertificatesResponse(struct soap *soap, _tds__GetCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCACertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetCACertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetCACertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCACertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificates(struct soap *soap, const char *tag, int id, const _tds__GetCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCACertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCACertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCACertificates * SOAP_FMAC4 soap_in__tds__GetCACertificates(struct soap *soap, const char *tag, _tds__GetCACertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCACertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificates, sizeof(_tds__GetCACertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCACertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCACertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificates, SOAP_TYPE__tds__GetCACertificates, sizeof(_tds__GetCACertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCACertificates * SOAP_FMAC2 soap_instantiate__tds__GetCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCACertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCACertificates *p;
	size_t k = sizeof(_tds__GetCACertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCACertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCACertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCACertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCACertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCACertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCACertificates(soap, tag ? tag : "tds:GetCACertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCACertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCACertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCACertificates * SOAP_FMAC4 soap_get__tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetClientCertificateModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetClientCertificateModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetClientCertificateModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetClientCertificateModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const _tds__SetClientCertificateModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetClientCertificateModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetClientCertificateModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, _tds__SetClientCertificateModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetClientCertificateModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(_tds__SetClientCertificateModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetClientCertificateModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetClientCertificateModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateModeResponse, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(_tds__SetClientCertificateModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetClientCertificateModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetClientCertificateModeResponse *p;
	size_t k = sizeof(_tds__SetClientCertificateModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetClientCertificateModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetClientCertificateModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetClientCertificateModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetClientCertificateModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetClientCertificateModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetClientCertificateModeResponse(soap, tag ? tag : "tds:SetClientCertificateModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetClientCertificateModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetClientCertificateModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__SetClientCertificateModeResponse(struct soap *soap, _tds__SetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetClientCertificateMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetClientCertificateMode::Enabled);
}

void _tds__SetClientCertificateMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetClientCertificateMode::Enabled, SOAP_TYPE_bool);
#endif
}

int _tds__SetClientCertificateMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetClientCertificateMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, const _tds__SetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateMode), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__SetClientCertificateMode::Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetClientCertificateMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetClientCertificateMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetClientCertificateMode * SOAP_FMAC4 soap_in__tds__SetClientCertificateMode(struct soap *soap, const char *tag, _tds__SetClientCertificateMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetClientCertificateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(_tds__SetClientCertificateMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetClientCertificateMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetClientCertificateMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__SetClientCertificateMode::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateMode, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(_tds__SetClientCertificateMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetClientCertificateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetClientCertificateMode *p;
	size_t k = sizeof(_tds__SetClientCertificateMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetClientCertificateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetClientCertificateMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetClientCertificateMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetClientCertificateMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetClientCertificateMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetClientCertificateMode(soap, tag ? tag : "tds:SetClientCertificateMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetClientCertificateMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetClientCertificateMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetClientCertificateMode * SOAP_FMAC4 soap_get__tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetClientCertificateModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__GetClientCertificateModeResponse::Enabled);
}

void _tds__GetClientCertificateModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetClientCertificateModeResponse::Enabled, SOAP_TYPE_bool);
#endif
}

int _tds__GetClientCertificateModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetClientCertificateModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const _tds__GetClientCertificateModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__GetClientCertificateModeResponse::Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetClientCertificateModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetClientCertificateModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, _tds__GetClientCertificateModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetClientCertificateModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(_tds__GetClientCertificateModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetClientCertificateModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetClientCertificateModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__GetClientCertificateModeResponse::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateModeResponse, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(_tds__GetClientCertificateModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetClientCertificateModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetClientCertificateModeResponse *p;
	size_t k = sizeof(_tds__GetClientCertificateModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetClientCertificateModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetClientCertificateModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetClientCertificateModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetClientCertificateModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetClientCertificateModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetClientCertificateModeResponse(soap, tag ? tag : "tds:GetClientCertificateModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetClientCertificateModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetClientCertificateModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__GetClientCertificateModeResponse(struct soap *soap, _tds__GetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetClientCertificateMode::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetClientCertificateMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetClientCertificateMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetClientCertificateMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, const _tds__GetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetClientCertificateMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetClientCertificateMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetClientCertificateMode * SOAP_FMAC4 soap_in__tds__GetClientCertificateMode(struct soap *soap, const char *tag, _tds__GetClientCertificateMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetClientCertificateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(_tds__GetClientCertificateMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetClientCertificateMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetClientCertificateMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateMode, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(_tds__GetClientCertificateMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetClientCertificateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetClientCertificateMode *p;
	size_t k = sizeof(_tds__GetClientCertificateMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetClientCertificateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetClientCertificateMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetClientCertificateMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetClientCertificateMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetClientCertificateMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetClientCertificateMode(soap, tag ? tag : "tds:GetClientCertificateMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetClientCertificateMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetClientCertificateMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetClientCertificateMode * SOAP_FMAC4 soap_get__tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__LoadCertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__LoadCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, _tds__LoadCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(_tds__LoadCertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificatesResponse, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(_tds__LoadCertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificatesResponse *p;
	size_t k = sizeof(_tds__LoadCertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificatesResponse(soap, tag ? tag : "tds:LoadCertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCertificatesResponse(struct soap *soap, _tds__LoadCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCertificates::NVTCertificate);
}

void _tds__LoadCertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCertificates::NVTCertificate);
#endif
}

int _tds__LoadCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificates(struct soap *soap, const char *tag, int id, const _tds__LoadCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NVTCertificate", -1, &a->_tds__LoadCertificates::NVTCertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificates * SOAP_FMAC4 soap_in__tds__LoadCertificates(struct soap *soap, const char *tag, _tds__LoadCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificates, sizeof(_tds__LoadCertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NVTCertificate", &a->_tds__LoadCertificates::NVTCertificate, "tt:Certificate"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__LoadCertificates::NVTCertificate.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__LoadCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificates, SOAP_TYPE__tds__LoadCertificates, sizeof(_tds__LoadCertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificates *p;
	size_t k = sizeof(_tds__LoadCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificates(soap, tag ? tag : "tds:LoadCertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificates * SOAP_FMAC4 soap_get__tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPkcs10RequestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetPkcs10RequestResponse::Pkcs10Request = NULL;
}

void _tds__GetPkcs10RequestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetPkcs10RequestResponse::Pkcs10Request);
#endif
}

int _tds__GetPkcs10RequestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPkcs10RequestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, int id, const _tds__GetPkcs10RequestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse), type))
		return soap->error;
	if (a->Pkcs10Request)
		soap_element_result(soap, "tds:Pkcs10Request");
	if (!a->_tds__GetPkcs10RequestResponse::Pkcs10Request)
	{	if (soap_element_empty(soap, "tds:Pkcs10Request", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:Pkcs10Request", -1, &a->_tds__GetPkcs10RequestResponse::Pkcs10Request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPkcs10RequestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPkcs10RequestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_in__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, _tds__GetPkcs10RequestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPkcs10RequestResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(_tds__GetPkcs10RequestResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPkcs10RequestResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPkcs10RequestResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Pkcs10Request1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pkcs10Request1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:Pkcs10Request", &a->_tds__GetPkcs10RequestResponse::Pkcs10Request, "tt:BinaryData"))
				{	soap_flag_Pkcs10Request1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Pkcs10Request");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetPkcs10RequestResponse::Pkcs10Request))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetPkcs10RequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10RequestResponse, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(_tds__GetPkcs10RequestResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPkcs10RequestResponse * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10RequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPkcs10RequestResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPkcs10RequestResponse *p;
	size_t k = sizeof(_tds__GetPkcs10RequestResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPkcs10RequestResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPkcs10RequestResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPkcs10RequestResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPkcs10RequestResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPkcs10RequestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPkcs10RequestResponse(soap, tag ? tag : "tds:GetPkcs10RequestResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPkcs10RequestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPkcs10RequestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_get__tds__GetPkcs10RequestResponse(struct soap *soap, _tds__GetPkcs10RequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPkcs10Request::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__GetPkcs10Request::CertificateID);
	this->_tds__GetPkcs10Request::Subject = NULL;
	this->_tds__GetPkcs10Request::Attributes = NULL;
}

void _tds__GetPkcs10Request::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetPkcs10Request::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->_tds__GetPkcs10Request::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->_tds__GetPkcs10Request::Subject);
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetPkcs10Request::Attributes);
#endif
}

int _tds__GetPkcs10Request::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPkcs10Request(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, const _tds__GetPkcs10Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10Request), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->_tds__GetPkcs10Request::CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tds:Subject", -1, &a->_tds__GetPkcs10Request::Subject, ""))
		return soap->error;
	if (soap_out_PointerTott__BinaryData(soap, "tds:Attributes", -1, &a->_tds__GetPkcs10Request::Attributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPkcs10Request::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPkcs10Request(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPkcs10Request * SOAP_FMAC4 soap_in__tds__GetPkcs10Request(struct soap *soap, const char *tag, _tds__GetPkcs10Request *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPkcs10Request*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(_tds__GetPkcs10Request), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPkcs10Request)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPkcs10Request *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_Attributes1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:CertificateID", &a->_tds__GetPkcs10Request::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tds:Subject", &a->_tds__GetPkcs10Request::Subject, "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			}
			if (soap_flag_Attributes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:Attributes", &a->_tds__GetPkcs10Request::Attributes, "tt:BinaryData"))
				{	soap_flag_Attributes1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetPkcs10Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10Request, SOAP_TYPE__tds__GetPkcs10Request, sizeof(_tds__GetPkcs10Request), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPkcs10Request(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPkcs10Request *p;
	size_t k = sizeof(_tds__GetPkcs10Request);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPkcs10Request, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPkcs10Request);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPkcs10Request, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPkcs10Request location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPkcs10Request::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPkcs10Request(soap, tag ? tag : "tds:GetPkcs10Request", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPkcs10Request::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPkcs10Request(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPkcs10Request * SOAP_FMAC4 soap_get__tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteCertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_in__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, _tds__DeleteCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(_tds__DeleteCertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteCertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteCertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificatesResponse, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(_tds__DeleteCertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteCertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteCertificatesResponse *p;
	size_t k = sizeof(_tds__DeleteCertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteCertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteCertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteCertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteCertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteCertificatesResponse(soap, tag ? tag : "tds:DeleteCertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_get__tds__DeleteCertificatesResponse(struct soap *soap, _tds__DeleteCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->_tds__DeleteCertificates::CertificateID);
}

void _tds__DeleteCertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->_tds__DeleteCertificates::CertificateID);
#endif
}

int _tds__DeleteCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificates(struct soap *soap, const char *tag, int id, const _tds__DeleteCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tds:CertificateID", -1, &a->_tds__DeleteCertificates::CertificateID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteCertificates * SOAP_FMAC4 soap_in__tds__DeleteCertificates(struct soap *soap, const char *tag, _tds__DeleteCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificates, sizeof(_tds__DeleteCertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteCertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteCertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tds:CertificateID", &a->_tds__DeleteCertificates::CertificateID, "xsd:token"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__DeleteCertificates::CertificateID.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificates, SOAP_TYPE__tds__DeleteCertificates, sizeof(_tds__DeleteCertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteCertificates *p;
	size_t k = sizeof(_tds__DeleteCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteCertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteCertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteCertificates(soap, tag ? tag : "tds:DeleteCertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteCertificates * SOAP_FMAC4 soap_get__tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetCertificatesStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetCertificatesStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetCertificatesStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetCertificatesStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const _tds__SetCertificatesStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetCertificatesStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetCertificatesStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, _tds__SetCertificatesStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetCertificatesStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(_tds__SetCertificatesStatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetCertificatesStatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetCertificatesStatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatusResponse, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(_tds__SetCertificatesStatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetCertificatesStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetCertificatesStatusResponse *p;
	size_t k = sizeof(_tds__SetCertificatesStatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetCertificatesStatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetCertificatesStatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetCertificatesStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetCertificatesStatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetCertificatesStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetCertificatesStatusResponse(soap, tag ? tag : "tds:SetCertificatesStatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetCertificatesStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetCertificatesStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__SetCertificatesStatusResponse(struct soap *soap, _tds__SetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetCertificatesStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__SetCertificatesStatus::CertificateStatus);
}

void _tds__SetCertificatesStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__SetCertificatesStatus::CertificateStatus);
#endif
}

int _tds__SetCertificatesStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetCertificatesStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, const _tds__SetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", -1, &a->_tds__SetCertificatesStatus::CertificateStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetCertificatesStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetCertificatesStatus(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatus * SOAP_FMAC4 soap_in__tds__SetCertificatesStatus(struct soap *soap, const char *tag, _tds__SetCertificatesStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetCertificatesStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(_tds__SetCertificatesStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetCertificatesStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetCertificatesStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", &a->_tds__SetCertificatesStatus::CertificateStatus, "tt:CertificateStatus"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatus, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(_tds__SetCertificatesStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetCertificatesStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetCertificatesStatus *p;
	size_t k = sizeof(_tds__SetCertificatesStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetCertificatesStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetCertificatesStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetCertificatesStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetCertificatesStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetCertificatesStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetCertificatesStatus(soap, tag ? tag : "tds:SetCertificatesStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetCertificatesStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetCertificatesStatus(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatus * SOAP_FMAC4 soap_get__tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificatesStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__GetCertificatesStatusResponse::CertificateStatus);
}

void _tds__GetCertificatesStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__GetCertificatesStatusResponse::CertificateStatus);
#endif
}

int _tds__GetCertificatesStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:CertificateStatus");
	if (soap_out_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", -1, &a->_tds__GetCertificatesStatusResponse::CertificateStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificatesStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, _tds__GetCertificatesStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(_tds__GetCertificatesStatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificatesStatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificatesStatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", &a->_tds__GetCertificatesStatusResponse::CertificateStatus, "tt:CertificateStatus"))
					continue;
			}
			soap_check_result(soap, "tds:CertificateStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatusResponse, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(_tds__GetCertificatesStatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificatesStatusResponse *p;
	size_t k = sizeof(_tds__GetCertificatesStatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificatesStatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificatesStatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificatesStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificatesStatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificatesStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificatesStatusResponse(soap, tag ? tag : "tds:GetCertificatesStatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesStatusResponse(struct soap *soap, _tds__GetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificatesStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetCertificatesStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetCertificatesStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatus), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificatesStatus(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatus * SOAP_FMAC4 soap_in__tds__GetCertificatesStatus(struct soap *soap, const char *tag, _tds__GetCertificatesStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(_tds__GetCertificatesStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificatesStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificatesStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatus, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(_tds__GetCertificatesStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificatesStatus *p;
	size_t k = sizeof(_tds__GetCertificatesStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificatesStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificatesStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificatesStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificatesStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificatesStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificatesStatus(soap, tag ? tag : "tds:GetCertificatesStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesStatus(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatus * SOAP_FMAC4 soap_get__tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCertificatesResponse::NvtCertificate);
}

void _tds__GetCertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCertificatesResponse::NvtCertificate);
#endif
}

int _tds__GetCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:NvtCertificate");
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NvtCertificate", -1, &a->_tds__GetCertificatesResponse::NvtCertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesResponse(struct soap *soap, const char *tag, _tds__GetCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(_tds__GetCertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NvtCertificate", &a->_tds__GetCertificatesResponse::NvtCertificate, "tt:Certificate"))
					continue;
			}
			soap_check_result(soap, "tds:NvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesResponse, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(_tds__GetCertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificatesResponse *p;
	size_t k = sizeof(_tds__GetCertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificatesResponse(soap, tag ? tag : "tds:GetCertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesResponse(struct soap *soap, _tds__GetCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetCertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificates(struct soap *soap, const char *tag, int id, const _tds__GetCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificates * SOAP_FMAC4 soap_in__tds__GetCertificates(struct soap *soap, const char *tag, _tds__GetCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificates, sizeof(_tds__GetCertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificates, SOAP_TYPE__tds__GetCertificates, sizeof(_tds__GetCertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificates * SOAP_FMAC2 soap_instantiate__tds__GetCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificates *p;
	size_t k = sizeof(_tds__GetCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificates(soap, tag ? tag : "tds:GetCertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificates * SOAP_FMAC4 soap_get__tds__GetCertificates(struct soap *soap, _tds__GetCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateCertificateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateCertificateResponse::NvtCertificate = NULL;
}

void _tds__CreateCertificateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Certificate(soap, &this->_tds__CreateCertificateResponse::NvtCertificate);
#endif
}

int _tds__CreateCertificateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateCertificateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificateResponse(struct soap *soap, const char *tag, int id, const _tds__CreateCertificateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificateResponse), type))
		return soap->error;
	if (a->NvtCertificate)
		soap_element_result(soap, "tds:NvtCertificate");
	if (!a->_tds__CreateCertificateResponse::NvtCertificate)
	{	if (soap_element_empty(soap, "tds:NvtCertificate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Certificate(soap, "tds:NvtCertificate", -1, &a->_tds__CreateCertificateResponse::NvtCertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateCertificateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateCertificateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateCertificateResponse * SOAP_FMAC4 soap_in__tds__CreateCertificateResponse(struct soap *soap, const char *tag, _tds__CreateCertificateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateCertificateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(_tds__CreateCertificateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateCertificateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateCertificateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NvtCertificate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NvtCertificate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Certificate(soap, "tds:NvtCertificate", &a->_tds__CreateCertificateResponse::NvtCertificate, "tt:Certificate"))
				{	soap_flag_NvtCertificate1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__CreateCertificateResponse::NvtCertificate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificateResponse, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(_tds__CreateCertificateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateCertificateResponse * SOAP_FMAC2 soap_instantiate__tds__CreateCertificateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateCertificateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateCertificateResponse *p;
	size_t k = sizeof(_tds__CreateCertificateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateCertificateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateCertificateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateCertificateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateCertificateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateCertificateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateCertificateResponse(soap, tag ? tag : "tds:CreateCertificateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateCertificateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateCertificateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateCertificateResponse * SOAP_FMAC4 soap_get__tds__CreateCertificateResponse(struct soap *soap, _tds__CreateCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateCertificate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateCertificate::CertificateID = NULL;
	this->_tds__CreateCertificate::Subject = NULL;
	this->_tds__CreateCertificate::ValidNotBefore = NULL;
	this->_tds__CreateCertificate::ValidNotAfter = NULL;
}

void _tds__CreateCertificate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__token(soap, &this->_tds__CreateCertificate::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->_tds__CreateCertificate::Subject);
	soap_serialize_PointerTodateTime(soap, &this->_tds__CreateCertificate::ValidNotBefore);
	soap_serialize_PointerTodateTime(soap, &this->_tds__CreateCertificate::ValidNotAfter);
#endif
}

int _tds__CreateCertificate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateCertificate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificate(struct soap *soap, const char *tag, int id, const _tds__CreateCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificate), type))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tds:CertificateID", -1, &a->_tds__CreateCertificate::CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tds:Subject", -1, &a->_tds__CreateCertificate::Subject, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tds:ValidNotBefore", -1, &a->_tds__CreateCertificate::ValidNotBefore, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tds:ValidNotAfter", -1, &a->_tds__CreateCertificate::ValidNotAfter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateCertificate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateCertificate(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateCertificate * SOAP_FMAC4 soap_in__tds__CreateCertificate(struct soap *soap, const char *tag, _tds__CreateCertificate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateCertificate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificate, sizeof(_tds__CreateCertificate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateCertificate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateCertificate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_ValidNotBefore1 = 1;
	size_t soap_flag_ValidNotAfter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tds:CertificateID", &a->_tds__CreateCertificate::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tds:Subject", &a->_tds__CreateCertificate::Subject, "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			}
			if (soap_flag_ValidNotBefore1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tds:ValidNotBefore", &a->_tds__CreateCertificate::ValidNotBefore, "xsd:dateTime"))
				{	soap_flag_ValidNotBefore1--;
					continue;
				}
			}
			if (soap_flag_ValidNotAfter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tds:ValidNotAfter", &a->_tds__CreateCertificate::ValidNotAfter, "xsd:dateTime"))
				{	soap_flag_ValidNotAfter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificate, SOAP_TYPE__tds__CreateCertificate, sizeof(_tds__CreateCertificate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateCertificate * SOAP_FMAC2 soap_instantiate__tds__CreateCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateCertificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateCertificate *p;
	size_t k = sizeof(_tds__CreateCertificate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateCertificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateCertificate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateCertificate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateCertificate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateCertificate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateCertificate(soap, tag ? tag : "tds:CreateCertificate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateCertificate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateCertificate(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateCertificate * SOAP_FMAC4 soap_get__tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetAccessPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetAccessPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetAccessPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAccessPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const _tds__SetAccessPolicyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAccessPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetAccessPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, _tds__SetAccessPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAccessPolicyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(_tds__SetAccessPolicyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetAccessPolicyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetAccessPolicyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicyResponse, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(_tds__SetAccessPolicyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAccessPolicyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetAccessPolicyResponse *p;
	size_t k = sizeof(_tds__SetAccessPolicyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetAccessPolicyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetAccessPolicyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetAccessPolicyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetAccessPolicyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetAccessPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetAccessPolicyResponse(soap, tag ? tag : "tds:SetAccessPolicyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAccessPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAccessPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__SetAccessPolicyResponse(struct soap *soap, _tds__SetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetAccessPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetAccessPolicy::PolicyFile = NULL;
}

void _tds__SetAccessPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__SetAccessPolicy::PolicyFile);
#endif
}

int _tds__SetAccessPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAccessPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, const _tds__SetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicy), type))
		return soap->error;
	if (!a->_tds__SetAccessPolicy::PolicyFile)
	{	if (soap_element_empty(soap, "tds:PolicyFile", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->_tds__SetAccessPolicy::PolicyFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAccessPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetAccessPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAccessPolicy * SOAP_FMAC4 soap_in__tds__SetAccessPolicy(struct soap *soap, const char *tag, _tds__SetAccessPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAccessPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(_tds__SetAccessPolicy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetAccessPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetAccessPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PolicyFile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->_tds__SetAccessPolicy::PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__SetAccessPolicy::PolicyFile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicy, SOAP_TYPE__tds__SetAccessPolicy, sizeof(_tds__SetAccessPolicy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAccessPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetAccessPolicy *p;
	size_t k = sizeof(_tds__SetAccessPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetAccessPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetAccessPolicy);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetAccessPolicy, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetAccessPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetAccessPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetAccessPolicy(soap, tag ? tag : "tds:SetAccessPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAccessPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAccessPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAccessPolicy * SOAP_FMAC4 soap_get__tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAccessPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetAccessPolicyResponse::PolicyFile = NULL;
}

void _tds__GetAccessPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetAccessPolicyResponse::PolicyFile);
#endif
}

int _tds__GetAccessPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAccessPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const _tds__GetAccessPolicyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicyResponse), type))
		return soap->error;
	if (a->PolicyFile)
		soap_element_result(soap, "tds:PolicyFile");
	if (!a->_tds__GetAccessPolicyResponse::PolicyFile)
	{	if (soap_element_empty(soap, "tds:PolicyFile", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->_tds__GetAccessPolicyResponse::PolicyFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAccessPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAccessPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, _tds__GetAccessPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAccessPolicyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(_tds__GetAccessPolicyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAccessPolicyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAccessPolicyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PolicyFile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->_tds__GetAccessPolicyResponse::PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:PolicyFile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetAccessPolicyResponse::PolicyFile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicyResponse, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(_tds__GetAccessPolicyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAccessPolicyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAccessPolicyResponse *p;
	size_t k = sizeof(_tds__GetAccessPolicyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAccessPolicyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAccessPolicyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAccessPolicyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAccessPolicyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAccessPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAccessPolicyResponse(soap, tag ? tag : "tds:GetAccessPolicyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAccessPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAccessPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__GetAccessPolicyResponse(struct soap *soap, _tds__GetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAccessPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetAccessPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetAccessPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAccessPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, const _tds__GetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicy), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAccessPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAccessPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAccessPolicy * SOAP_FMAC4 soap_in__tds__GetAccessPolicy(struct soap *soap, const char *tag, _tds__GetAccessPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAccessPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(_tds__GetAccessPolicy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAccessPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAccessPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicy, SOAP_TYPE__tds__GetAccessPolicy, sizeof(_tds__GetAccessPolicy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAccessPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAccessPolicy *p;
	size_t k = sizeof(_tds__GetAccessPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAccessPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAccessPolicy);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAccessPolicy, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAccessPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAccessPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAccessPolicy(soap, tag ? tag : "tds:GetAccessPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAccessPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAccessPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAccessPolicy * SOAP_FMAC4 soap_get__tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RemoveIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__RemoveIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__RemoveIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(_tds__RemoveIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RemoveIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RemoveIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__RemoveIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(_tds__RemoveIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RemoveIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__RemoveIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RemoveIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RemoveIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RemoveIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RemoveIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RemoveIPAddressFilterResponse(soap, tag ? tag : "tds:RemoveIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilterResponse(struct soap *soap, _tds__RemoveIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RemoveIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__RemoveIPAddressFilter::IPAddressFilter = NULL;
}

void _tds__RemoveIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__RemoveIPAddressFilter::IPAddressFilter);
#endif
}

int _tds__RemoveIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilter), type))
		return soap->error;
	if (!a->_tds__RemoveIPAddressFilter::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__RemoveIPAddressFilter::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RemoveIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(_tds__RemoveIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RemoveIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RemoveIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__RemoveIPAddressFilter::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__RemoveIPAddressFilter::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__RemoveIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilter, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(_tds__RemoveIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RemoveIPAddressFilter *p;
	size_t k = sizeof(_tds__RemoveIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RemoveIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RemoveIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RemoveIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RemoveIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RemoveIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RemoveIPAddressFilter(soap, tag ? tag : "tds:RemoveIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__AddIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__AddIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__AddIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__AddIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__AddIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__AddIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__AddIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(_tds__AddIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__AddIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__AddIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__AddIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilterResponse, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(_tds__AddIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__AddIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__AddIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__AddIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__AddIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__AddIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__AddIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__AddIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__AddIPAddressFilterResponse(soap, tag ? tag : "tds:AddIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__AddIPAddressFilterResponse(struct soap *soap, _tds__AddIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__AddIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__AddIPAddressFilter::IPAddressFilter = NULL;
}

void _tds__AddIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__AddIPAddressFilter::IPAddressFilter);
#endif
}

int _tds__AddIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__AddIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilter), type))
		return soap->error;
	if (!a->_tds__AddIPAddressFilter::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__AddIPAddressFilter::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__AddIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__AddIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilter * SOAP_FMAC4 soap_in__tds__AddIPAddressFilter(struct soap *soap, const char *tag, _tds__AddIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(_tds__AddIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__AddIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__AddIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__AddIPAddressFilter::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__AddIPAddressFilter::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__AddIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilter, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(_tds__AddIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__AddIPAddressFilter *p;
	size_t k = sizeof(_tds__AddIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__AddIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__AddIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__AddIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__AddIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__AddIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__AddIPAddressFilter(soap, tag ? tag : "tds:AddIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilter * SOAP_FMAC4 soap_get__tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__SetIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__SetIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(_tds__SetIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilterResponse, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(_tds__SetIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__SetIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetIPAddressFilterResponse(soap, tag ? tag : "tds:SetIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__SetIPAddressFilterResponse(struct soap *soap, _tds__SetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetIPAddressFilter::IPAddressFilter = NULL;
}

void _tds__SetIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__SetIPAddressFilter::IPAddressFilter);
#endif
}

int _tds__SetIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__SetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilter), type))
		return soap->error;
	if (!a->_tds__SetIPAddressFilter::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__SetIPAddressFilter::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilter * SOAP_FMAC4 soap_in__tds__SetIPAddressFilter(struct soap *soap, const char *tag, _tds__SetIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(_tds__SetIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__SetIPAddressFilter::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__SetIPAddressFilter::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilter, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(_tds__SetIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetIPAddressFilter *p;
	size_t k = sizeof(_tds__SetIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetIPAddressFilter(soap, tag ? tag : "tds:SetIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilter * SOAP_FMAC4 soap_get__tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetIPAddressFilterResponse::IPAddressFilter = NULL;
}

void _tds__GetIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__GetIPAddressFilterResponse::IPAddressFilter);
#endif
}

int _tds__GetIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__GetIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse), type))
		return soap->error;
	if (a->IPAddressFilter)
		soap_element_result(soap, "tds:IPAddressFilter");
	if (!a->_tds__GetIPAddressFilterResponse::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__GetIPAddressFilterResponse::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__GetIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(_tds__GetIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__GetIPAddressFilterResponse::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:IPAddressFilter");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetIPAddressFilterResponse::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilterResponse, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(_tds__GetIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__GetIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetIPAddressFilterResponse(soap, tag ? tag : "tds:GetIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__GetIPAddressFilterResponse(struct soap *soap, _tds__GetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__GetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilter * SOAP_FMAC4 soap_in__tds__GetIPAddressFilter(struct soap *soap, const char *tag, _tds__GetIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(_tds__GetIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilter, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(_tds__GetIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetIPAddressFilter *p;
	size_t k = sizeof(_tds__GetIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetIPAddressFilter(soap, tag ? tag : "tds:GetIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilter * SOAP_FMAC4 soap_get__tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetZeroConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetZeroConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetZeroConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetZeroConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetZeroConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetZeroConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetZeroConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, _tds__SetZeroConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetZeroConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(_tds__SetZeroConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetZeroConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetZeroConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfigurationResponse, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(_tds__SetZeroConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetZeroConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetZeroConfigurationResponse *p;
	size_t k = sizeof(_tds__SetZeroConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetZeroConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetZeroConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetZeroConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetZeroConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetZeroConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetZeroConfigurationResponse(soap, tag ? tag : "tds:SetZeroConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetZeroConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetZeroConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetZeroConfigurationResponse(struct soap *soap, _tds__SetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetZeroConfiguration::InterfaceToken);
	soap_default_bool(soap, &this->_tds__SetZeroConfiguration::Enabled);
}

void _tds__SetZeroConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetZeroConfiguration::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetZeroConfiguration::InterfaceToken);
	soap_embedded(soap, &this->_tds__SetZeroConfiguration::Enabled, SOAP_TYPE_bool);
#endif
}

int _tds__SetZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__SetZeroConfiguration::InterfaceToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__SetZeroConfiguration::Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetZeroConfiguration * SOAP_FMAC4 soap_in__tds__SetZeroConfiguration(struct soap *soap, const char *tag, _tds__SetZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(_tds__SetZeroConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetZeroConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetZeroConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__SetZeroConfiguration::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__SetZeroConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0 || soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfiguration, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(_tds__SetZeroConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetZeroConfiguration *p;
	size_t k = sizeof(_tds__SetZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetZeroConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetZeroConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetZeroConfiguration(soap, tag ? tag : "tds:SetZeroConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetZeroConfiguration * SOAP_FMAC4 soap_get__tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetZeroConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetZeroConfigurationResponse::ZeroConfiguration = NULL;
}

void _tds__GetZeroConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkZeroConfiguration(soap, &this->_tds__GetZeroConfigurationResponse::ZeroConfiguration);
#endif
}

int _tds__GetZeroConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetZeroConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetZeroConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse), type))
		return soap->error;
	if (a->ZeroConfiguration)
		soap_element_result(soap, "tds:ZeroConfiguration");
	if (!a->_tds__GetZeroConfigurationResponse::ZeroConfiguration)
	{	if (soap_element_empty(soap, "tds:ZeroConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", -1, &a->_tds__GetZeroConfigurationResponse::ZeroConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetZeroConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetZeroConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, _tds__GetZeroConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetZeroConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(_tds__GetZeroConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetZeroConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetZeroConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ZeroConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZeroConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", &a->_tds__GetZeroConfigurationResponse::ZeroConfiguration, "tt:NetworkZeroConfiguration"))
				{	soap_flag_ZeroConfiguration1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:ZeroConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetZeroConfigurationResponse::ZeroConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfigurationResponse, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(_tds__GetZeroConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetZeroConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetZeroConfigurationResponse *p;
	size_t k = sizeof(_tds__GetZeroConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetZeroConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetZeroConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetZeroConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetZeroConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetZeroConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetZeroConfigurationResponse(soap, tag ? tag : "tds:GetZeroConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetZeroConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetZeroConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetZeroConfigurationResponse(struct soap *soap, _tds__GetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetZeroConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetZeroConfiguration * SOAP_FMAC4 soap_in__tds__GetZeroConfiguration(struct soap *soap, const char *tag, _tds__GetZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(_tds__GetZeroConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetZeroConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetZeroConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfiguration, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(_tds__GetZeroConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetZeroConfiguration *p;
	size_t k = sizeof(_tds__GetZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetZeroConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetZeroConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetZeroConfiguration(soap, tag ? tag : "tds:GetZeroConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetZeroConfiguration * SOAP_FMAC4 soap_get__tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkDefaultGatewayResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetNetworkDefaultGatewayResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetNetworkDefaultGatewayResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkDefaultGatewayResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkDefaultGatewayResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(_tds__SetNetworkDefaultGatewayResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkDefaultGatewayResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(_tds__SetNetworkDefaultGatewayResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkDefaultGatewayResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkDefaultGatewayResponse *p;
	size_t k = sizeof(_tds__SetNetworkDefaultGatewayResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkDefaultGatewayResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkDefaultGatewayResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkDefaultGatewayResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkDefaultGatewayResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag ? tag : "tds:SetNetworkDefaultGatewayResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkDefaultGatewayResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkDefaultGatewayResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, _tds__SetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkDefaultGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv4Address);
	soap_default_std__vectorTemplateOftt__IPv6Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv6Address);
}

void _tds__SetNetworkDefaultGateway::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv4Address);
	soap_serialize_std__vectorTemplateOftt__IPv6Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv6Address);
#endif
}

int _tds__SetNetworkDefaultGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkDefaultGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const _tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tds:IPv4Address", -1, &a->_tds__SetNetworkDefaultGateway::IPv4Address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv6Address(soap, "tds:IPv6Address", -1, &a->_tds__SetNetworkDefaultGateway::IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkDefaultGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkDefaultGateway(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkDefaultGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(_tds__SetNetworkDefaultGateway), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkDefaultGateway)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkDefaultGateway *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tds:IPv4Address", &a->_tds__SetNetworkDefaultGateway::IPv4Address, "tt:IPv4Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv6Address(soap, "tds:IPv6Address", &a->_tds__SetNetworkDefaultGateway::IPv6Address, "tt:IPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGateway, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(_tds__SetNetworkDefaultGateway), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkDefaultGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkDefaultGateway *p;
	size_t k = sizeof(_tds__SetNetworkDefaultGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkDefaultGateway);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkDefaultGateway, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkDefaultGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkDefaultGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkDefaultGateway(soap, tag ? tag : "tds:SetNetworkDefaultGateway", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkDefaultGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkDefaultGateway(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkDefaultGatewayResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway = NULL;
}

void _tds__GetNetworkDefaultGatewayResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkGateway(soap, &this->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway);
#endif
}

int _tds__GetNetworkDefaultGatewayResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse), type))
		return soap->error;
	if (a->NetworkGateway)
		soap_element_result(soap, "tds:NetworkGateway");
	if (!a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway)
	{	if (soap_element_empty(soap, "tds:NetworkGateway", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", -1, &a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkDefaultGatewayResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkDefaultGatewayResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(_tds__GetNetworkDefaultGatewayResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkDefaultGatewayResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NetworkGateway1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NetworkGateway1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", &a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway, "tt:NetworkGateway"))
				{	soap_flag_NetworkGateway1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NetworkGateway");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(_tds__GetNetworkDefaultGatewayResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkDefaultGatewayResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkDefaultGatewayResponse *p;
	size_t k = sizeof(_tds__GetNetworkDefaultGatewayResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkDefaultGatewayResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkDefaultGatewayResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkDefaultGatewayResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkDefaultGatewayResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag ? tag : "tds:GetNetworkDefaultGatewayResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkDefaultGatewayResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkDefaultGatewayResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, _tds__GetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkDefaultGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNetworkDefaultGateway::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNetworkDefaultGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkDefaultGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const _tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkDefaultGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkDefaultGateway(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkDefaultGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(_tds__GetNetworkDefaultGateway), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkDefaultGateway)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkDefaultGateway *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGateway, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(_tds__GetNetworkDefaultGateway), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkDefaultGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkDefaultGateway *p;
	size_t k = sizeof(_tds__GetNetworkDefaultGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkDefaultGateway);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkDefaultGateway, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkDefaultGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkDefaultGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkDefaultGateway(soap, tag ? tag : "tds:GetNetworkDefaultGateway", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkDefaultGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkDefaultGateway(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkProtocolsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetNetworkProtocolsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetNetworkProtocolsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkProtocolsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkProtocolsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkProtocolsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkProtocolsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(_tds__SetNetworkProtocolsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkProtocolsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkProtocolsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocolsResponse, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(_tds__SetNetworkProtocolsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocolsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkProtocolsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkProtocolsResponse *p;
	size_t k = sizeof(_tds__SetNetworkProtocolsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkProtocolsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkProtocolsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkProtocolsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkProtocolsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkProtocolsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkProtocolsResponse(soap, tag ? tag : "tds:SetNetworkProtocolsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkProtocolsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkProtocolsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__SetNetworkProtocolsResponse(struct soap *soap, _tds__SetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkProtocols::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__SetNetworkProtocols::NetworkProtocols);
}

void _tds__SetNetworkProtocols::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__SetNetworkProtocols::NetworkProtocols);
#endif
}

int _tds__SetNetworkProtocols::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkProtocols(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const _tds__SetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocols), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", -1, &a->_tds__SetNetworkProtocols::NetworkProtocols, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkProtocols::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkProtocols(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocols * SOAP_FMAC4 soap_in__tds__SetNetworkProtocols(struct soap *soap, const char *tag, _tds__SetNetworkProtocols *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkProtocols*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(_tds__SetNetworkProtocols), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkProtocols)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkProtocols *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", &a->_tds__SetNetworkProtocols::NetworkProtocols, "tt:NetworkProtocol"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__SetNetworkProtocols::NetworkProtocols.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocols, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(_tds__SetNetworkProtocols), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkProtocols(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkProtocols *p;
	size_t k = sizeof(_tds__SetNetworkProtocols);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkProtocols, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkProtocols);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkProtocols, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkProtocols location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkProtocols::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkProtocols(soap, tag ? tag : "tds:SetNetworkProtocols", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkProtocols::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkProtocols(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocols * SOAP_FMAC4 soap_get__tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkProtocolsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__GetNetworkProtocolsResponse::NetworkProtocols);
}

void _tds__GetNetworkProtocolsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__GetNetworkProtocolsResponse::NetworkProtocols);
#endif
}

int _tds__GetNetworkProtocolsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkProtocolsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:NetworkProtocols");
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", -1, &a->_tds__GetNetworkProtocolsResponse::NetworkProtocols, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkProtocolsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkProtocolsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkProtocolsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(_tds__GetNetworkProtocolsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkProtocolsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkProtocolsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", &a->_tds__GetNetworkProtocolsResponse::NetworkProtocols, "tt:NetworkProtocol"))
					continue;
			}
			soap_check_result(soap, "tds:NetworkProtocols");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocolsResponse, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(_tds__GetNetworkProtocolsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocolsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkProtocolsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkProtocolsResponse *p;
	size_t k = sizeof(_tds__GetNetworkProtocolsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkProtocolsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkProtocolsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkProtocolsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkProtocolsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkProtocolsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkProtocolsResponse(soap, tag ? tag : "tds:GetNetworkProtocolsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkProtocolsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkProtocolsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__GetNetworkProtocolsResponse(struct soap *soap, _tds__GetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkProtocols::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNetworkProtocols::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNetworkProtocols::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkProtocols(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const _tds__GetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocols), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkProtocols::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkProtocols(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocols * SOAP_FMAC4 soap_in__tds__GetNetworkProtocols(struct soap *soap, const char *tag, _tds__GetNetworkProtocols *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkProtocols*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(_tds__GetNetworkProtocols), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkProtocols)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkProtocols *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocols, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(_tds__GetNetworkProtocols), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkProtocols(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkProtocols *p;
	size_t k = sizeof(_tds__GetNetworkProtocols);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkProtocols, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkProtocols);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkProtocols, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkProtocols location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkProtocols::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkProtocols(soap, tag ? tag : "tds:GetNetworkProtocols", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkProtocols::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkProtocols(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocols * SOAP_FMAC4 soap_get__tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkInterfacesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetNetworkInterfacesResponse::RebootNeeded);
}

void _tds__SetNetworkInterfacesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetNetworkInterfacesResponse::RebootNeeded, SOAP_TYPE_bool);
#endif
}

int _tds__SetNetworkInterfacesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkInterfacesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_bool(soap, "tds:RebootNeeded", -1, &a->_tds__SetNetworkInterfacesResponse::RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkInterfacesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkInterfacesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkInterfacesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(_tds__SetNetworkInterfacesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkInterfacesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkInterfacesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RebootNeeded1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:RebootNeeded", &a->_tds__SetNetworkInterfacesResponse::RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfacesResponse, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(_tds__SetNetworkInterfacesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfacesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkInterfacesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkInterfacesResponse *p;
	size_t k = sizeof(_tds__SetNetworkInterfacesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkInterfacesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkInterfacesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkInterfacesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkInterfacesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkInterfacesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkInterfacesResponse(soap, tag ? tag : "tds:SetNetworkInterfacesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkInterfacesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkInterfacesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__SetNetworkInterfacesResponse(struct soap *soap, _tds__SetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkInterfaces::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken);
	this->_tds__SetNetworkInterfaces::NetworkInterface = NULL;
}

void _tds__SetNetworkInterfaces::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken);
	soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(soap, &this->_tds__SetNetworkInterfaces::NetworkInterface);
#endif
}

int _tds__SetNetworkInterfaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkInterfaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const _tds__SetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfaces), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__SetNetworkInterfaces::InterfaceToken, ""))
		return soap->error;
	if (!a->_tds__SetNetworkInterfaces::NetworkInterface)
	{	if (soap_element_empty(soap, "tds:NetworkInterface", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", -1, &a->_tds__SetNetworkInterfaces::NetworkInterface, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkInterfaces::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkInterfaces(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, _tds__SetNetworkInterfaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkInterfaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(_tds__SetNetworkInterfaces), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkInterfaces)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkInterfaces *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_NetworkInterface1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__SetNetworkInterfaces::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap_flag_NetworkInterface1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", &a->_tds__SetNetworkInterfaces::NetworkInterface, "tt:NetworkInterfaceSetConfiguration"))
				{	soap_flag_NetworkInterface1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0 || !a->_tds__SetNetworkInterfaces::NetworkInterface))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfaces, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(_tds__SetNetworkInterfaces), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkInterfaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkInterfaces *p;
	size_t k = sizeof(_tds__SetNetworkInterfaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkInterfaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkInterfaces);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkInterfaces, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkInterfaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkInterfaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkInterfaces(soap, tag ? tag : "tds:SetNetworkInterfaces", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkInterfaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkInterfaces(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkInterfacesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkInterface(soap, &this->_tds__GetNetworkInterfacesResponse::NetworkInterfaces);
}

void _tds__GetNetworkInterfacesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkInterface(soap, &this->_tds__GetNetworkInterfacesResponse::NetworkInterfaces);
#endif
}

int _tds__GetNetworkInterfacesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkInterfacesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:NetworkInterfaces");
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkInterface(soap, "tds:NetworkInterfaces", -1, &a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkInterfacesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkInterfacesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkInterfacesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(_tds__GetNetworkInterfacesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkInterfacesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkInterfacesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkInterface(soap, "tds:NetworkInterfaces", &a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces, "tt:NetworkInterface"))
					continue;
			}
			soap_check_result(soap, "tds:NetworkInterfaces");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfacesResponse, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(_tds__GetNetworkInterfacesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfacesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkInterfacesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkInterfacesResponse *p;
	size_t k = sizeof(_tds__GetNetworkInterfacesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkInterfacesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkInterfacesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkInterfacesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkInterfacesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkInterfacesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkInterfacesResponse(soap, tag ? tag : "tds:GetNetworkInterfacesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkInterfacesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkInterfacesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__GetNetworkInterfacesResponse(struct soap *soap, _tds__GetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkInterfaces::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNetworkInterfaces::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNetworkInterfaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkInterfaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const _tds__GetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkInterfaces::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkInterfaces(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, _tds__GetNetworkInterfaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkInterfaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(_tds__GetNetworkInterfaces), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkInterfaces)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkInterfaces *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfaces, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(_tds__GetNetworkInterfaces), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkInterfaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkInterfaces *p;
	size_t k = sizeof(_tds__GetNetworkInterfaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkInterfaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkInterfaces);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkInterfaces, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkInterfaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkInterfaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkInterfaces(soap, tag ? tag : "tds:GetNetworkInterfaces", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkInterfaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkInterfaces(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDynamicDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDynamicDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDynamicDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDynamicDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const _tds__SetDynamicDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDynamicDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDynamicDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, _tds__SetDynamicDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDynamicDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(_tds__SetDynamicDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDynamicDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDynamicDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNSResponse, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(_tds__SetDynamicDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDynamicDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDynamicDNSResponse *p;
	size_t k = sizeof(_tds__SetDynamicDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDynamicDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDynamicDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDynamicDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDynamicDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDynamicDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDynamicDNSResponse(soap, tag ? tag : "tds:SetDynamicDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDynamicDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDynamicDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__SetDynamicDNSResponse(struct soap *soap, _tds__SetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDynamicDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DynamicDNSType(soap, &this->_tds__SetDynamicDNS::Type);
	this->_tds__SetDynamicDNS::Name = NULL;
	this->_tds__SetDynamicDNS::TTL = NULL;
}

void _tds__SetDynamicDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSName(soap, &this->_tds__SetDynamicDNS::Name);
	soap_serialize_PointerToxsd__duration(soap, &this->_tds__SetDynamicDNS::TTL);
#endif
}

int _tds__SetDynamicDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDynamicDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const _tds__SetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNS), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tds:Type", -1, &a->_tds__SetDynamicDNS::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tds:Name", -1, &a->_tds__SetDynamicDNS::Name, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tds:TTL", -1, &a->_tds__SetDynamicDNS::TTL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDynamicDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDynamicDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDynamicDNS * SOAP_FMAC4 soap_in__tds__SetDynamicDNS(struct soap *soap, const char *tag, _tds__SetDynamicDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDynamicDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(_tds__SetDynamicDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDynamicDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDynamicDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TTL1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DynamicDNSType(soap, "tds:Type", &a->_tds__SetDynamicDNS::Type, "tt:DynamicDNSType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__DNSName(soap, "tds:Name", &a->_tds__SetDynamicDNS::Name, "tt:DNSName"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_TTL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tds:TTL", &a->_tds__SetDynamicDNS::TTL, "xsd:duration"))
				{	soap_flag_TTL1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNS, SOAP_TYPE__tds__SetDynamicDNS, sizeof(_tds__SetDynamicDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDynamicDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDynamicDNS *p;
	size_t k = sizeof(_tds__SetDynamicDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDynamicDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDynamicDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDynamicDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDynamicDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDynamicDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDynamicDNS(soap, tag ? tag : "tds:SetDynamicDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDynamicDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDynamicDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDynamicDNS * SOAP_FMAC4 soap_get__tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDynamicDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDynamicDNSResponse::DynamicDNSInformation = NULL;
}

void _tds__GetDynamicDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DynamicDNSInformation(soap, &this->_tds__GetDynamicDNSResponse::DynamicDNSInformation);
#endif
}

int _tds__GetDynamicDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDynamicDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const _tds__GetDynamicDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNSResponse), type))
		return soap->error;
	if (a->DynamicDNSInformation)
		soap_element_result(soap, "tds:DynamicDNSInformation");
	if (!a->_tds__GetDynamicDNSResponse::DynamicDNSInformation)
	{	if (soap_element_empty(soap, "tds:DynamicDNSInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", -1, &a->_tds__GetDynamicDNSResponse::DynamicDNSInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDynamicDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDynamicDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, _tds__GetDynamicDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDynamicDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(_tds__GetDynamicDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDynamicDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDynamicDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DynamicDNSInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DynamicDNSInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", &a->_tds__GetDynamicDNSResponse::DynamicDNSInformation, "tt:DynamicDNSInformation"))
				{	soap_flag_DynamicDNSInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DynamicDNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetDynamicDNSResponse::DynamicDNSInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNSResponse, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(_tds__GetDynamicDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDynamicDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDynamicDNSResponse *p;
	size_t k = sizeof(_tds__GetDynamicDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDynamicDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDynamicDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDynamicDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDynamicDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDynamicDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDynamicDNSResponse(soap, tag ? tag : "tds:GetDynamicDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDynamicDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDynamicDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__GetDynamicDNSResponse(struct soap *soap, _tds__GetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDynamicDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDynamicDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDynamicDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDynamicDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const _tds__GetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDynamicDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDynamicDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDynamicDNS * SOAP_FMAC4 soap_in__tds__GetDynamicDNS(struct soap *soap, const char *tag, _tds__GetDynamicDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDynamicDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(_tds__GetDynamicDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDynamicDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDynamicDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNS, SOAP_TYPE__tds__GetDynamicDNS, sizeof(_tds__GetDynamicDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDynamicDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDynamicDNS *p;
	size_t k = sizeof(_tds__GetDynamicDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDynamicDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDynamicDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDynamicDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDynamicDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDynamicDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDynamicDNS(soap, tag ? tag : "tds:GetDynamicDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDynamicDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDynamicDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDynamicDNS * SOAP_FMAC4 soap_get__tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNTPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetNTPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetNTPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNTPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTPResponse(struct soap *soap, const char *tag, int id, const _tds__SetNTPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTPResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNTPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNTPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNTPResponse * SOAP_FMAC4 soap_in__tds__SetNTPResponse(struct soap *soap, const char *tag, _tds__SetNTPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNTPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTPResponse, sizeof(_tds__SetNTPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNTPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNTPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTPResponse, SOAP_TYPE__tds__SetNTPResponse, sizeof(_tds__SetNTPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__SetNTPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNTPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNTPResponse *p;
	size_t k = sizeof(_tds__SetNTPResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNTPResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNTPResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNTPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNTPResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNTPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNTPResponse(soap, tag ? tag : "tds:SetNTPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNTPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNTPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNTPResponse * SOAP_FMAC4 soap_get__tds__SetNTPResponse(struct soap *soap, _tds__SetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNTP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetNTP::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__SetNTP::NTPManual);
}

void _tds__SetNTP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetNTP::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__SetNTP::NTPManual);
#endif
}

int _tds__SetNTP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNTP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTP(struct soap *soap, const char *tag, int id, const _tds__SetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTP), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &a->_tds__SetNTP::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:NTPManual", -1, &a->_tds__SetNTP::NTPManual, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNTP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNTP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNTP * SOAP_FMAC4 soap_in__tds__SetNTP(struct soap *soap, const char *tag, _tds__SetNTP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNTP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTP, sizeof(_tds__SetNTP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNTP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNTP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:FromDHCP", &a->_tds__SetNTP::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:NTPManual", &a->_tds__SetNTP::NTPManual, "tt:NetworkHost"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTP, SOAP_TYPE__tds__SetNTP, sizeof(_tds__SetNTP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNTP * SOAP_FMAC2 soap_instantiate__tds__SetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNTP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNTP *p;
	size_t k = sizeof(_tds__SetNTP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNTP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNTP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNTP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNTP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNTP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNTP(soap, tag ? tag : "tds:SetNTP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNTP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNTP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNTP * SOAP_FMAC4 soap_get__tds__SetNTP(struct soap *soap, _tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNTPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetNTPResponse::NTPInformation = NULL;
}

void _tds__GetNTPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NTPInformation(soap, &this->_tds__GetNTPResponse::NTPInformation);
#endif
}

int _tds__GetNTPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNTPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTPResponse(struct soap *soap, const char *tag, int id, const _tds__GetNTPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTPResponse), type))
		return soap->error;
	if (a->NTPInformation)
		soap_element_result(soap, "tds:NTPInformation");
	if (!a->_tds__GetNTPResponse::NTPInformation)
	{	if (soap_element_empty(soap, "tds:NTPInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NTPInformation(soap, "tds:NTPInformation", -1, &a->_tds__GetNTPResponse::NTPInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNTPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNTPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNTPResponse * SOAP_FMAC4 soap_in__tds__GetNTPResponse(struct soap *soap, const char *tag, _tds__GetNTPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNTPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTPResponse, sizeof(_tds__GetNTPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNTPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNTPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NTPInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NTPInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NTPInformation(soap, "tds:NTPInformation", &a->_tds__GetNTPResponse::NTPInformation, "tt:NTPInformation"))
				{	soap_flag_NTPInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NTPInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetNTPResponse::NTPInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTPResponse, SOAP_TYPE__tds__GetNTPResponse, sizeof(_tds__GetNTPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__GetNTPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNTPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNTPResponse *p;
	size_t k = sizeof(_tds__GetNTPResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNTPResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNTPResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNTPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNTPResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNTPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNTPResponse(soap, tag ? tag : "tds:GetNTPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNTPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNTPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNTPResponse * SOAP_FMAC4 soap_get__tds__GetNTPResponse(struct soap *soap, _tds__GetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNTP::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNTP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNTP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNTP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTP(struct soap *soap, const char *tag, int id, const _tds__GetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTP), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNTP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNTP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNTP * SOAP_FMAC4 soap_in__tds__GetNTP(struct soap *soap, const char *tag, _tds__GetNTP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNTP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTP, sizeof(_tds__GetNTP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNTP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNTP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTP, SOAP_TYPE__tds__GetNTP, sizeof(_tds__GetNTP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNTP * SOAP_FMAC2 soap_instantiate__tds__GetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNTP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNTP *p;
	size_t k = sizeof(_tds__GetNTP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNTP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNTP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNTP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNTP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNTP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNTP(soap, tag ? tag : "tds:GetNTP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNTP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNTP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNTP * SOAP_FMAC4 soap_get__tds__GetNTP(struct soap *soap, _tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNSResponse(struct soap *soap, const char *tag, int id, const _tds__SetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDNSResponse * SOAP_FMAC4 soap_in__tds__SetDNSResponse(struct soap *soap, const char *tag, _tds__SetDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNSResponse, sizeof(_tds__SetDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNSResponse, SOAP_TYPE__tds__SetDNSResponse, sizeof(_tds__SetDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDNSResponse *p;
	size_t k = sizeof(_tds__SetDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDNSResponse(soap, tag ? tag : "tds:SetDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDNSResponse * SOAP_FMAC4 soap_get__tds__SetDNSResponse(struct soap *soap, _tds__SetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetDNS::FromDHCP);
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->_tds__SetDNS::SearchDomain);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->_tds__SetDNS::DNSManual);
}

void _tds__SetDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetDNS::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->_tds__SetDNS::SearchDomain);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->_tds__SetDNS::DNSManual);
#endif
}

int _tds__SetDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNS(struct soap *soap, const char *tag, int id, const _tds__SetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNS), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &a->_tds__SetDNS::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tds:SearchDomain", -1, &a->_tds__SetDNS::SearchDomain, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tds:DNSManual", -1, &a->_tds__SetDNS::DNSManual, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDNS * SOAP_FMAC4 soap_in__tds__SetDNS(struct soap *soap, const char *tag, _tds__SetDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNS, sizeof(_tds__SetDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:FromDHCP", &a->_tds__SetDNS::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tds:SearchDomain", &a->_tds__SetDNS::SearchDomain, "xsd:token"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tds:DNSManual", &a->_tds__SetDNS::DNSManual, "tt:IPAddress"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNS, SOAP_TYPE__tds__SetDNS, sizeof(_tds__SetDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDNS * SOAP_FMAC2 soap_instantiate__tds__SetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDNS *p;
	size_t k = sizeof(_tds__SetDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDNS(soap, tag ? tag : "tds:SetDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDNS * SOAP_FMAC4 soap_get__tds__SetDNS(struct soap *soap, _tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDNSResponse::DNSInformation = NULL;
}

void _tds__GetDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSInformation(soap, &this->_tds__GetDNSResponse::DNSInformation);
#endif
}

int _tds__GetDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNSResponse(struct soap *soap, const char *tag, int id, const _tds__GetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNSResponse), type))
		return soap->error;
	if (a->DNSInformation)
		soap_element_result(soap, "tds:DNSInformation");
	if (!a->_tds__GetDNSResponse::DNSInformation)
	{	if (soap_element_empty(soap, "tds:DNSInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DNSInformation(soap, "tds:DNSInformation", -1, &a->_tds__GetDNSResponse::DNSInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDNSResponse * SOAP_FMAC4 soap_in__tds__GetDNSResponse(struct soap *soap, const char *tag, _tds__GetDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNSResponse, sizeof(_tds__GetDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DNSInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DNSInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DNSInformation(soap, "tds:DNSInformation", &a->_tds__GetDNSResponse::DNSInformation, "tt:DNSInformation"))
				{	soap_flag_DNSInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetDNSResponse::DNSInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNSResponse, SOAP_TYPE__tds__GetDNSResponse, sizeof(_tds__GetDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDNSResponse *p;
	size_t k = sizeof(_tds__GetDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDNSResponse(soap, tag ? tag : "tds:GetDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDNSResponse * SOAP_FMAC4 soap_get__tds__GetDNSResponse(struct soap *soap, _tds__GetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNS(struct soap *soap, const char *tag, int id, const _tds__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDNS * SOAP_FMAC4 soap_in__tds__GetDNS(struct soap *soap, const char *tag, _tds__GetDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNS, sizeof(_tds__GetDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNS, SOAP_TYPE__tds__GetDNS, sizeof(_tds__GetDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDNS * SOAP_FMAC2 soap_instantiate__tds__GetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDNS *p;
	size_t k = sizeof(_tds__GetDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDNS(soap, tag ? tag : "tds:GetDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDNS * SOAP_FMAC4 soap_get__tds__GetDNS(struct soap *soap, _tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostnameFromDHCPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetHostnameFromDHCPResponse::RebootNeeded);
}

void _tds__SetHostnameFromDHCPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHostnameFromDHCPResponse::RebootNeeded, SOAP_TYPE_bool);
#endif
}

int _tds__SetHostnameFromDHCPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameFromDHCPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, const _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_bool(soap, "tds:RebootNeeded", -1, &a->_tds__SetHostnameFromDHCPResponse::RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameFromDHCPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameFromDHCPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(_tds__SetHostnameFromDHCPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostnameFromDHCPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostnameFromDHCPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RebootNeeded1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:RebootNeeded", &a->_tds__SetHostnameFromDHCPResponse::RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHostnameFromDHCPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(_tds__SetHostnameFromDHCPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameFromDHCPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostnameFromDHCPResponse *p;
	size_t k = sizeof(_tds__SetHostnameFromDHCPResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostnameFromDHCPResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostnameFromDHCPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostnameFromDHCPResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostnameFromDHCPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostnameFromDHCPResponse(soap, tag ? tag : "tds:SetHostnameFromDHCPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameFromDHCPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameFromDHCPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCPResponse(struct soap *soap, _tds__SetHostnameFromDHCPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostnameFromDHCP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetHostnameFromDHCP::FromDHCP);
}

void _tds__SetHostnameFromDHCP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHostnameFromDHCP::FromDHCP, SOAP_TYPE_bool);
#endif
}

int _tds__SetHostnameFromDHCP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameFromDHCP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const _tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCP), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &a->_tds__SetHostnameFromDHCP::FromDHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameFromDHCP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostnameFromDHCP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameFromDHCP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(_tds__SetHostnameFromDHCP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostnameFromDHCP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostnameFromDHCP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:FromDHCP", &a->_tds__SetHostnameFromDHCP::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHostnameFromDHCP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCP, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(_tds__SetHostnameFromDHCP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameFromDHCP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostnameFromDHCP *p;
	size_t k = sizeof(_tds__SetHostnameFromDHCP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostnameFromDHCP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostnameFromDHCP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostnameFromDHCP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostnameFromDHCP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostnameFromDHCP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostnameFromDHCP(soap, tag ? tag : "tds:SetHostnameFromDHCP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameFromDHCP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameFromDHCP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostnameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetHostnameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetHostnameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, const _tds__SetHostnameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostnameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameResponse * SOAP_FMAC4 soap_in__tds__SetHostnameResponse(struct soap *soap, const char *tag, _tds__SetHostnameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(_tds__SetHostnameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostnameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostnameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameResponse, SOAP_TYPE__tds__SetHostnameResponse, sizeof(_tds__SetHostnameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostnameResponse *p;
	size_t k = sizeof(_tds__SetHostnameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostnameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostnameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostnameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostnameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostnameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostnameResponse(soap, tag ? tag : "tds:SetHostnameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameResponse * SOAP_FMAC4 soap_get__tds__SetHostnameResponse(struct soap *soap, _tds__SetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostname::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__SetHostname::Name);
}

void _tds__SetHostname::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHostname::Name, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->_tds__SetHostname::Name);
#endif
}

int _tds__SetHostname::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostname(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostname(struct soap *soap, const char *tag, int id, const _tds__SetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostname), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:Name", -1, &a->_tds__SetHostname::Name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostname::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostname(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostname * SOAP_FMAC4 soap_in__tds__SetHostname(struct soap *soap, const char *tag, _tds__SetHostname *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostname*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostname, sizeof(_tds__SetHostname), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostname)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostname *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:Name", &a->_tds__SetHostname::Name, "xsd:token"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostname, SOAP_TYPE__tds__SetHostname, sizeof(_tds__SetHostname), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostname * SOAP_FMAC2 soap_instantiate__tds__SetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostname *p;
	size_t k = sizeof(_tds__SetHostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostname);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostname, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostname::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostname(soap, tag ? tag : "tds:SetHostname", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostname::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostname(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostname * SOAP_FMAC4 soap_get__tds__SetHostname(struct soap *soap, _tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetHostnameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetHostnameResponse::HostnameInformation = NULL;
}

void _tds__GetHostnameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__HostnameInformation(soap, &this->_tds__GetHostnameResponse::HostnameInformation);
#endif
}

int _tds__GetHostnameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetHostnameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, const _tds__GetHostnameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostnameResponse), type))
		return soap->error;
	if (a->HostnameInformation)
		soap_element_result(soap, "tds:HostnameInformation");
	if (!a->_tds__GetHostnameResponse::HostnameInformation)
	{	if (soap_element_empty(soap, "tds:HostnameInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", -1, &a->_tds__GetHostnameResponse::HostnameInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetHostnameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetHostnameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetHostnameResponse * SOAP_FMAC4 soap_in__tds__GetHostnameResponse(struct soap *soap, const char *tag, _tds__GetHostnameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetHostnameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(_tds__GetHostnameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetHostnameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetHostnameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HostnameInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostnameInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", &a->_tds__GetHostnameResponse::HostnameInformation, "tt:HostnameInformation"))
				{	soap_flag_HostnameInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:HostnameInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetHostnameResponse::HostnameInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostnameResponse, SOAP_TYPE__tds__GetHostnameResponse, sizeof(_tds__GetHostnameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__GetHostnameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetHostnameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetHostnameResponse *p;
	size_t k = sizeof(_tds__GetHostnameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetHostnameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetHostnameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetHostnameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetHostnameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetHostnameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetHostnameResponse(soap, tag ? tag : "tds:GetHostnameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetHostnameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetHostnameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetHostnameResponse * SOAP_FMAC4 soap_get__tds__GetHostnameResponse(struct soap *soap, _tds__GetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetHostname::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetHostname::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetHostname::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetHostname(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostname(struct soap *soap, const char *tag, int id, const _tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostname), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetHostname::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetHostname(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetHostname * SOAP_FMAC4 soap_in__tds__GetHostname(struct soap *soap, const char *tag, _tds__GetHostname *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetHostname*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostname, sizeof(_tds__GetHostname), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetHostname)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetHostname *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostname, SOAP_TYPE__tds__GetHostname, sizeof(_tds__GetHostname), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetHostname * SOAP_FMAC2 soap_instantiate__tds__GetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetHostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetHostname *p;
	size_t k = sizeof(_tds__GetHostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetHostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetHostname);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetHostname, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetHostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetHostname::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetHostname(soap, tag ? tag : "tds:GetHostname", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetHostname::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetHostname(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetHostname * SOAP_FMAC4 soap_get__tds__GetHostname(struct soap *soap, _tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCapabilitiesResponse::Capabilities = NULL;
}

void _tds__GetCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Capabilities(soap, &this->_tds__GetCapabilitiesResponse::Capabilities);
#endif
}

int _tds__GetCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->_tds__GetCapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Capabilities(soap, "tds:Capabilities", -1, &a->_tds__GetCapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(_tds__GetCapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Capabilities(soap, "tds:Capabilities", &a->_tds__GetCapabilitiesResponse::Capabilities, "tt:Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetCapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(_tds__GetCapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCapabilitiesResponse *p;
	size_t k = sizeof(_tds__GetCapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCapabilitiesResponse(soap, tag ? tag : "tds:GetCapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetCapabilitiesResponse(struct soap *soap, _tds__GetCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__CapabilityCategory(soap, &this->_tds__GetCapabilities::Category);
}

void _tds__GetCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__CapabilityCategory(soap, &this->_tds__GetCapabilities::Category);
#endif
}

int _tds__GetCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilities(struct soap *soap, const char *tag, int id, const _tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilities), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__CapabilityCategory(soap, "tds:Category", -1, &a->_tds__GetCapabilities::Category, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCapabilities * SOAP_FMAC4 soap_in__tds__GetCapabilities(struct soap *soap, const char *tag, _tds__GetCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(_tds__GetCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__CapabilityCategory(soap, "tds:Category", &a->_tds__GetCapabilities::Category, "tt:CapabilityCategory"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, SOAP_TYPE__tds__GetCapabilities, sizeof(_tds__GetCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCapabilities *p;
	size_t k = sizeof(_tds__GetCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCapabilities(soap, tag ? tag : "tds:GetCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCapabilities * SOAP_FMAC4 soap_get__tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetAuthFailureWarningConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetAuthFailureWarningConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetAuthFailureWarningConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAuthFailureWarningConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAuthFailureWarningConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetAuthFailureWarningConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAuthFailureWarningConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetAuthFailureWarningConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetAuthFailureWarningConfigurationResponse(struct soap *soap, const char *tag, _tds__SetAuthFailureWarningConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAuthFailureWarningConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse, sizeof(_tds__SetAuthFailureWarningConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetAuthFailureWarningConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetAuthFailureWarningConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse, sizeof(_tds__SetAuthFailureWarningConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAuthFailureWarningConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetAuthFailureWarningConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAuthFailureWarningConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetAuthFailureWarningConfigurationResponse *p;
	size_t k = sizeof(_tds__SetAuthFailureWarningConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetAuthFailureWarningConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetAuthFailureWarningConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetAuthFailureWarningConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetAuthFailureWarningConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetAuthFailureWarningConfigurationResponse(soap, tag ? tag : "tds:SetAuthFailureWarningConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAuthFailureWarningConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAuthFailureWarningConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetAuthFailureWarningConfigurationResponse(struct soap *soap, _tds__SetAuthFailureWarningConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAuthFailureWarningConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetAuthFailureWarningConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetAuthFailureWarningConfiguration::Enabled);
	soap_default_int(soap, &this->_tds__SetAuthFailureWarningConfiguration::MonitorPeriod);
	soap_default_int(soap, &this->_tds__SetAuthFailureWarningConfiguration::MaxAuthFailures);
}

void _tds__SetAuthFailureWarningConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetAuthFailureWarningConfiguration::Enabled, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_tds__SetAuthFailureWarningConfiguration::MonitorPeriod, SOAP_TYPE_int);
	soap_embedded(soap, &this->_tds__SetAuthFailureWarningConfiguration::MaxAuthFailures, SOAP_TYPE_int);
#endif
}

int _tds__SetAuthFailureWarningConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAuthFailureWarningConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__SetAuthFailureWarningConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:MonitorPeriod", -1, &a->_tds__SetAuthFailureWarningConfiguration::MonitorPeriod, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:MaxAuthFailures", -1, &a->_tds__SetAuthFailureWarningConfiguration::MaxAuthFailures, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAuthFailureWarningConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetAuthFailureWarningConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_in__tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, _tds__SetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAuthFailureWarningConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, sizeof(_tds__SetAuthFailureWarningConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetAuthFailureWarningConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetAuthFailureWarningConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_MonitorPeriod1 = 1;
	size_t soap_flag_MaxAuthFailures1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__SetAuthFailureWarningConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_MonitorPeriod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:MonitorPeriod", &a->_tds__SetAuthFailureWarningConfiguration::MonitorPeriod, "xsd:int"))
				{	soap_flag_MonitorPeriod1--;
					continue;
				}
			}
			if (soap_flag_MaxAuthFailures1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:MaxAuthFailures", &a->_tds__SetAuthFailureWarningConfiguration::MaxAuthFailures, "xsd:int"))
				{	soap_flag_MaxAuthFailures1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0 || soap_flag_MonitorPeriod1 > 0 || soap_flag_MaxAuthFailures1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetAuthFailureWarningConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, sizeof(_tds__SetAuthFailureWarningConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetAuthFailureWarningConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAuthFailureWarningConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetAuthFailureWarningConfiguration *p;
	size_t k = sizeof(_tds__SetAuthFailureWarningConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetAuthFailureWarningConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetAuthFailureWarningConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetAuthFailureWarningConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetAuthFailureWarningConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetAuthFailureWarningConfiguration(soap, tag ? tag : "tds:SetAuthFailureWarningConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAuthFailureWarningConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAuthFailureWarningConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_get__tds__SetAuthFailureWarningConfiguration(struct soap *soap, _tds__SetAuthFailureWarningConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAuthFailureWarningConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::Enabled);
	soap_default_int(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::MonitorPeriod);
	soap_default_int(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::MaxAuthFailures);
}

void _tds__GetAuthFailureWarningConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::Enabled, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::MonitorPeriod, SOAP_TYPE_int);
	soap_embedded(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::MaxAuthFailures, SOAP_TYPE_int);
#endif
}

int _tds__GetAuthFailureWarningConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAuthFailureWarningConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAuthFailureWarningConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetAuthFailureWarningConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__GetAuthFailureWarningConfigurationResponse::Enabled, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:MonitorPeriod", -1, &a->_tds__GetAuthFailureWarningConfigurationResponse::MonitorPeriod, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:MaxAuthFailures", -1, &a->_tds__GetAuthFailureWarningConfigurationResponse::MaxAuthFailures, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAuthFailureWarningConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAuthFailureWarningConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetAuthFailureWarningConfigurationResponse(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAuthFailureWarningConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse, sizeof(_tds__GetAuthFailureWarningConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAuthFailureWarningConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_MonitorPeriod1 = 1;
	size_t soap_flag_MaxAuthFailures1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__GetAuthFailureWarningConfigurationResponse::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_MonitorPeriod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:MonitorPeriod", &a->_tds__GetAuthFailureWarningConfigurationResponse::MonitorPeriod, "xsd:int"))
				{	soap_flag_MonitorPeriod1--;
					continue;
				}
			}
			if (soap_flag_MaxAuthFailures1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:MaxAuthFailures", &a->_tds__GetAuthFailureWarningConfigurationResponse::MaxAuthFailures, "xsd:int"))
				{	soap_flag_MaxAuthFailures1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0 || soap_flag_MonitorPeriod1 > 0 || soap_flag_MaxAuthFailures1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetAuthFailureWarningConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse, sizeof(_tds__GetAuthFailureWarningConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAuthFailureWarningConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAuthFailureWarningConfigurationResponse *p;
	size_t k = sizeof(_tds__GetAuthFailureWarningConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAuthFailureWarningConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAuthFailureWarningConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAuthFailureWarningConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAuthFailureWarningConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAuthFailureWarningConfigurationResponse(soap, tag ? tag : "tds:GetAuthFailureWarningConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAuthFailureWarningConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAuthFailureWarningConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetAuthFailureWarningConfigurationResponse(struct soap *soap, _tds__GetAuthFailureWarningConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAuthFailureWarningConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAuthFailureWarningConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetAuthFailureWarningConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetAuthFailureWarningConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAuthFailureWarningConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAuthFailureWarningConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAuthFailureWarningConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_in__tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAuthFailureWarningConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, sizeof(_tds__GetAuthFailureWarningConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAuthFailureWarningConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAuthFailureWarningConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetAuthFailureWarningConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, sizeof(_tds__GetAuthFailureWarningConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAuthFailureWarningConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAuthFailureWarningConfiguration *p;
	size_t k = sizeof(_tds__GetAuthFailureWarningConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAuthFailureWarningConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAuthFailureWarningConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAuthFailureWarningConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAuthFailureWarningConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAuthFailureWarningConfiguration(soap, tag ? tag : "tds:GetAuthFailureWarningConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAuthFailureWarningConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAuthFailureWarningConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_get__tds__GetAuthFailureWarningConfiguration(struct soap *soap, _tds__GetAuthFailureWarningConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAuthFailureWarningOptionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange = NULL;
	this->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange = NULL;
}

void _tds__GetAuthFailureWarningOptionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange);
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange);
#endif
}

int _tds__GetAuthFailureWarningOptionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAuthFailureWarningOptionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAuthFailureWarningOptionsResponse(struct soap *soap, const char *tag, int id, const _tds__GetAuthFailureWarningOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse), type))
		return soap->error;
	if (a->MonitorPeriodRange)
		soap_element_result(soap, "tds:MonitorPeriodRange");
	if (!a->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange)
	{	if (soap_element_empty(soap, "tds:MonitorPeriodRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tds:MonitorPeriodRange", -1, &a->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange, ""))
		return soap->error;
	if (!a->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange)
	{	if (soap_element_empty(soap, "tds:AuthFailureRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tds:AuthFailureRange", -1, &a->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAuthFailureWarningOptionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAuthFailureWarningOptionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptionsResponse * SOAP_FMAC4 soap_in__tds__GetAuthFailureWarningOptionsResponse(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningOptionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAuthFailureWarningOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse, sizeof(_tds__GetAuthFailureWarningOptionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAuthFailureWarningOptionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MonitorPeriodRange1 = 1;
	size_t soap_flag_AuthFailureRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MonitorPeriodRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:MonitorPeriodRange", &a->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange, "tt:IntRange"))
				{	soap_flag_MonitorPeriodRange1--;
					continue;
				}
			}
			if (soap_flag_AuthFailureRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:AuthFailureRange", &a->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange, "tt:IntRange"))
				{	soap_flag_AuthFailureRange1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:MonitorPeriodRange");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange || !a->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetAuthFailureWarningOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse, sizeof(_tds__GetAuthFailureWarningOptionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningOptionsResponse * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningOptionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAuthFailureWarningOptionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAuthFailureWarningOptionsResponse *p;
	size_t k = sizeof(_tds__GetAuthFailureWarningOptionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAuthFailureWarningOptionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAuthFailureWarningOptionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAuthFailureWarningOptionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAuthFailureWarningOptionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAuthFailureWarningOptionsResponse(soap, tag ? tag : "tds:GetAuthFailureWarningOptionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAuthFailureWarningOptionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAuthFailureWarningOptionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptionsResponse * SOAP_FMAC4 soap_get__tds__GetAuthFailureWarningOptionsResponse(struct soap *soap, _tds__GetAuthFailureWarningOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAuthFailureWarningOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAuthFailureWarningOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetAuthFailureWarningOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetAuthFailureWarningOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAuthFailureWarningOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, int id, const _tds__GetAuthFailureWarningOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAuthFailureWarningOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAuthFailureWarningOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAuthFailureWarningOptions(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptions * SOAP_FMAC4 soap_in__tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAuthFailureWarningOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAuthFailureWarningOptions, sizeof(_tds__GetAuthFailureWarningOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAuthFailureWarningOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAuthFailureWarningOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetAuthFailureWarningOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAuthFailureWarningOptions, SOAP_TYPE__tds__GetAuthFailureWarningOptions, sizeof(_tds__GetAuthFailureWarningOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningOptions * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAuthFailureWarningOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAuthFailureWarningOptions *p;
	size_t k = sizeof(_tds__GetAuthFailureWarningOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAuthFailureWarningOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAuthFailureWarningOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAuthFailureWarningOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAuthFailureWarningOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAuthFailureWarningOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAuthFailureWarningOptions(soap, tag ? tag : "tds:GetAuthFailureWarningOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAuthFailureWarningOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAuthFailureWarningOptions(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptions * SOAP_FMAC4 soap_get__tds__GetAuthFailureWarningOptions(struct soap *soap, _tds__GetAuthFailureWarningOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAuthFailureWarningOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetPasswordHistoryConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetPasswordHistoryConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetPasswordHistoryConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetPasswordHistoryConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetPasswordHistoryConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetPasswordHistoryConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetPasswordHistoryConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetPasswordHistoryConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetPasswordHistoryConfigurationResponse(struct soap *soap, const char *tag, _tds__SetPasswordHistoryConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetPasswordHistoryConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse, sizeof(_tds__SetPasswordHistoryConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetPasswordHistoryConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetPasswordHistoryConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse, sizeof(_tds__SetPasswordHistoryConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetPasswordHistoryConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetPasswordHistoryConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetPasswordHistoryConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetPasswordHistoryConfigurationResponse *p;
	size_t k = sizeof(_tds__SetPasswordHistoryConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetPasswordHistoryConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetPasswordHistoryConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetPasswordHistoryConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetPasswordHistoryConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetPasswordHistoryConfigurationResponse(soap, tag ? tag : "tds:SetPasswordHistoryConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetPasswordHistoryConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetPasswordHistoryConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetPasswordHistoryConfigurationResponse(struct soap *soap, _tds__SetPasswordHistoryConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetPasswordHistoryConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetPasswordHistoryConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetPasswordHistoryConfiguration::Enabled);
	soap_default_int(soap, &this->_tds__SetPasswordHistoryConfiguration::Length);
}

void _tds__SetPasswordHistoryConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetPasswordHistoryConfiguration::Enabled, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_tds__SetPasswordHistoryConfiguration::Length, SOAP_TYPE_int);
#endif
}

int _tds__SetPasswordHistoryConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetPasswordHistoryConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetPasswordHistoryConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetPasswordHistoryConfiguration), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__SetPasswordHistoryConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:Length", -1, &a->_tds__SetPasswordHistoryConfiguration::Length, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetPasswordHistoryConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetPasswordHistoryConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfiguration * SOAP_FMAC4 soap_in__tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, _tds__SetPasswordHistoryConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetPasswordHistoryConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, sizeof(_tds__SetPasswordHistoryConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetPasswordHistoryConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetPasswordHistoryConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Length1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__SetPasswordHistoryConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Length1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:Length", &a->_tds__SetPasswordHistoryConfiguration::Length, "xsd:int"))
				{	soap_flag_Length1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0 || soap_flag_Length1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetPasswordHistoryConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, sizeof(_tds__SetPasswordHistoryConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetPasswordHistoryConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetPasswordHistoryConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetPasswordHistoryConfiguration *p;
	size_t k = sizeof(_tds__SetPasswordHistoryConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetPasswordHistoryConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetPasswordHistoryConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetPasswordHistoryConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetPasswordHistoryConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetPasswordHistoryConfiguration(soap, tag ? tag : "tds:SetPasswordHistoryConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetPasswordHistoryConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetPasswordHistoryConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfiguration * SOAP_FMAC4 soap_get__tds__SetPasswordHistoryConfiguration(struct soap *soap, _tds__SetPasswordHistoryConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordHistoryConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__GetPasswordHistoryConfigurationResponse::Enabled);
	soap_default_int(soap, &this->_tds__GetPasswordHistoryConfigurationResponse::Length);
}

void _tds__GetPasswordHistoryConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetPasswordHistoryConfigurationResponse::Enabled, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_tds__GetPasswordHistoryConfigurationResponse::Length, SOAP_TYPE_int);
#endif
}

int _tds__GetPasswordHistoryConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordHistoryConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordHistoryConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetPasswordHistoryConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__GetPasswordHistoryConfigurationResponse::Enabled, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:Length", -1, &a->_tds__GetPasswordHistoryConfigurationResponse::Length, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordHistoryConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordHistoryConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetPasswordHistoryConfigurationResponse(struct soap *soap, const char *tag, _tds__GetPasswordHistoryConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordHistoryConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse, sizeof(_tds__GetPasswordHistoryConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordHistoryConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Length1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__GetPasswordHistoryConfigurationResponse::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Length1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:Length", &a->_tds__GetPasswordHistoryConfigurationResponse::Length, "xsd:int"))
				{	soap_flag_Length1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0 || soap_flag_Length1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetPasswordHistoryConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse, sizeof(_tds__GetPasswordHistoryConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordHistoryConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetPasswordHistoryConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordHistoryConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordHistoryConfigurationResponse *p;
	size_t k = sizeof(_tds__GetPasswordHistoryConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordHistoryConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordHistoryConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordHistoryConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordHistoryConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordHistoryConfigurationResponse(soap, tag ? tag : "tds:GetPasswordHistoryConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordHistoryConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordHistoryConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetPasswordHistoryConfigurationResponse(struct soap *soap, _tds__GetPasswordHistoryConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordHistoryConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordHistoryConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetPasswordHistoryConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetPasswordHistoryConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordHistoryConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetPasswordHistoryConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordHistoryConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordHistoryConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordHistoryConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfiguration * SOAP_FMAC4 soap_in__tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, _tds__GetPasswordHistoryConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordHistoryConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, sizeof(_tds__GetPasswordHistoryConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordHistoryConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordHistoryConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPasswordHistoryConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, sizeof(_tds__GetPasswordHistoryConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetPasswordHistoryConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordHistoryConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordHistoryConfiguration *p;
	size_t k = sizeof(_tds__GetPasswordHistoryConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordHistoryConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordHistoryConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordHistoryConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordHistoryConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordHistoryConfiguration(soap, tag ? tag : "tds:GetPasswordHistoryConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordHistoryConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordHistoryConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfiguration * SOAP_FMAC4 soap_get__tds__GetPasswordHistoryConfiguration(struct soap *soap, _tds__GetPasswordHistoryConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetPasswordComplexityConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetPasswordComplexityConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetPasswordComplexityConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetPasswordComplexityConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetPasswordComplexityConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetPasswordComplexityConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetPasswordComplexityConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetPasswordComplexityConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetPasswordComplexityConfigurationResponse(struct soap *soap, const char *tag, _tds__SetPasswordComplexityConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetPasswordComplexityConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse, sizeof(_tds__SetPasswordComplexityConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetPasswordComplexityConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetPasswordComplexityConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse, sizeof(_tds__SetPasswordComplexityConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetPasswordComplexityConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetPasswordComplexityConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetPasswordComplexityConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetPasswordComplexityConfigurationResponse *p;
	size_t k = sizeof(_tds__SetPasswordComplexityConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetPasswordComplexityConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetPasswordComplexityConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetPasswordComplexityConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetPasswordComplexityConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetPasswordComplexityConfigurationResponse(soap, tag ? tag : "tds:SetPasswordComplexityConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetPasswordComplexityConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetPasswordComplexityConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetPasswordComplexityConfigurationResponse(struct soap *soap, _tds__SetPasswordComplexityConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetPasswordComplexityConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetPasswordComplexityConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetPasswordComplexityConfiguration::MinLen = NULL;
	this->_tds__SetPasswordComplexityConfiguration::Uppercase = NULL;
	this->_tds__SetPasswordComplexityConfiguration::Number = NULL;
	this->_tds__SetPasswordComplexityConfiguration::SpecialChars = NULL;
	this->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence = NULL;
	this->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked = NULL;
}

void _tds__SetPasswordComplexityConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tds__SetPasswordComplexityConfiguration::MinLen);
	soap_serialize_PointerToint(soap, &this->_tds__SetPasswordComplexityConfiguration::Uppercase);
	soap_serialize_PointerToint(soap, &this->_tds__SetPasswordComplexityConfiguration::Number);
	soap_serialize_PointerToint(soap, &this->_tds__SetPasswordComplexityConfiguration::SpecialChars);
	soap_serialize_PointerTobool(soap, &this->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence);
	soap_serialize_PointerTobool(soap, &this->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked);
#endif
}

int _tds__SetPasswordComplexityConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetPasswordComplexityConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetPasswordComplexityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetPasswordComplexityConfiguration), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:MinLen", -1, &a->_tds__SetPasswordComplexityConfiguration::MinLen, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:Uppercase", -1, &a->_tds__SetPasswordComplexityConfiguration::Uppercase, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:Number", -1, &a->_tds__SetPasswordComplexityConfiguration::Number, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:SpecialChars", -1, &a->_tds__SetPasswordComplexityConfiguration::SpecialChars, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:BlockUsernameOccurrence", -1, &a->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:PolicyConfigurationLocked", -1, &a->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetPasswordComplexityConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetPasswordComplexityConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfiguration * SOAP_FMAC4 soap_in__tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, _tds__SetPasswordComplexityConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetPasswordComplexityConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, sizeof(_tds__SetPasswordComplexityConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetPasswordComplexityConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetPasswordComplexityConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MinLen1 = 1;
	size_t soap_flag_Uppercase1 = 1;
	size_t soap_flag_Number1 = 1;
	size_t soap_flag_SpecialChars1 = 1;
	size_t soap_flag_BlockUsernameOccurrence1 = 1;
	size_t soap_flag_PolicyConfigurationLocked1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinLen1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:MinLen", &a->_tds__SetPasswordComplexityConfiguration::MinLen, "xsd:int"))
				{	soap_flag_MinLen1--;
					continue;
				}
			}
			if (soap_flag_Uppercase1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:Uppercase", &a->_tds__SetPasswordComplexityConfiguration::Uppercase, "xsd:int"))
				{	soap_flag_Uppercase1--;
					continue;
				}
			}
			if (soap_flag_Number1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:Number", &a->_tds__SetPasswordComplexityConfiguration::Number, "xsd:int"))
				{	soap_flag_Number1--;
					continue;
				}
			}
			if (soap_flag_SpecialChars1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:SpecialChars", &a->_tds__SetPasswordComplexityConfiguration::SpecialChars, "xsd:int"))
				{	soap_flag_SpecialChars1--;
					continue;
				}
			}
			if (soap_flag_BlockUsernameOccurrence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:BlockUsernameOccurrence", &a->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence, "xsd:boolean"))
				{	soap_flag_BlockUsernameOccurrence1--;
					continue;
				}
			}
			if (soap_flag_PolicyConfigurationLocked1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:PolicyConfigurationLocked", &a->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked, "xsd:boolean"))
				{	soap_flag_PolicyConfigurationLocked1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetPasswordComplexityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, sizeof(_tds__SetPasswordComplexityConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetPasswordComplexityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetPasswordComplexityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetPasswordComplexityConfiguration *p;
	size_t k = sizeof(_tds__SetPasswordComplexityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetPasswordComplexityConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetPasswordComplexityConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetPasswordComplexityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetPasswordComplexityConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetPasswordComplexityConfiguration(soap, tag ? tag : "tds:SetPasswordComplexityConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetPasswordComplexityConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetPasswordComplexityConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfiguration * SOAP_FMAC4 soap_get__tds__SetPasswordComplexityConfiguration(struct soap *soap, _tds__SetPasswordComplexityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordComplexityConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetPasswordComplexityConfigurationResponse::MinLen = NULL;
	this->_tds__GetPasswordComplexityConfigurationResponse::Uppercase = NULL;
	this->_tds__GetPasswordComplexityConfigurationResponse::Number = NULL;
	this->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars = NULL;
	this->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence = NULL;
	this->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked = NULL;
}

void _tds__GetPasswordComplexityConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::MinLen);
	soap_serialize_PointerToint(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::Uppercase);
	soap_serialize_PointerToint(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::Number);
	soap_serialize_PointerToint(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars);
	soap_serialize_PointerTobool(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence);
	soap_serialize_PointerTobool(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked);
#endif
}

int _tds__GetPasswordComplexityConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordComplexityConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordComplexityConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetPasswordComplexityConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse), type))
		return soap->error;
	if (a->MinLen)
		soap_element_result(soap, "tds:MinLen");
	if (soap_out_PointerToint(soap, "tds:MinLen", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::MinLen, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:Uppercase", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::Uppercase, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:Number", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::Number, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:SpecialChars", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:BlockUsernameOccurrence", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:PolicyConfigurationLocked", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordComplexityConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordComplexityConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetPasswordComplexityConfigurationResponse(struct soap *soap, const char *tag, _tds__GetPasswordComplexityConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordComplexityConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse, sizeof(_tds__GetPasswordComplexityConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordComplexityConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MinLen1 = 1;
	size_t soap_flag_Uppercase1 = 1;
	size_t soap_flag_Number1 = 1;
	size_t soap_flag_SpecialChars1 = 1;
	size_t soap_flag_BlockUsernameOccurrence1 = 1;
	size_t soap_flag_PolicyConfigurationLocked1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinLen1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:MinLen", &a->_tds__GetPasswordComplexityConfigurationResponse::MinLen, "xsd:int"))
				{	soap_flag_MinLen1--;
					continue;
				}
			}
			if (soap_flag_Uppercase1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:Uppercase", &a->_tds__GetPasswordComplexityConfigurationResponse::Uppercase, "xsd:int"))
				{	soap_flag_Uppercase1--;
					continue;
				}
			}
			if (soap_flag_Number1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:Number", &a->_tds__GetPasswordComplexityConfigurationResponse::Number, "xsd:int"))
				{	soap_flag_Number1--;
					continue;
				}
			}
			if (soap_flag_SpecialChars1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:SpecialChars", &a->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars, "xsd:int"))
				{	soap_flag_SpecialChars1--;
					continue;
				}
			}
			if (soap_flag_BlockUsernameOccurrence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:BlockUsernameOccurrence", &a->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence, "xsd:boolean"))
				{	soap_flag_BlockUsernameOccurrence1--;
					continue;
				}
			}
			if (soap_flag_PolicyConfigurationLocked1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:PolicyConfigurationLocked", &a->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked, "xsd:boolean"))
				{	soap_flag_PolicyConfigurationLocked1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:MinLen");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPasswordComplexityConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse, sizeof(_tds__GetPasswordComplexityConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordComplexityConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordComplexityConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordComplexityConfigurationResponse *p;
	size_t k = sizeof(_tds__GetPasswordComplexityConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordComplexityConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordComplexityConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordComplexityConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordComplexityConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordComplexityConfigurationResponse(soap, tag ? tag : "tds:GetPasswordComplexityConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordComplexityConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordComplexityConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetPasswordComplexityConfigurationResponse(struct soap *soap, _tds__GetPasswordComplexityConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordComplexityConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordComplexityConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetPasswordComplexityConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetPasswordComplexityConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordComplexityConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetPasswordComplexityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordComplexityConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordComplexityConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordComplexityConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfiguration * SOAP_FMAC4 soap_in__tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, _tds__GetPasswordComplexityConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordComplexityConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, sizeof(_tds__GetPasswordComplexityConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordComplexityConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordComplexityConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPasswordComplexityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, sizeof(_tds__GetPasswordComplexityConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordComplexityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordComplexityConfiguration *p;
	size_t k = sizeof(_tds__GetPasswordComplexityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordComplexityConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordComplexityConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordComplexityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordComplexityConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordComplexityConfiguration(soap, tag ? tag : "tds:GetPasswordComplexityConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordComplexityConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordComplexityConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfiguration * SOAP_FMAC4 soap_get__tds__GetPasswordComplexityConfiguration(struct soap *soap, _tds__GetPasswordComplexityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordComplexityOptionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetPasswordComplexityOptionsResponse::MinLenRange = NULL;
	this->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange = NULL;
	this->_tds__GetPasswordComplexityOptionsResponse::NumberRange = NULL;
	this->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange = NULL;
	this->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported = NULL;
	this->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported = NULL;
}

void _tds__GetPasswordComplexityOptionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetPasswordComplexityOptionsResponse::MinLenRange);
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange);
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetPasswordComplexityOptionsResponse::NumberRange);
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange);
	soap_serialize_PointerTobool(soap, &this->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported);
	soap_serialize_PointerTobool(soap, &this->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported);
#endif
}

int _tds__GetPasswordComplexityOptionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordComplexityOptionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordComplexityOptionsResponse(struct soap *soap, const char *tag, int id, const _tds__GetPasswordComplexityOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse), type))
		return soap->error;
	if (a->MinLenRange)
		soap_element_result(soap, "tds:MinLenRange");
	if (soap_out_PointerTott__IntRange(soap, "tds:MinLenRange", -1, &a->_tds__GetPasswordComplexityOptionsResponse::MinLenRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tds:UppercaseRange", -1, &a->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tds:NumberRange", -1, &a->_tds__GetPasswordComplexityOptionsResponse::NumberRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tds:SpecialCharsRange", -1, &a->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:BlockUsernameOccurrenceSupported", -1, &a->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:PolicyConfigurationLockSupported", -1, &a->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordComplexityOptionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordComplexityOptionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptionsResponse * SOAP_FMAC4 soap_in__tds__GetPasswordComplexityOptionsResponse(struct soap *soap, const char *tag, _tds__GetPasswordComplexityOptionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordComplexityOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse, sizeof(_tds__GetPasswordComplexityOptionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordComplexityOptionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MinLenRange1 = 1;
	size_t soap_flag_UppercaseRange1 = 1;
	size_t soap_flag_NumberRange1 = 1;
	size_t soap_flag_SpecialCharsRange1 = 1;
	size_t soap_flag_BlockUsernameOccurrenceSupported1 = 1;
	size_t soap_flag_PolicyConfigurationLockSupported1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinLenRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:MinLenRange", &a->_tds__GetPasswordComplexityOptionsResponse::MinLenRange, "tt:IntRange"))
				{	soap_flag_MinLenRange1--;
					continue;
				}
			}
			if (soap_flag_UppercaseRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:UppercaseRange", &a->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange, "tt:IntRange"))
				{	soap_flag_UppercaseRange1--;
					continue;
				}
			}
			if (soap_flag_NumberRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:NumberRange", &a->_tds__GetPasswordComplexityOptionsResponse::NumberRange, "tt:IntRange"))
				{	soap_flag_NumberRange1--;
					continue;
				}
			}
			if (soap_flag_SpecialCharsRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:SpecialCharsRange", &a->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange, "tt:IntRange"))
				{	soap_flag_SpecialCharsRange1--;
					continue;
				}
			}
			if (soap_flag_BlockUsernameOccurrenceSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:BlockUsernameOccurrenceSupported", &a->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported, "xsd:boolean"))
				{	soap_flag_BlockUsernameOccurrenceSupported1--;
					continue;
				}
			}
			if (soap_flag_PolicyConfigurationLockSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:PolicyConfigurationLockSupported", &a->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported, "xsd:boolean"))
				{	soap_flag_PolicyConfigurationLockSupported1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:MinLenRange");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPasswordComplexityOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse, sizeof(_tds__GetPasswordComplexityOptionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordComplexityOptionsResponse * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityOptionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordComplexityOptionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordComplexityOptionsResponse *p;
	size_t k = sizeof(_tds__GetPasswordComplexityOptionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordComplexityOptionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordComplexityOptionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordComplexityOptionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordComplexityOptionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordComplexityOptionsResponse(soap, tag ? tag : "tds:GetPasswordComplexityOptionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordComplexityOptionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordComplexityOptionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptionsResponse * SOAP_FMAC4 soap_get__tds__GetPasswordComplexityOptionsResponse(struct soap *soap, _tds__GetPasswordComplexityOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordComplexityOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordComplexityOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetPasswordComplexityOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetPasswordComplexityOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordComplexityOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, int id, const _tds__GetPasswordComplexityOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordComplexityOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordComplexityOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordComplexityOptions(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptions * SOAP_FMAC4 soap_in__tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, _tds__GetPasswordComplexityOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordComplexityOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordComplexityOptions, sizeof(_tds__GetPasswordComplexityOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordComplexityOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordComplexityOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPasswordComplexityOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordComplexityOptions, SOAP_TYPE__tds__GetPasswordComplexityOptions, sizeof(_tds__GetPasswordComplexityOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordComplexityOptions * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordComplexityOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordComplexityOptions *p;
	size_t k = sizeof(_tds__GetPasswordComplexityOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordComplexityOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordComplexityOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordComplexityOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordComplexityOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordComplexityOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordComplexityOptions(soap, tag ? tag : "tds:GetPasswordComplexityOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordComplexityOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordComplexityOptions(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptions * SOAP_FMAC4 soap_get__tds__GetPasswordComplexityOptions(struct soap *soap, _tds__GetPasswordComplexityOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordComplexityOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetWsdlUrlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl);
}

void _tds__GetWsdlUrlResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl);
#endif
}

int _tds__GetWsdlUrlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetWsdlUrlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, const _tds__GetWsdlUrlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrlResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:WsdlUrl");
	if (soap_out_xsd__anyURI(soap, "tds:WsdlUrl", -1, &a->_tds__GetWsdlUrlResponse::WsdlUrl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetWsdlUrlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetWsdlUrlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_in__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, _tds__GetWsdlUrlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetWsdlUrlResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(_tds__GetWsdlUrlResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetWsdlUrlResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetWsdlUrlResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WsdlUrl1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WsdlUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:WsdlUrl", &a->_tds__GetWsdlUrlResponse::WsdlUrl, "xsd:anyURI"))
				{	soap_flag_WsdlUrl1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:WsdlUrl");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_WsdlUrl1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetWsdlUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrlResponse, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(_tds__GetWsdlUrlResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetWsdlUrlResponse * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetWsdlUrlResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetWsdlUrlResponse *p;
	size_t k = sizeof(_tds__GetWsdlUrlResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetWsdlUrlResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetWsdlUrlResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetWsdlUrlResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetWsdlUrlResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetWsdlUrlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetWsdlUrlResponse(soap, tag ? tag : "tds:GetWsdlUrlResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetWsdlUrlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetWsdlUrlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_get__tds__GetWsdlUrlResponse(struct soap *soap, _tds__GetWsdlUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetWsdlUrl::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetWsdlUrl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetWsdlUrl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetWsdlUrl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const _tds__GetWsdlUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrl), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetWsdlUrl::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetWsdlUrl(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetWsdlUrl * SOAP_FMAC4 soap_in__tds__GetWsdlUrl(struct soap *soap, const char *tag, _tds__GetWsdlUrl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetWsdlUrl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(_tds__GetWsdlUrl), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetWsdlUrl)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetWsdlUrl *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetWsdlUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrl, SOAP_TYPE__tds__GetWsdlUrl, sizeof(_tds__GetWsdlUrl), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetWsdlUrl(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetWsdlUrl *p;
	size_t k = sizeof(_tds__GetWsdlUrl);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetWsdlUrl, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetWsdlUrl);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetWsdlUrl, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetWsdlUrl location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetWsdlUrl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetWsdlUrl(soap, tag ? tag : "tds:GetWsdlUrl", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetWsdlUrl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetWsdlUrl(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetWsdlUrl * SOAP_FMAC4 soap_get__tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUserResponse(struct soap *soap, const char *tag, int id, const _tds__SetUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetUserResponse * SOAP_FMAC4 soap_in__tds__SetUserResponse(struct soap *soap, const char *tag, _tds__SetUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUserResponse, sizeof(_tds__SetUserResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetUserResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetUserResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUserResponse, SOAP_TYPE__tds__SetUserResponse, sizeof(_tds__SetUserResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetUserResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetUserResponse *p;
	size_t k = sizeof(_tds__SetUserResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetUserResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetUserResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetUserResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetUserResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetUserResponse(soap, tag ? tag : "tds:SetUserResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetUserResponse * SOAP_FMAC4 soap_get__tds__SetUserResponse(struct soap *soap, _tds__SetUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__SetUser::User);
}

void _tds__SetUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__SetUser::User);
#endif
}

int _tds__SetUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUser(struct soap *soap, const char *tag, int id, const _tds__SetUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUser), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__User(soap, "tds:User", -1, &a->_tds__SetUser::User, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetUser::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetUser(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetUser * SOAP_FMAC4 soap_in__tds__SetUser(struct soap *soap, const char *tag, _tds__SetUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUser, sizeof(_tds__SetUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__User(soap, "tds:User", &a->_tds__SetUser::User, "tt:User"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__SetUser::User.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUser, SOAP_TYPE__tds__SetUser, sizeof(_tds__SetUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetUser * SOAP_FMAC2 soap_instantiate__tds__SetUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetUser *p;
	size_t k = sizeof(_tds__SetUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetUser);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetUser, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetUser(soap, tag ? tag : "tds:SetUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetUser(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetUser * SOAP_FMAC4 soap_get__tds__SetUser(struct soap *soap, _tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteUsersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteUsersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteUsersResponse * SOAP_FMAC4 soap_in__tds__DeleteUsersResponse(struct soap *soap, const char *tag, _tds__DeleteUsersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(_tds__DeleteUsersResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteUsersResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteUsersResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsersResponse, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(_tds__DeleteUsersResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteUsersResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteUsersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteUsersResponse *p;
	size_t k = sizeof(_tds__DeleteUsersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteUsersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteUsersResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteUsersResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteUsersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteUsersResponse(soap, tag ? tag : "tds:DeleteUsersResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteUsersResponse * SOAP_FMAC4 soap_get__tds__DeleteUsersResponse(struct soap *soap, _tds__DeleteUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteUsers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_tds__DeleteUsers::Username);
}

void _tds__DeleteUsers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_tds__DeleteUsers::Username);
#endif
}

int _tds__DeleteUsers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteUsers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsers(struct soap *soap, const char *tag, int id, const _tds__DeleteUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsers), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tds:Username", -1, &a->_tds__DeleteUsers::Username, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteUsers::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteUsers(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteUsers * SOAP_FMAC4 soap_in__tds__DeleteUsers(struct soap *soap, const char *tag, _tds__DeleteUsers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsers, sizeof(_tds__DeleteUsers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteUsers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteUsers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tds:Username", &a->_tds__DeleteUsers::Username, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__DeleteUsers::Username.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsers, SOAP_TYPE__tds__DeleteUsers, sizeof(_tds__DeleteUsers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteUsers * SOAP_FMAC2 soap_instantiate__tds__DeleteUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteUsers *p;
	size_t k = sizeof(_tds__DeleteUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteUsers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteUsers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteUsers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteUsers(soap, tag ? tag : "tds:DeleteUsers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteUsers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteUsers(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteUsers * SOAP_FMAC4 soap_get__tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateUsersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__CreateUsersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__CreateUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, const _tds__CreateUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateUsersResponse * SOAP_FMAC4 soap_in__tds__CreateUsersResponse(struct soap *soap, const char *tag, _tds__CreateUsersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(_tds__CreateUsersResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateUsersResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateUsersResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsersResponse, SOAP_TYPE__tds__CreateUsersResponse, sizeof(_tds__CreateUsersResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateUsersResponse * SOAP_FMAC2 soap_instantiate__tds__CreateUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateUsersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateUsersResponse *p;
	size_t k = sizeof(_tds__CreateUsersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateUsersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateUsersResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateUsersResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateUsersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateUsersResponse(soap, tag ? tag : "tds:CreateUsersResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateUsersResponse * SOAP_FMAC4 soap_get__tds__CreateUsersResponse(struct soap *soap, _tds__CreateUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateUsers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__CreateUsers::User);
}

void _tds__CreateUsers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__CreateUsers::User);
#endif
}

int _tds__CreateUsers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateUsers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsers(struct soap *soap, const char *tag, int id, const _tds__CreateUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsers), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__User(soap, "tds:User", -1, &a->_tds__CreateUsers::User, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateUsers::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateUsers(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateUsers * SOAP_FMAC4 soap_in__tds__CreateUsers(struct soap *soap, const char *tag, _tds__CreateUsers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsers, sizeof(_tds__CreateUsers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateUsers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateUsers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__User(soap, "tds:User", &a->_tds__CreateUsers::User, "tt:User"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__CreateUsers::User.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsers, SOAP_TYPE__tds__CreateUsers, sizeof(_tds__CreateUsers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateUsers * SOAP_FMAC2 soap_instantiate__tds__CreateUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateUsers *p;
	size_t k = sizeof(_tds__CreateUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateUsers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateUsers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateUsers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateUsers(soap, tag ? tag : "tds:CreateUsers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateUsers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateUsers(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateUsers * SOAP_FMAC4 soap_get__tds__CreateUsers(struct soap *soap, _tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetUsersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__GetUsersResponse::User);
}

void _tds__GetUsersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__GetUsersResponse::User);
#endif
}

int _tds__GetUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsersResponse(struct soap *soap, const char *tag, int id, const _tds__GetUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsersResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:User");
	if (soap_out_std__vectorTemplateOfPointerTott__User(soap, "tds:User", -1, &a->_tds__GetUsersResponse::User, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetUsersResponse * SOAP_FMAC4 soap_in__tds__GetUsersResponse(struct soap *soap, const char *tag, _tds__GetUsersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsersResponse, sizeof(_tds__GetUsersResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetUsersResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetUsersResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__User(soap, "tds:User", &a->_tds__GetUsersResponse::User, "tt:User"))
					continue;
			}
			soap_check_result(soap, "tds:User");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsersResponse, SOAP_TYPE__tds__GetUsersResponse, sizeof(_tds__GetUsersResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetUsersResponse * SOAP_FMAC2 soap_instantiate__tds__GetUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetUsersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetUsersResponse *p;
	size_t k = sizeof(_tds__GetUsersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetUsersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetUsersResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetUsersResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetUsersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetUsersResponse(soap, tag ? tag : "tds:GetUsersResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetUsersResponse * SOAP_FMAC4 soap_get__tds__GetUsersResponse(struct soap *soap, _tds__GetUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetUsers::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetUsers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetUsers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetUsers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsers(struct soap *soap, const char *tag, int id, const _tds__GetUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetUsers::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetUsers(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetUsers * SOAP_FMAC4 soap_in__tds__GetUsers(struct soap *soap, const char *tag, _tds__GetUsers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsers, sizeof(_tds__GetUsers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetUsers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetUsers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsers, SOAP_TYPE__tds__GetUsers, sizeof(_tds__GetUsers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetUsers * SOAP_FMAC2 soap_instantiate__tds__GetUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetUsers *p;
	size_t k = sizeof(_tds__GetUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetUsers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetUsers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetUsers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetUsers(soap, tag ? tag : "tds:GetUsers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetUsers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetUsers(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetUsers * SOAP_FMAC4 soap_get__tds__GetUsers(struct soap *soap, _tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRemoteUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetRemoteUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRemoteUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRemoteUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, int id, const _tds__SetRemoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRemoteUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRemoteUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, _tds__SetRemoteUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRemoteUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(_tds__SetRemoteUserResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRemoteUserResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRemoteUserResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUserResponse, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(_tds__SetRemoteUserResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRemoteUserResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRemoteUserResponse *p;
	size_t k = sizeof(_tds__SetRemoteUserResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRemoteUserResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRemoteUserResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRemoteUserResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRemoteUserResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRemoteUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRemoteUserResponse(soap, tag ? tag : "tds:SetRemoteUserResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRemoteUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRemoteUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__SetRemoteUserResponse(struct soap *soap, _tds__SetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRemoteUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetRemoteUser::RemoteUser = NULL;
}

void _tds__SetRemoteUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RemoteUser(soap, &this->_tds__SetRemoteUser::RemoteUser);
#endif
}

int _tds__SetRemoteUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRemoteUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const _tds__SetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUser), type))
		return soap->error;
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->_tds__SetRemoteUser::RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRemoteUser::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRemoteUser(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRemoteUser * SOAP_FMAC4 soap_in__tds__SetRemoteUser(struct soap *soap, const char *tag, _tds__SetRemoteUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUser, sizeof(_tds__SetRemoteUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRemoteUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRemoteUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RemoteUser1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->_tds__SetRemoteUser::RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUser, SOAP_TYPE__tds__SetRemoteUser, sizeof(_tds__SetRemoteUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRemoteUser *p;
	size_t k = sizeof(_tds__SetRemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRemoteUser);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRemoteUser, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRemoteUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRemoteUser(soap, tag ? tag : "tds:SetRemoteUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRemoteUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRemoteUser(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRemoteUser * SOAP_FMAC4 soap_get__tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRemoteUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetRemoteUserResponse::RemoteUser = NULL;
}

void _tds__GetRemoteUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RemoteUser(soap, &this->_tds__GetRemoteUserResponse::RemoteUser);
#endif
}

int _tds__GetRemoteUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRemoteUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, int id, const _tds__GetRemoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUserResponse), type))
		return soap->error;
	if (a->RemoteUser)
		soap_element_result(soap, "tds:RemoteUser");
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->_tds__GetRemoteUserResponse::RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRemoteUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRemoteUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, _tds__GetRemoteUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRemoteUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(_tds__GetRemoteUserResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRemoteUserResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRemoteUserResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RemoteUser1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->_tds__GetRemoteUserResponse::RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RemoteUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUserResponse, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(_tds__GetRemoteUserResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRemoteUserResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRemoteUserResponse *p;
	size_t k = sizeof(_tds__GetRemoteUserResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRemoteUserResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRemoteUserResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRemoteUserResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRemoteUserResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRemoteUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRemoteUserResponse(soap, tag ? tag : "tds:GetRemoteUserResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRemoteUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRemoteUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__GetRemoteUserResponse(struct soap *soap, _tds__GetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRemoteUser::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetRemoteUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetRemoteUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRemoteUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const _tds__GetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUser), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRemoteUser::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRemoteUser(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRemoteUser * SOAP_FMAC4 soap_in__tds__GetRemoteUser(struct soap *soap, const char *tag, _tds__GetRemoteUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUser, sizeof(_tds__GetRemoteUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRemoteUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRemoteUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUser, SOAP_TYPE__tds__GetRemoteUser, sizeof(_tds__GetRemoteUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRemoteUser *p;
	size_t k = sizeof(_tds__GetRemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRemoteUser);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRemoteUser, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRemoteUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRemoteUser(soap, tag ? tag : "tds:GetRemoteUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRemoteUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRemoteUser(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRemoteUser * SOAP_FMAC4 soap_get__tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetEndpointReferenceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_tds__GetEndpointReferenceResponse::GUID);
}

void _tds__GetEndpointReferenceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetEndpointReferenceResponse::GUID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetEndpointReferenceResponse::GUID);
#endif
}

int _tds__GetEndpointReferenceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetEndpointReferenceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, int id, const _tds__GetEndpointReferenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:GUID");
	if (soap_out_std__string(soap, "tds:GUID", -1, &a->_tds__GetEndpointReferenceResponse::GUID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetEndpointReferenceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetEndpointReferenceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_in__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, _tds__GetEndpointReferenceResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetEndpointReferenceResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(_tds__GetEndpointReferenceResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetEndpointReferenceResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetEndpointReferenceResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GUID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GUID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:GUID", &a->_tds__GetEndpointReferenceResponse::GUID, "xsd:string"))
				{	soap_flag_GUID1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:GUID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GUID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetEndpointReferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReferenceResponse, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(_tds__GetEndpointReferenceResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetEndpointReferenceResponse * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReferenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetEndpointReferenceResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetEndpointReferenceResponse *p;
	size_t k = sizeof(_tds__GetEndpointReferenceResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetEndpointReferenceResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetEndpointReferenceResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetEndpointReferenceResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetEndpointReferenceResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetEndpointReferenceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetEndpointReferenceResponse(soap, tag ? tag : "tds:GetEndpointReferenceResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetEndpointReferenceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetEndpointReferenceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_get__tds__GetEndpointReferenceResponse(struct soap *soap, _tds__GetEndpointReferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetEndpointReference::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetEndpointReference::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetEndpointReference::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetEndpointReference(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const _tds__GetEndpointReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetEndpointReference::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetEndpointReference(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetEndpointReference * SOAP_FMAC4 soap_in__tds__GetEndpointReference(struct soap *soap, const char *tag, _tds__GetEndpointReference *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetEndpointReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReference, sizeof(_tds__GetEndpointReference), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetEndpointReference)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetEndpointReference *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetEndpointReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReference, SOAP_TYPE__tds__GetEndpointReference, sizeof(_tds__GetEndpointReference), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetEndpointReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetEndpointReference *p;
	size_t k = sizeof(_tds__GetEndpointReference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetEndpointReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetEndpointReference);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetEndpointReference, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetEndpointReference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetEndpointReference::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetEndpointReference(soap, tag ? tag : "tds:GetEndpointReference", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetEndpointReference::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetEndpointReference(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetEndpointReference * SOAP_FMAC4 soap_get__tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDPAddressesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDPAddressesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDPAddressesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDPAddressesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, int id, const _tds__SetDPAddressesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddressesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDPAddressesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDPAddressesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, _tds__SetDPAddressesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDPAddressesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(_tds__SetDPAddressesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDPAddressesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDPAddressesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddressesResponse, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(_tds__SetDPAddressesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__SetDPAddressesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDPAddressesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDPAddressesResponse *p;
	size_t k = sizeof(_tds__SetDPAddressesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDPAddressesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDPAddressesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDPAddressesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDPAddressesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDPAddressesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDPAddressesResponse(soap, tag ? tag : "tds:SetDPAddressesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDPAddressesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDPAddressesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__SetDPAddressesResponse(struct soap *soap, _tds__SetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDPAddresses::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__SetDPAddresses::DPAddress);
}

void _tds__SetDPAddresses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__SetDPAddresses::DPAddress);
#endif
}

int _tds__SetDPAddresses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDPAddresses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const _tds__SetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddresses), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:DPAddress", -1, &a->_tds__SetDPAddresses::DPAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDPAddresses::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDPAddresses(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDPAddresses * SOAP_FMAC4 soap_in__tds__SetDPAddresses(struct soap *soap, const char *tag, _tds__SetDPAddresses *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDPAddresses*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddresses, sizeof(_tds__SetDPAddresses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDPAddresses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDPAddresses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:DPAddress", &a->_tds__SetDPAddresses::DPAddress, "tt:NetworkHost"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddresses, SOAP_TYPE__tds__SetDPAddresses, sizeof(_tds__SetDPAddresses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__SetDPAddresses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDPAddresses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDPAddresses *p;
	size_t k = sizeof(_tds__SetDPAddresses);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDPAddresses, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDPAddresses);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDPAddresses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDPAddresses location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDPAddresses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDPAddresses(soap, tag ? tag : "tds:SetDPAddresses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDPAddresses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDPAddresses(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDPAddresses * SOAP_FMAC4 soap_get__tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDPAddressesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__GetDPAddressesResponse::DPAddress);
}

void _tds__GetDPAddressesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__GetDPAddressesResponse::DPAddress);
#endif
}

int _tds__GetDPAddressesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDPAddressesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, int id, const _tds__GetDPAddressesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddressesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:DPAddress");
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:DPAddress", -1, &a->_tds__GetDPAddressesResponse::DPAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDPAddressesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDPAddressesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, _tds__GetDPAddressesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDPAddressesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(_tds__GetDPAddressesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDPAddressesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDPAddressesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:DPAddress", &a->_tds__GetDPAddressesResponse::DPAddress, "tt:NetworkHost"))
					continue;
			}
			soap_check_result(soap, "tds:DPAddress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddressesResponse, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(_tds__GetDPAddressesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDPAddressesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDPAddressesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDPAddressesResponse *p;
	size_t k = sizeof(_tds__GetDPAddressesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDPAddressesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDPAddressesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDPAddressesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDPAddressesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDPAddressesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDPAddressesResponse(soap, tag ? tag : "tds:GetDPAddressesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDPAddressesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDPAddressesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__GetDPAddressesResponse(struct soap *soap, _tds__GetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDPAddresses::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDPAddresses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDPAddresses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDPAddresses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const _tds__GetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddresses), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDPAddresses::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDPAddresses(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDPAddresses * SOAP_FMAC4 soap_in__tds__GetDPAddresses(struct soap *soap, const char *tag, _tds__GetDPAddresses *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDPAddresses*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddresses, sizeof(_tds__GetDPAddresses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDPAddresses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDPAddresses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddresses, SOAP_TYPE__tds__GetDPAddresses, sizeof(_tds__GetDPAddresses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__GetDPAddresses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDPAddresses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDPAddresses *p;
	size_t k = sizeof(_tds__GetDPAddresses);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDPAddresses, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDPAddresses);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDPAddresses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDPAddresses location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDPAddresses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDPAddresses(soap, tag ? tag : "tds:GetDPAddresses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDPAddresses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDPAddresses(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDPAddresses * SOAP_FMAC4 soap_get__tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRemoteDiscoveryModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetRemoteDiscoveryModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRemoteDiscoveryModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRemoteDiscoveryModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRemoteDiscoveryModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRemoteDiscoveryModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRemoteDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(_tds__SetRemoteDiscoveryModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRemoteDiscoveryModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(_tds__SetRemoteDiscoveryModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRemoteDiscoveryModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRemoteDiscoveryModeResponse *p;
	size_t k = sizeof(_tds__SetRemoteDiscoveryModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRemoteDiscoveryModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRemoteDiscoveryModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRemoteDiscoveryModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRemoteDiscoveryModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRemoteDiscoveryModeResponse(soap, tag ? tag : "tds:SetRemoteDiscoveryModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRemoteDiscoveryModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRemoteDiscoveryModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, _tds__SetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRemoteDiscoveryMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DiscoveryMode(soap, &this->_tds__SetRemoteDiscoveryMode::RemoteDiscoveryMode);
}

void _tds__SetRemoteDiscoveryMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRemoteDiscoveryMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRemoteDiscoveryMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->_tds__SetRemoteDiscoveryMode::RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRemoteDiscoveryMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRemoteDiscoveryMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRemoteDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(_tds__SetRemoteDiscoveryMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRemoteDiscoveryMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRemoteDiscoveryMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RemoteDiscoveryMode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->_tds__SetRemoteDiscoveryMode::RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryMode, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(_tds__SetRemoteDiscoveryMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRemoteDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRemoteDiscoveryMode *p;
	size_t k = sizeof(_tds__SetRemoteDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRemoteDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRemoteDiscoveryMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRemoteDiscoveryMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRemoteDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRemoteDiscoveryMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRemoteDiscoveryMode(soap, tag ? tag : "tds:SetRemoteDiscoveryMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRemoteDiscoveryMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRemoteDiscoveryMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRemoteDiscoveryModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DiscoveryMode(soap, &this->_tds__GetRemoteDiscoveryModeResponse::RemoteDiscoveryMode);
}

void _tds__GetRemoteDiscoveryModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetRemoteDiscoveryModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRemoteDiscoveryModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RemoteDiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->_tds__GetRemoteDiscoveryModeResponse::RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRemoteDiscoveryModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRemoteDiscoveryModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRemoteDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(_tds__GetRemoteDiscoveryModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRemoteDiscoveryModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RemoteDiscoveryMode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->_tds__GetRemoteDiscoveryModeResponse::RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RemoteDiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(_tds__GetRemoteDiscoveryModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRemoteDiscoveryModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRemoteDiscoveryModeResponse *p;
	size_t k = sizeof(_tds__GetRemoteDiscoveryModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRemoteDiscoveryModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRemoteDiscoveryModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRemoteDiscoveryModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRemoteDiscoveryModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRemoteDiscoveryModeResponse(soap, tag ? tag : "tds:GetRemoteDiscoveryModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRemoteDiscoveryModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRemoteDiscoveryModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, _tds__GetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRemoteDiscoveryMode::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetRemoteDiscoveryMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetRemoteDiscoveryMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRemoteDiscoveryMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRemoteDiscoveryMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRemoteDiscoveryMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRemoteDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(_tds__GetRemoteDiscoveryMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRemoteDiscoveryMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRemoteDiscoveryMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryMode, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(_tds__GetRemoteDiscoveryMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRemoteDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRemoteDiscoveryMode *p;
	size_t k = sizeof(_tds__GetRemoteDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRemoteDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRemoteDiscoveryMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRemoteDiscoveryMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRemoteDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRemoteDiscoveryMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRemoteDiscoveryMode(soap, tag ? tag : "tds:GetRemoteDiscoveryMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRemoteDiscoveryMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRemoteDiscoveryMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDiscoveryModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDiscoveryModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDiscoveryModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDiscoveryModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const _tds__SetDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDiscoveryModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDiscoveryModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__SetDiscoveryModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(_tds__SetDiscoveryModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDiscoveryModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDiscoveryModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryModeResponse, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(_tds__SetDiscoveryModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDiscoveryModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDiscoveryModeResponse *p;
	size_t k = sizeof(_tds__SetDiscoveryModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDiscoveryModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDiscoveryModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDiscoveryModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDiscoveryModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDiscoveryModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDiscoveryModeResponse(soap, tag ? tag : "tds:SetDiscoveryModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDiscoveryModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDiscoveryModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetDiscoveryModeResponse(struct soap *soap, _tds__SetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDiscoveryMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DiscoveryMode(soap, &this->_tds__SetDiscoveryMode::DiscoveryMode);
}

void _tds__SetDiscoveryMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDiscoveryMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDiscoveryMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const _tds__SetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->_tds__SetDiscoveryMode::DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDiscoveryMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDiscoveryMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetDiscoveryMode(struct soap *soap, const char *tag, _tds__SetDiscoveryMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(_tds__SetDiscoveryMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDiscoveryMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDiscoveryMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DiscoveryMode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->_tds__SetDiscoveryMode::DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryMode, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(_tds__SetDiscoveryMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDiscoveryMode *p;
	size_t k = sizeof(_tds__SetDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDiscoveryMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDiscoveryMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDiscoveryMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDiscoveryMode(soap, tag ? tag : "tds:SetDiscoveryMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDiscoveryMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDiscoveryMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDiscoveryModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DiscoveryMode(soap, &this->_tds__GetDiscoveryModeResponse::DiscoveryMode);
}

void _tds__GetDiscoveryModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDiscoveryModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDiscoveryModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const _tds__GetDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:DiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->_tds__GetDiscoveryModeResponse::DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDiscoveryModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDiscoveryModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__GetDiscoveryModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(_tds__GetDiscoveryModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDiscoveryModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDiscoveryModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DiscoveryMode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->_tds__GetDiscoveryModeResponse::DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryModeResponse, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(_tds__GetDiscoveryModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDiscoveryModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDiscoveryModeResponse *p;
	size_t k = sizeof(_tds__GetDiscoveryModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDiscoveryModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDiscoveryModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDiscoveryModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDiscoveryModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDiscoveryModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDiscoveryModeResponse(soap, tag ? tag : "tds:GetDiscoveryModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDiscoveryModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDiscoveryModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetDiscoveryModeResponse(struct soap *soap, _tds__GetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDiscoveryMode::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDiscoveryMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDiscoveryMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDiscoveryMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const _tds__GetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDiscoveryMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDiscoveryMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetDiscoveryMode(struct soap *soap, const char *tag, _tds__GetDiscoveryMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(_tds__GetDiscoveryMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDiscoveryMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDiscoveryMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryMode, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(_tds__GetDiscoveryMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDiscoveryMode *p;
	size_t k = sizeof(_tds__GetDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDiscoveryMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDiscoveryMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDiscoveryMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDiscoveryMode(soap, tag ? tag : "tds:GetDiscoveryMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDiscoveryMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDiscoveryMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RemoveScopesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__RemoveScopesResponse::ScopeItem);
}

void _tds__RemoveScopesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__RemoveScopesResponse::ScopeItem);
#endif
}

int _tds__RemoveScopesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveScopesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopesResponse(struct soap *soap, const char *tag, int id, const _tds__RemoveScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:ScopeItem");
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", -1, &a->_tds__RemoveScopesResponse::ScopeItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveScopesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RemoveScopesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveScopesResponse * SOAP_FMAC4 soap_in__tds__RemoveScopesResponse(struct soap *soap, const char *tag, _tds__RemoveScopesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(_tds__RemoveScopesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RemoveScopesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RemoveScopesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", &a->_tds__RemoveScopesResponse::ScopeItem, "xsd:anyURI"))
					continue;
			}
			soap_check_result(soap, "tds:ScopeItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__RemoveScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopesResponse, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(_tds__RemoveScopesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveScopesResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveScopesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveScopesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RemoveScopesResponse *p;
	size_t k = sizeof(_tds__RemoveScopesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RemoveScopesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RemoveScopesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RemoveScopesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RemoveScopesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RemoveScopesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RemoveScopesResponse(soap, tag ? tag : "tds:RemoveScopesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveScopesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveScopesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveScopesResponse * SOAP_FMAC4 soap_get__tds__RemoveScopesResponse(struct soap *soap, _tds__RemoveScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RemoveScopes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__RemoveScopes::ScopeItem);
}

void _tds__RemoveScopes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__RemoveScopes::ScopeItem);
#endif
}

int _tds__RemoveScopes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveScopes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopes(struct soap *soap, const char *tag, int id, const _tds__RemoveScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", -1, &a->_tds__RemoveScopes::ScopeItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveScopes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RemoveScopes(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveScopes * SOAP_FMAC4 soap_in__tds__RemoveScopes(struct soap *soap, const char *tag, _tds__RemoveScopes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopes, sizeof(_tds__RemoveScopes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RemoveScopes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RemoveScopes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", &a->_tds__RemoveScopes::ScopeItem, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__RemoveScopes::ScopeItem.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__RemoveScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopes, SOAP_TYPE__tds__RemoveScopes, sizeof(_tds__RemoveScopes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveScopes * SOAP_FMAC2 soap_instantiate__tds__RemoveScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RemoveScopes *p;
	size_t k = sizeof(_tds__RemoveScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RemoveScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RemoveScopes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RemoveScopes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RemoveScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RemoveScopes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RemoveScopes(soap, tag ? tag : "tds:RemoveScopes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveScopes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveScopes(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveScopes * SOAP_FMAC4 soap_get__tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__AddScopesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__AddScopesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__AddScopesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddScopesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopesResponse(struct soap *soap, const char *tag, int id, const _tds__AddScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__AddScopesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__AddScopesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddScopesResponse * SOAP_FMAC4 soap_in__tds__AddScopesResponse(struct soap *soap, const char *tag, _tds__AddScopesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopesResponse, sizeof(_tds__AddScopesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__AddScopesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__AddScopesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__AddScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopesResponse, SOAP_TYPE__tds__AddScopesResponse, sizeof(_tds__AddScopesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddScopesResponse * SOAP_FMAC2 soap_instantiate__tds__AddScopesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddScopesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__AddScopesResponse *p;
	size_t k = sizeof(_tds__AddScopesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__AddScopesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__AddScopesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__AddScopesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__AddScopesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__AddScopesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__AddScopesResponse(soap, tag ? tag : "tds:AddScopesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddScopesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddScopesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddScopesResponse * SOAP_FMAC4 soap_get__tds__AddScopesResponse(struct soap *soap, _tds__AddScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__AddScopes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__AddScopes::ScopeItem);
}

void _tds__AddScopes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__AddScopes::ScopeItem);
#endif
}

int _tds__AddScopes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddScopes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopes(struct soap *soap, const char *tag, int id, const _tds__AddScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", -1, &a->_tds__AddScopes::ScopeItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__AddScopes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__AddScopes(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddScopes * SOAP_FMAC4 soap_in__tds__AddScopes(struct soap *soap, const char *tag, _tds__AddScopes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopes, sizeof(_tds__AddScopes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__AddScopes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__AddScopes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", &a->_tds__AddScopes::ScopeItem, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__AddScopes::ScopeItem.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__AddScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopes, SOAP_TYPE__tds__AddScopes, sizeof(_tds__AddScopes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddScopes * SOAP_FMAC2 soap_instantiate__tds__AddScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__AddScopes *p;
	size_t k = sizeof(_tds__AddScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__AddScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__AddScopes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__AddScopes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__AddScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__AddScopes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__AddScopes(soap, tag ? tag : "tds:AddScopes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddScopes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddScopes(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddScopes * SOAP_FMAC4 soap_get__tds__AddScopes(struct soap *soap, _tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetScopesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetScopesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetScopesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetScopesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopesResponse(struct soap *soap, const char *tag, int id, const _tds__SetScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetScopesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetScopesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetScopesResponse * SOAP_FMAC4 soap_in__tds__SetScopesResponse(struct soap *soap, const char *tag, _tds__SetScopesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopesResponse, sizeof(_tds__SetScopesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetScopesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetScopesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopesResponse, SOAP_TYPE__tds__SetScopesResponse, sizeof(_tds__SetScopesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__SetScopesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetScopesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetScopesResponse *p;
	size_t k = sizeof(_tds__SetScopesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetScopesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetScopesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetScopesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetScopesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetScopesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetScopesResponse(soap, tag ? tag : "tds:SetScopesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetScopesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetScopesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetScopesResponse * SOAP_FMAC4 soap_get__tds__SetScopesResponse(struct soap *soap, _tds__SetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetScopes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__SetScopes::Scopes);
}

void _tds__SetScopes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__SetScopes::Scopes);
#endif
}

int _tds__SetScopes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetScopes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopes(struct soap *soap, const char *tag, int id, const _tds__SetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tds:Scopes", -1, &a->_tds__SetScopes::Scopes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetScopes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetScopes(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetScopes * SOAP_FMAC4 soap_in__tds__SetScopes(struct soap *soap, const char *tag, _tds__SetScopes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopes, sizeof(_tds__SetScopes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetScopes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetScopes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tds:Scopes", &a->_tds__SetScopes::Scopes, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__SetScopes::Scopes.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopes, SOAP_TYPE__tds__SetScopes, sizeof(_tds__SetScopes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetScopes * SOAP_FMAC2 soap_instantiate__tds__SetScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetScopes *p;
	size_t k = sizeof(_tds__SetScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetScopes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetScopes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetScopes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetScopes(soap, tag ? tag : "tds:SetScopes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetScopes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetScopes(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetScopes * SOAP_FMAC4 soap_get__tds__SetScopes(struct soap *soap, _tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetScopesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Scope(soap, &this->_tds__GetScopesResponse::Scopes);
}

void _tds__GetScopesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Scope(soap, &this->_tds__GetScopesResponse::Scopes);
#endif
}

int _tds__GetScopesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetScopesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopesResponse(struct soap *soap, const char *tag, int id, const _tds__GetScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Scopes");
	if (soap_out_std__vectorTemplateOfPointerTott__Scope(soap, "tds:Scopes", -1, &a->_tds__GetScopesResponse::Scopes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetScopesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetScopesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetScopesResponse * SOAP_FMAC4 soap_in__tds__GetScopesResponse(struct soap *soap, const char *tag, _tds__GetScopesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopesResponse, sizeof(_tds__GetScopesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetScopesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetScopesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Scope(soap, "tds:Scopes", &a->_tds__GetScopesResponse::Scopes, "tt:Scope"))
					continue;
			}
			soap_check_result(soap, "tds:Scopes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__GetScopesResponse::Scopes.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopesResponse, SOAP_TYPE__tds__GetScopesResponse, sizeof(_tds__GetScopesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__GetScopesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetScopesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetScopesResponse *p;
	size_t k = sizeof(_tds__GetScopesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetScopesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetScopesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetScopesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetScopesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetScopesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetScopesResponse(soap, tag ? tag : "tds:GetScopesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetScopesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetScopesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetScopesResponse * SOAP_FMAC4 soap_get__tds__GetScopesResponse(struct soap *soap, _tds__GetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetScopes::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetScopes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetScopes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetScopes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopes(struct soap *soap, const char *tag, int id, const _tds__GetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetScopes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetScopes(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetScopes * SOAP_FMAC4 soap_in__tds__GetScopes(struct soap *soap, const char *tag, _tds__GetScopes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopes, sizeof(_tds__GetScopes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetScopes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetScopes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopes, SOAP_TYPE__tds__GetScopes, sizeof(_tds__GetScopes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetScopes * SOAP_FMAC2 soap_instantiate__tds__GetScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetScopes *p;
	size_t k = sizeof(_tds__GetScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetScopes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetScopes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetScopes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetScopes(soap, tag ? tag : "tds:GetScopes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetScopes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetScopes(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetScopes * SOAP_FMAC4 soap_get__tds__GetScopes(struct soap *soap, _tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemLogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetSystemLogResponse::SystemLog = NULL;
}

void _tds__GetSystemLogResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemLog(soap, &this->_tds__GetSystemLogResponse::SystemLog);
#endif
}

int _tds__GetSystemLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLogResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLogResponse), type))
		return soap->error;
	if (a->SystemLog)
		soap_element_result(soap, "tds:SystemLog");
	if (!a->_tds__GetSystemLogResponse::SystemLog)
	{	if (soap_element_empty(soap, "tds:SystemLog", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SystemLog(soap, "tds:SystemLog", -1, &a->_tds__GetSystemLogResponse::SystemLog, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemLogResponse * SOAP_FMAC4 soap_in__tds__GetSystemLogResponse(struct soap *soap, const char *tag, _tds__GetSystemLogResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemLogResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(_tds__GetSystemLogResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemLogResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemLogResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SystemLog1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLog1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemLog(soap, "tds:SystemLog", &a->_tds__GetSystemLogResponse::SystemLog, "tt:SystemLog"))
				{	soap_flag_SystemLog1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemLog");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetSystemLogResponse::SystemLog))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetSystemLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLogResponse, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(_tds__GetSystemLogResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemLogResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemLogResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemLogResponse *p;
	size_t k = sizeof(_tds__GetSystemLogResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemLogResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemLogResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemLogResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemLogResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemLogResponse(soap, tag ? tag : "tds:GetSystemLogResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemLogResponse * SOAP_FMAC4 soap_get__tds__GetSystemLogResponse(struct soap *soap, _tds__GetSystemLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__SystemLogType(soap, &this->_tds__GetSystemLog::LogType);
}

void _tds__GetSystemLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLog(struct soap *soap, const char *tag, int id, const _tds__GetSystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLog), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tds:LogType", -1, &a->_tds__GetSystemLog::LogType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemLog::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemLog(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemLog * SOAP_FMAC4 soap_in__tds__GetSystemLog(struct soap *soap, const char *tag, _tds__GetSystemLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemLog*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLog, sizeof(_tds__GetSystemLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemLog)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemLog *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LogType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LogType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SystemLogType(soap, "tds:LogType", &a->_tds__GetSystemLog::LogType, "tt:SystemLogType"))
				{	soap_flag_LogType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LogType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetSystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLog, SOAP_TYPE__tds__GetSystemLog, sizeof(_tds__GetSystemLog), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemLog * SOAP_FMAC2 soap_instantiate__tds__GetSystemLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemLog *p;
	size_t k = sizeof(_tds__GetSystemLog);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemLog, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemLog);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemLog, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemLog location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemLog(soap, tag ? tag : "tds:GetSystemLog", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemLog(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemLog * SOAP_FMAC4 soap_get__tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemSupportInformationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetSystemSupportInformationResponse::SupportInformation = NULL;
}

void _tds__GetSystemSupportInformationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SupportInformation(soap, &this->_tds__GetSystemSupportInformationResponse::SupportInformation);
#endif
}

int _tds__GetSystemSupportInformationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemSupportInformationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse), type))
		return soap->error;
	if (a->SupportInformation)
		soap_element_result(soap, "tds:SupportInformation");
	if (!a->_tds__GetSystemSupportInformationResponse::SupportInformation)
	{	if (soap_element_empty(soap, "tds:SupportInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SupportInformation(soap, "tds:SupportInformation", -1, &a->_tds__GetSystemSupportInformationResponse::SupportInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemSupportInformationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemSupportInformationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemSupportInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(_tds__GetSystemSupportInformationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemSupportInformationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemSupportInformationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SupportInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SupportInformation(soap, "tds:SupportInformation", &a->_tds__GetSystemSupportInformationResponse::SupportInformation, "tt:SupportInformation"))
				{	soap_flag_SupportInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SupportInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetSystemSupportInformationResponse::SupportInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetSystemSupportInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformationResponse, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(_tds__GetSystemSupportInformationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemSupportInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemSupportInformationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemSupportInformationResponse *p;
	size_t k = sizeof(_tds__GetSystemSupportInformationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemSupportInformationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemSupportInformationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemSupportInformationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemSupportInformationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemSupportInformationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemSupportInformationResponse(soap, tag ? tag : "tds:GetSystemSupportInformationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemSupportInformationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemSupportInformationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformationResponse(struct soap *soap, _tds__GetSystemSupportInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemSupportInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetSystemSupportInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemSupportInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemSupportInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const _tds__GetSystemSupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemSupportInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemSupportInformation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, _tds__GetSystemSupportInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemSupportInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(_tds__GetSystemSupportInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemSupportInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemSupportInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemSupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformation, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(_tds__GetSystemSupportInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemSupportInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemSupportInformation *p;
	size_t k = sizeof(_tds__GetSystemSupportInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemSupportInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemSupportInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemSupportInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemSupportInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemSupportInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemSupportInformation(soap, tag ? tag : "tds:GetSystemSupportInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemSupportInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemSupportInformation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemBackupResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__BackupFile(soap, &this->_tds__GetSystemBackupResponse::BackupFiles);
}

void _tds__GetSystemBackupResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__BackupFile(soap, &this->_tds__GetSystemBackupResponse::BackupFiles);
#endif
}

int _tds__GetSystemBackupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemBackupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemBackupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackupResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:BackupFiles");
	if (soap_out_std__vectorTemplateOfPointerTott__BackupFile(soap, "tds:BackupFiles", -1, &a->_tds__GetSystemBackupResponse::BackupFiles, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemBackupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemBackupResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_in__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, _tds__GetSystemBackupResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemBackupResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(_tds__GetSystemBackupResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemBackupResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemBackupResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__BackupFile(soap, "tds:BackupFiles", &a->_tds__GetSystemBackupResponse::BackupFiles, "tt:BackupFile"))
					continue;
			}
			soap_check_result(soap, "tds:BackupFiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__GetSystemBackupResponse::BackupFiles.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetSystemBackupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackupResponse, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(_tds__GetSystemBackupResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemBackupResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemBackupResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemBackupResponse *p;
	size_t k = sizeof(_tds__GetSystemBackupResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemBackupResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemBackupResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemBackupResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemBackupResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemBackupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemBackupResponse(soap, tag ? tag : "tds:GetSystemBackupResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemBackupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemBackupResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_get__tds__GetSystemBackupResponse(struct soap *soap, _tds__GetSystemBackupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemBackup::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetSystemBackup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemBackup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemBackup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const _tds__GetSystemBackup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackup), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemBackup::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemBackup(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemBackup * SOAP_FMAC4 soap_in__tds__GetSystemBackup(struct soap *soap, const char *tag, _tds__GetSystemBackup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemBackup*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackup, sizeof(_tds__GetSystemBackup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemBackup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemBackup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemBackup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackup, SOAP_TYPE__tds__GetSystemBackup, sizeof(_tds__GetSystemBackup), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemBackup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemBackup *p;
	size_t k = sizeof(_tds__GetSystemBackup);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemBackup, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemBackup);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemBackup, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemBackup location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemBackup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemBackup(soap, tag ? tag : "tds:GetSystemBackup", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemBackup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemBackup(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemBackup * SOAP_FMAC4 soap_get__tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RestoreSystemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__RestoreSystemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__RestoreSystemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RestoreSystemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RestoreSystemResponse(struct soap *soap, const char *tag, int id, const _tds__RestoreSystemResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RestoreSystemResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RestoreSystemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RestoreSystemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RestoreSystemResponse * SOAP_FMAC4 soap_in__tds__RestoreSystemResponse(struct soap *soap, const char *tag, _tds__RestoreSystemResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RestoreSystemResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(_tds__RestoreSystemResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RestoreSystemResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RestoreSystemResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__RestoreSystemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystemResponse, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(_tds__RestoreSystemResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RestoreSystemResponse * SOAP_FMAC2 soap_instantiate__tds__RestoreSystemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RestoreSystemResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RestoreSystemResponse *p;
	size_t k = sizeof(_tds__RestoreSystemResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RestoreSystemResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RestoreSystemResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RestoreSystemResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RestoreSystemResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RestoreSystemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RestoreSystemResponse(soap, tag ? tag : "tds:RestoreSystemResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RestoreSystemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RestoreSystemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RestoreSystemResponse * SOAP_FMAC4 soap_get__tds__RestoreSystemResponse(struct soap *soap, _tds__RestoreSystemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RestoreSystemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RestoreSystem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__BackupFile(soap, &this->_tds__RestoreSystem::BackupFiles);
}

void _tds__RestoreSystem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__BackupFile(soap, &this->_tds__RestoreSystem::BackupFiles);
#endif
}

int _tds__RestoreSystem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RestoreSystem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RestoreSystem(struct soap *soap, const char *tag, int id, const _tds__RestoreSystem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RestoreSystem), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__BackupFile(soap, "tds:BackupFiles", -1, &a->_tds__RestoreSystem::BackupFiles, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RestoreSystem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RestoreSystem(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RestoreSystem * SOAP_FMAC4 soap_in__tds__RestoreSystem(struct soap *soap, const char *tag, _tds__RestoreSystem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RestoreSystem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystem, sizeof(_tds__RestoreSystem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RestoreSystem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RestoreSystem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__BackupFile(soap, "tds:BackupFiles", &a->_tds__RestoreSystem::BackupFiles, "tt:BackupFile"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__RestoreSystem::BackupFiles.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__RestoreSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystem, SOAP_TYPE__tds__RestoreSystem, sizeof(_tds__RestoreSystem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RestoreSystem * SOAP_FMAC2 soap_instantiate__tds__RestoreSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RestoreSystem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RestoreSystem *p;
	size_t k = sizeof(_tds__RestoreSystem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RestoreSystem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RestoreSystem);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RestoreSystem, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RestoreSystem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RestoreSystem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RestoreSystem(soap, tag ? tag : "tds:RestoreSystem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RestoreSystem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RestoreSystem(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RestoreSystem * SOAP_FMAC4 soap_get__tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SystemRebootResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_tds__SystemRebootResponse::Message);
}

void _tds__SystemRebootResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SystemRebootResponse::Message, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__SystemRebootResponse::Message);
#endif
}

int _tds__SystemRebootResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SystemRebootResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, const _tds__SystemRebootResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemRebootResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Message");
	if (soap_out_std__string(soap, "tds:Message", -1, &a->_tds__SystemRebootResponse::Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SystemRebootResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SystemRebootResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SystemRebootResponse * SOAP_FMAC4 soap_in__tds__SystemRebootResponse(struct soap *soap, const char *tag, _tds__SystemRebootResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SystemRebootResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(_tds__SystemRebootResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SystemRebootResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SystemRebootResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:Message", &a->_tds__SystemRebootResponse::Message, "xsd:string"))
				{	soap_flag_Message1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SystemRebootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemRebootResponse, SOAP_TYPE__tds__SystemRebootResponse, sizeof(_tds__SystemRebootResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SystemRebootResponse * SOAP_FMAC2 soap_instantiate__tds__SystemRebootResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SystemRebootResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SystemRebootResponse *p;
	size_t k = sizeof(_tds__SystemRebootResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SystemRebootResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SystemRebootResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SystemRebootResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SystemRebootResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SystemRebootResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SystemRebootResponse(soap, tag ? tag : "tds:SystemRebootResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SystemRebootResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SystemRebootResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SystemRebootResponse * SOAP_FMAC4 soap_get__tds__SystemRebootResponse(struct soap *soap, _tds__SystemRebootResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SystemReboot::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SystemReboot::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SystemReboot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SystemReboot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemReboot(struct soap *soap, const char *tag, int id, const _tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemReboot), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SystemReboot::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SystemReboot(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SystemReboot * SOAP_FMAC4 soap_in__tds__SystemReboot(struct soap *soap, const char *tag, _tds__SystemReboot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SystemReboot*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemReboot, sizeof(_tds__SystemReboot), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SystemReboot)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SystemReboot *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SystemReboot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemReboot, SOAP_TYPE__tds__SystemReboot, sizeof(_tds__SystemReboot), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SystemReboot * SOAP_FMAC2 soap_instantiate__tds__SystemReboot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SystemReboot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SystemReboot *p;
	size_t k = sizeof(_tds__SystemReboot);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SystemReboot, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SystemReboot);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SystemReboot, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SystemReboot location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SystemReboot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SystemReboot(soap, tag ? tag : "tds:SystemReboot", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SystemReboot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SystemReboot(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SystemReboot * SOAP_FMAC4 soap_get__tds__SystemReboot(struct soap *soap, _tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__UpgradeSystemFirmwareResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__UpgradeSystemFirmwareResponse::Message = NULL;
}

void _tds__UpgradeSystemFirmwareResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tds__UpgradeSystemFirmwareResponse::Message);
#endif
}

int _tds__UpgradeSystemFirmwareResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__UpgradeSystemFirmwareResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, int id, const _tds__UpgradeSystemFirmwareResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse), type))
		return soap->error;
	if (a->Message)
		soap_element_result(soap, "tds:Message");
	if (soap_out_PointerTostd__string(soap, "tds:Message", -1, &a->_tds__UpgradeSystemFirmwareResponse::Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__UpgradeSystemFirmwareResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__UpgradeSystemFirmwareResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_in__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, _tds__UpgradeSystemFirmwareResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__UpgradeSystemFirmwareResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(_tds__UpgradeSystemFirmwareResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__UpgradeSystemFirmwareResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__UpgradeSystemFirmwareResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tds:Message", &a->_tds__UpgradeSystemFirmwareResponse::Message, "xsd:string"))
				{	soap_flag_Message1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__UpgradeSystemFirmwareResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(_tds__UpgradeSystemFirmwareResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmwareResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__UpgradeSystemFirmwareResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__UpgradeSystemFirmwareResponse *p;
	size_t k = sizeof(_tds__UpgradeSystemFirmwareResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__UpgradeSystemFirmwareResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__UpgradeSystemFirmwareResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__UpgradeSystemFirmwareResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__UpgradeSystemFirmwareResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__UpgradeSystemFirmwareResponse(soap, tag ? tag : "tds:UpgradeSystemFirmwareResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__UpgradeSystemFirmwareResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__UpgradeSystemFirmwareResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_get__tds__UpgradeSystemFirmwareResponse(struct soap *soap, _tds__UpgradeSystemFirmwareResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UpgradeSystemFirmwareResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__UpgradeSystemFirmware::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__UpgradeSystemFirmware::Firmware = NULL;
}

void _tds__UpgradeSystemFirmware::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &this->_tds__UpgradeSystemFirmware::Firmware);
#endif
}

int _tds__UpgradeSystemFirmware::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__UpgradeSystemFirmware(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, const _tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UpgradeSystemFirmware), type))
		return soap->error;
	if (!a->_tds__UpgradeSystemFirmware::Firmware)
	{	if (soap_element_empty(soap, "tds:Firmware", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AttachmentData(soap, "tds:Firmware", -1, &a->_tds__UpgradeSystemFirmware::Firmware, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__UpgradeSystemFirmware::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__UpgradeSystemFirmware(soap, tag, this, type);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_in__tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, _tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__UpgradeSystemFirmware*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(_tds__UpgradeSystemFirmware), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__UpgradeSystemFirmware)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__UpgradeSystemFirmware *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Firmware1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Firmware1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tds:Firmware", &a->_tds__UpgradeSystemFirmware::Firmware, "tt:AttachmentData"))
				{	soap_flag_Firmware1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__UpgradeSystemFirmware::Firmware))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__UpgradeSystemFirmware *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmware, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(_tds__UpgradeSystemFirmware), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmware(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__UpgradeSystemFirmware(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__UpgradeSystemFirmware *p;
	size_t k = sizeof(_tds__UpgradeSystemFirmware);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__UpgradeSystemFirmware, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__UpgradeSystemFirmware);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__UpgradeSystemFirmware, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__UpgradeSystemFirmware location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__UpgradeSystemFirmware::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__UpgradeSystemFirmware(soap, tag ? tag : "tds:UpgradeSystemFirmware", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__UpgradeSystemFirmware::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__UpgradeSystemFirmware(soap, this, tag, type);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_get__tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetSystemFactoryDefaultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetSystemFactoryDefaultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetSystemFactoryDefaultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, const _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetSystemFactoryDefaultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetSystemFactoryDefaultResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(_tds__SetSystemFactoryDefaultResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetSystemFactoryDefaultResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetSystemFactoryDefaultResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetSystemFactoryDefaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(_tds__SetSystemFactoryDefaultResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefaultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetSystemFactoryDefaultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetSystemFactoryDefaultResponse *p;
	size_t k = sizeof(_tds__SetSystemFactoryDefaultResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetSystemFactoryDefaultResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetSystemFactoryDefaultResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetSystemFactoryDefaultResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetSystemFactoryDefaultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag ? tag : "tds:SetSystemFactoryDefaultResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetSystemFactoryDefaultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetSystemFactoryDefaultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefaultResponse(struct soap *soap, _tds__SetSystemFactoryDefaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetSystemFactoryDefault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__FactoryDefaultType(soap, &this->_tds__SetSystemFactoryDefault::FactoryDefault);
}

void _tds__SetSystemFactoryDefault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetSystemFactoryDefault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetSystemFactoryDefault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const _tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefault), type))
		return soap->error;
	if (soap_out_tt__FactoryDefaultType(soap, "tds:FactoryDefault", -1, &a->_tds__SetSystemFactoryDefault::FactoryDefault, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetSystemFactoryDefault::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetSystemFactoryDefault(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, _tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetSystemFactoryDefault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(_tds__SetSystemFactoryDefault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetSystemFactoryDefault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetSystemFactoryDefault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FactoryDefault1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FactoryDefault1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__FactoryDefaultType(soap, "tds:FactoryDefault", &a->_tds__SetSystemFactoryDefault::FactoryDefault, "tt:FactoryDefaultType"))
				{	soap_flag_FactoryDefault1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FactoryDefault1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetSystemFactoryDefault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefault, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(_tds__SetSystemFactoryDefault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetSystemFactoryDefault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetSystemFactoryDefault *p;
	size_t k = sizeof(_tds__SetSystemFactoryDefault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetSystemFactoryDefault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetSystemFactoryDefault);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetSystemFactoryDefault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetSystemFactoryDefault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetSystemFactoryDefault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetSystemFactoryDefault(soap, tag ? tag : "tds:SetSystemFactoryDefault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetSystemFactoryDefault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetSystemFactoryDefault(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemDateAndTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime = NULL;
}

void _tds__GetSystemDateAndTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemDateTime(soap, &this->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime);
#endif
}

int _tds__GetSystemDateAndTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemDateAndTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse), type))
		return soap->error;
	if (a->SystemDateAndTime)
		soap_element_result(soap, "tds:SystemDateAndTime");
	if (!a->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime)
	{	if (soap_element_empty(soap, "tds:SystemDateAndTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", -1, &a->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemDateAndTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemDateAndTimeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(_tds__GetSystemDateAndTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemDateAndTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemDateAndTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SystemDateAndTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemDateAndTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", &a->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime, "tt:SystemDateTime"))
				{	soap_flag_SystemDateAndTime1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemDateAndTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(_tds__GetSystemDateAndTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemDateAndTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemDateAndTimeResponse *p;
	size_t k = sizeof(_tds__GetSystemDateAndTimeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemDateAndTimeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemDateAndTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemDateAndTimeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemDateAndTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemDateAndTimeResponse(soap, tag ? tag : "tds:GetSystemDateAndTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemDateAndTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemDateAndTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTimeResponse(struct soap *soap, _tds__GetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemDateAndTime::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetSystemDateAndTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemDateAndTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemDateAndTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const _tds__GetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemDateAndTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemDateAndTime(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, _tds__GetSystemDateAndTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemDateAndTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(_tds__GetSystemDateAndTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemDateAndTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemDateAndTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTime, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(_tds__GetSystemDateAndTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemDateAndTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemDateAndTime *p;
	size_t k = sizeof(_tds__GetSystemDateAndTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemDateAndTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemDateAndTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemDateAndTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemDateAndTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemDateAndTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemDateAndTime(soap, tag ? tag : "tds:GetSystemDateAndTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemDateAndTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemDateAndTime(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetSystemDateAndTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetSystemDateAndTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetSystemDateAndTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetSystemDateAndTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetSystemDateAndTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetSystemDateAndTimeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(_tds__SetSystemDateAndTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetSystemDateAndTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetSystemDateAndTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(_tds__SetSystemDateAndTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetSystemDateAndTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetSystemDateAndTimeResponse *p;
	size_t k = sizeof(_tds__SetSystemDateAndTimeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetSystemDateAndTimeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetSystemDateAndTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetSystemDateAndTimeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetSystemDateAndTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetSystemDateAndTimeResponse(soap, tag ? tag : "tds:SetSystemDateAndTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetSystemDateAndTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetSystemDateAndTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTimeResponse(struct soap *soap, _tds__SetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetSystemDateAndTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__SetDateTimeType(soap, &this->_tds__SetSystemDateAndTime::DateTimeType);
	soap_default_bool(soap, &this->_tds__SetSystemDateAndTime::DaylightSavings);
	this->_tds__SetSystemDateAndTime::TimeZone = NULL;
	this->_tds__SetSystemDateAndTime::UTCDateTime = NULL;
}

void _tds__SetSystemDateAndTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetSystemDateAndTime::DaylightSavings, SOAP_TYPE_bool);
	soap_serialize_PointerTott__TimeZone(soap, &this->_tds__SetSystemDateAndTime::TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &this->_tds__SetSystemDateAndTime::UTCDateTime);
#endif
}

int _tds__SetSystemDateAndTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetSystemDateAndTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const _tds__SetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tds:DateTimeType", -1, &a->_tds__SetSystemDateAndTime::DateTimeType, ""))
		return soap->error;
	if (soap_out_bool(soap, "tds:DaylightSavings", -1, &a->_tds__SetSystemDateAndTime::DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tds:TimeZone", -1, &a->_tds__SetSystemDateAndTime::TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tds:UTCDateTime", -1, &a->_tds__SetSystemDateAndTime::UTCDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetSystemDateAndTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetSystemDateAndTime(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, _tds__SetSystemDateAndTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetSystemDateAndTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(_tds__SetSystemDateAndTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetSystemDateAndTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetSystemDateAndTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DateTimeType1 = 1;
	size_t soap_flag_DaylightSavings1 = 1;
	size_t soap_flag_TimeZone1 = 1;
	size_t soap_flag_UTCDateTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SetDateTimeType(soap, "tds:DateTimeType", &a->_tds__SetSystemDateAndTime::DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType1--;
					continue;
				}
			}
			if (soap_flag_DaylightSavings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:DaylightSavings", &a->_tds__SetSystemDateAndTime::DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings1--;
					continue;
				}
			}
			if (soap_flag_TimeZone1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TimeZone(soap, "tds:TimeZone", &a->_tds__SetSystemDateAndTime::TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone1--;
					continue;
				}
			}
			if (soap_flag_UTCDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tds:UTCDateTime", &a->_tds__SetSystemDateAndTime::UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType1 > 0 || soap_flag_DaylightSavings1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTime, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(_tds__SetSystemDateAndTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetSystemDateAndTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetSystemDateAndTime *p;
	size_t k = sizeof(_tds__SetSystemDateAndTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetSystemDateAndTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetSystemDateAndTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetSystemDateAndTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetSystemDateAndTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetSystemDateAndTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetSystemDateAndTime(soap, tag ? tag : "tds:SetSystemDateAndTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetSystemDateAndTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetSystemDateAndTime(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDeviceInformationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_tds__GetDeviceInformationResponse::Manufacturer);
	soap_default_std__string(soap, &this->_tds__GetDeviceInformationResponse::Model);
	soap_default_std__string(soap, &this->_tds__GetDeviceInformationResponse::FirmwareVersion);
	soap_default_std__string(soap, &this->_tds__GetDeviceInformationResponse::SerialNumber);
	soap_default_std__string(soap, &this->_tds__GetDeviceInformationResponse::HardwareId);
}

void _tds__GetDeviceInformationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetDeviceInformationResponse::Manufacturer, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetDeviceInformationResponse::Manufacturer);
	soap_embedded(soap, &this->_tds__GetDeviceInformationResponse::Model, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetDeviceInformationResponse::Model);
	soap_embedded(soap, &this->_tds__GetDeviceInformationResponse::FirmwareVersion, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetDeviceInformationResponse::FirmwareVersion);
	soap_embedded(soap, &this->_tds__GetDeviceInformationResponse::SerialNumber, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetDeviceInformationResponse::SerialNumber);
	soap_embedded(soap, &this->_tds__GetDeviceInformationResponse::HardwareId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetDeviceInformationResponse::HardwareId);
#endif
}

int _tds__GetDeviceInformationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDeviceInformationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, const _tds__GetDeviceInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Manufacturer");
	if (soap_out_std__string(soap, "tds:Manufacturer", -1, &a->_tds__GetDeviceInformationResponse::Manufacturer, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tds:Model", -1, &a->_tds__GetDeviceInformationResponse::Model, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tds:FirmwareVersion", -1, &a->_tds__GetDeviceInformationResponse::FirmwareVersion, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tds:SerialNumber", -1, &a->_tds__GetDeviceInformationResponse::SerialNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tds:HardwareId", -1, &a->_tds__GetDeviceInformationResponse::HardwareId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDeviceInformationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDeviceInformationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_in__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, _tds__GetDeviceInformationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDeviceInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(_tds__GetDeviceInformationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDeviceInformationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDeviceInformationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Manufacturer1 = 1;
	size_t soap_flag_Model1 = 1;
	size_t soap_flag_FirmwareVersion1 = 1;
	size_t soap_flag_SerialNumber1 = 1;
	size_t soap_flag_HardwareId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Manufacturer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:Manufacturer", &a->_tds__GetDeviceInformationResponse::Manufacturer, "xsd:string"))
				{	soap_flag_Manufacturer1--;
					continue;
				}
			}
			if (soap_flag_Model1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:Model", &a->_tds__GetDeviceInformationResponse::Model, "xsd:string"))
				{	soap_flag_Model1--;
					continue;
				}
			}
			if (soap_flag_FirmwareVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:FirmwareVersion", &a->_tds__GetDeviceInformationResponse::FirmwareVersion, "xsd:string"))
				{	soap_flag_FirmwareVersion1--;
					continue;
				}
			}
			if (soap_flag_SerialNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:SerialNumber", &a->_tds__GetDeviceInformationResponse::SerialNumber, "xsd:string"))
				{	soap_flag_SerialNumber1--;
					continue;
				}
			}
			if (soap_flag_HardwareId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:HardwareId", &a->_tds__GetDeviceInformationResponse::HardwareId, "xsd:string"))
				{	soap_flag_HardwareId1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Manufacturer");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Manufacturer1 > 0 || soap_flag_Model1 > 0 || soap_flag_FirmwareVersion1 > 0 || soap_flag_SerialNumber1 > 0 || soap_flag_HardwareId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDeviceInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformationResponse, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(_tds__GetDeviceInformationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDeviceInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDeviceInformationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDeviceInformationResponse *p;
	size_t k = sizeof(_tds__GetDeviceInformationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDeviceInformationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDeviceInformationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDeviceInformationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDeviceInformationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDeviceInformationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDeviceInformationResponse(soap, tag ? tag : "tds:GetDeviceInformationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDeviceInformationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDeviceInformationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_get__tds__GetDeviceInformationResponse(struct soap *soap, _tds__GetDeviceInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDeviceInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDeviceInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDeviceInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDeviceInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const _tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDeviceInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDeviceInformation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDeviceInformation * SOAP_FMAC4 soap_in__tds__GetDeviceInformation(struct soap *soap, const char *tag, _tds__GetDeviceInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDeviceInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(_tds__GetDeviceInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDeviceInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDeviceInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDeviceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformation, SOAP_TYPE__tds__GetDeviceInformation, sizeof(_tds__GetDeviceInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDeviceInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDeviceInformation *p;
	size_t k = sizeof(_tds__GetDeviceInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDeviceInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDeviceInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDeviceInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDeviceInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDeviceInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDeviceInformation(soap, tag ? tag : "tds:GetDeviceInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDeviceInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDeviceInformation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDeviceInformation * SOAP_FMAC4 soap_get__tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetServiceCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetServiceCapabilitiesResponse::Capabilities = NULL;
}

void _tds__GetServiceCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__DeviceServiceCapabilities(soap, &this->_tds__GetServiceCapabilitiesResponse::Capabilities);
#endif
}

int _tds__GetServiceCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetServiceCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->_tds__GetServiceCapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", -1, &a->_tds__GetServiceCapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetServiceCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(_tds__GetServiceCapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetServiceCapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetServiceCapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", &a->_tds__GetServiceCapabilitiesResponse::Capabilities, "tds:DeviceServiceCapabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tds__GetServiceCapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(_tds__GetServiceCapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetServiceCapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetServiceCapabilitiesResponse *p;
	size_t k = sizeof(_tds__GetServiceCapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetServiceCapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetServiceCapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetServiceCapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetServiceCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetServiceCapabilitiesResponse(soap, tag ? tag : "tds:GetServiceCapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetServiceCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetServiceCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetServiceCapabilitiesResponse(struct soap *soap, _tds__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetServiceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetServiceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetServiceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetServiceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const _tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetServiceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetServiceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetServiceCapabilities * SOAP_FMAC4 soap_in__tds__GetServiceCapabilities(struct soap *soap, const char *tag, _tds__GetServiceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(_tds__GetServiceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetServiceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetServiceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilities, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(_tds__GetServiceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetServiceCapabilities *p;
	size_t k = sizeof(_tds__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetServiceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetServiceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetServiceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetServiceCapabilities(soap, tag ? tag : "tds:GetServiceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetServiceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetServiceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetServiceCapabilities * SOAP_FMAC4 soap_get__tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetServicesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotds__Service(soap, &this->_tds__GetServicesResponse::Service);
}

void _tds__GetServicesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTotds__Service(soap, &this->_tds__GetServicesResponse::Service);
#endif
}

int _tds__GetServicesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetServicesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServicesResponse(struct soap *soap, const char *tag, int id, const _tds__GetServicesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServicesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Service");
	if (soap_out_std__vectorTemplateOfPointerTotds__Service(soap, "tds:Service", -1, &a->_tds__GetServicesResponse::Service, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetServicesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetServicesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetServicesResponse * SOAP_FMAC4 soap_in__tds__GetServicesResponse(struct soap *soap, const char *tag, _tds__GetServicesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetServicesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServicesResponse, sizeof(_tds__GetServicesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetServicesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetServicesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTotds__Service(soap, "tds:Service", &a->_tds__GetServicesResponse::Service, "tds:Service"))
					continue;
			}
			soap_check_result(soap, "tds:Service");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__GetServicesResponse::Service.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetServicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServicesResponse, SOAP_TYPE__tds__GetServicesResponse, sizeof(_tds__GetServicesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetServicesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetServicesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetServicesResponse *p;
	size_t k = sizeof(_tds__GetServicesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetServicesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetServicesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetServicesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetServicesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetServicesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetServicesResponse(soap, tag ? tag : "tds:GetServicesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetServicesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetServicesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetServicesResponse * SOAP_FMAC4 soap_get__tds__GetServicesResponse(struct soap *soap, _tds__GetServicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetServices::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__GetServices::IncludeCapability);
}

void _tds__GetServices::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetServices::IncludeCapability, SOAP_TYPE_bool);
#endif
}

int _tds__GetServices::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetServices(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServices(struct soap *soap, const char *tag, int id, const _tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServices), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:IncludeCapability", -1, &a->_tds__GetServices::IncludeCapability, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetServices::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetServices(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetServices * SOAP_FMAC4 soap_in__tds__GetServices(struct soap *soap, const char *tag, _tds__GetServices *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetServices*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServices, sizeof(_tds__GetServices), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetServices)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetServices *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IncludeCapability1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IncludeCapability1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:IncludeCapability", &a->_tds__GetServices::IncludeCapability, "xsd:boolean"))
				{	soap_flag_IncludeCapability1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IncludeCapability1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetServices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServices, SOAP_TYPE__tds__GetServices, sizeof(_tds__GetServices), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetServices * SOAP_FMAC2 soap_instantiate__tds__GetServices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetServices(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetServices *p;
	size_t k = sizeof(_tds__GetServices);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetServices, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetServices);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetServices, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetServices location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetServices::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetServices(soap, tag ? tag : "tds:GetServices", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetServices::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetServices(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetServices * SOAP_FMAC4 soap_get__tds__GetServices(struct soap *soap, _tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__StorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	this->tds__StorageConfiguration::Data = NULL;
}

void tds__StorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfigurationData(soap, &this->tds__StorageConfiguration::Data);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tds__StorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__StorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageConfiguration(struct soap *soap, const char *tag, int id, const tds__StorageConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__StorageConfiguration), type ? type : "tds:StorageConfiguration"))
		return soap->error;
	if (!a->tds__StorageConfiguration::Data)
	{	if (soap_element_empty(soap, "tds:Data", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfigurationData(soap, "tds:Data", -1, &a->tds__StorageConfiguration::Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__StorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__StorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tds__StorageConfiguration * SOAP_FMAC4 soap_in_tds__StorageConfiguration(struct soap *soap, const char *tag, tds__StorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__StorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageConfiguration, sizeof(tds__StorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__StorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__StorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfigurationData(soap, "tds:Data", &a->tds__StorageConfiguration::Data, "tds:StorageConfigurationData"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tds__StorageConfiguration::Data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tds__StorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageConfiguration, SOAP_TYPE_tds__StorageConfiguration, sizeof(tds__StorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__StorageConfiguration * SOAP_FMAC2 soap_instantiate_tds__StorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__StorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__StorageConfiguration *p;
	size_t k = sizeof(tds__StorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__StorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__StorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__StorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__StorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__StorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__StorageConfiguration(soap, tag ? tag : "tds:StorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__StorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__StorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tds__StorageConfiguration * SOAP_FMAC4 soap_get_tds__StorageConfiguration(struct soap *soap, tds__StorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__StorageConfigurationData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tds__StorageConfigurationData::LocalPath = NULL;
	this->tds__StorageConfigurationData::StorageUri = NULL;
	this->tds__StorageConfigurationData::User = NULL;
	this->tds__StorageConfigurationData::Extension = NULL;
	soap_default_std__string(soap, &this->tds__StorageConfigurationData::type);
}

void tds__StorageConfigurationData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__anyURI(soap, &this->tds__StorageConfigurationData::LocalPath);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tds__StorageConfigurationData::StorageUri);
	soap_serialize_PointerTotds__UserCredential(soap, &this->tds__StorageConfigurationData::User);
	soap_serialize_PointerTo_tds__StorageConfigurationData_Extension(soap, &this->tds__StorageConfigurationData::Extension);
#endif
}

int tds__StorageConfigurationData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__StorageConfigurationData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageConfigurationData(struct soap *soap, const char *tag, int id, const tds__StorageConfigurationData *a, const char *type)
{
	soap_set_attr(soap, "type", soap_std__string2s(soap, ((tds__StorageConfigurationData*)a)->type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__StorageConfigurationData), type))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tds:LocalPath", -1, &a->tds__StorageConfigurationData::LocalPath, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tds:StorageUri", -1, &a->tds__StorageConfigurationData::StorageUri, ""))
		return soap->error;
	if (soap_out_PointerTotds__UserCredential(soap, "tds:User", -1, &a->tds__StorageConfigurationData::User, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__StorageConfigurationData_Extension(soap, "tds:Extension", -1, &a->tds__StorageConfigurationData::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__StorageConfigurationData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__StorageConfigurationData(soap, tag, this, type);
}

SOAP_FMAC3 tds__StorageConfigurationData * SOAP_FMAC4 soap_in_tds__StorageConfigurationData(struct soap *soap, const char *tag, tds__StorageConfigurationData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__StorageConfigurationData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(tds__StorageConfigurationData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__StorageConfigurationData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__StorageConfigurationData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__string(soap, soap_attr_value(soap, "type", 1, 1), &((tds__StorageConfigurationData*)a)->type))
		return NULL;
	size_t soap_flag_LocalPath1 = 1;
	size_t soap_flag_StorageUri1 = 1;
	size_t soap_flag_User1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LocalPath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tds:LocalPath", &a->tds__StorageConfigurationData::LocalPath, "xsd:anyURI"))
				{	soap_flag_LocalPath1--;
					continue;
				}
			}
			if (soap_flag_StorageUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tds:StorageUri", &a->tds__StorageConfigurationData::StorageUri, "xsd:anyURI"))
				{	soap_flag_StorageUri1--;
					continue;
				}
			}
			if (soap_flag_User1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__UserCredential(soap, "tds:User", &a->tds__StorageConfigurationData::User, "tds:UserCredential"))
				{	soap_flag_User1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__StorageConfigurationData_Extension(soap, "tds:Extension", &a->tds__StorageConfigurationData::Extension, ""))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tds__StorageConfigurationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageConfigurationData, SOAP_TYPE_tds__StorageConfigurationData, sizeof(tds__StorageConfigurationData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__StorageConfigurationData * SOAP_FMAC2 soap_instantiate_tds__StorageConfigurationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__StorageConfigurationData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__StorageConfigurationData *p;
	size_t k = sizeof(tds__StorageConfigurationData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__StorageConfigurationData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__StorageConfigurationData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__StorageConfigurationData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__StorageConfigurationData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__StorageConfigurationData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__StorageConfigurationData(soap, tag ? tag : "tds:StorageConfigurationData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__StorageConfigurationData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__StorageConfigurationData(soap, this, tag, type);
}

SOAP_FMAC3 tds__StorageConfigurationData * SOAP_FMAC4 soap_get_tds__StorageConfigurationData(struct soap *soap, tds__StorageConfigurationData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageConfigurationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__UserCredential::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->tds__UserCredential::UserName);
	this->tds__UserCredential::Password = NULL;
	this->tds__UserCredential::Extension = NULL;
}

void tds__UserCredential::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tds__UserCredential::UserName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tds__UserCredential::UserName);
	soap_serialize_PointerTostd__string(soap, &this->tds__UserCredential::Password);
	soap_serialize_PointerTo_tds__UserCredential_Extension(soap, &this->tds__UserCredential::Extension);
#endif
}

int tds__UserCredential::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__UserCredential(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__UserCredential(struct soap *soap, const char *tag, int id, const tds__UserCredential *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__UserCredential), type))
		return soap->error;
	if (soap_out_std__string(soap, "tds:UserName", -1, &a->tds__UserCredential::UserName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tds:Password", -1, &a->tds__UserCredential::Password, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__UserCredential_Extension(soap, "tds:Extension", -1, &a->tds__UserCredential::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__UserCredential::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__UserCredential(soap, tag, this, type);
}

SOAP_FMAC3 tds__UserCredential * SOAP_FMAC4 soap_in_tds__UserCredential(struct soap *soap, const char *tag, tds__UserCredential *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__UserCredential*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__UserCredential, sizeof(tds__UserCredential), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__UserCredential)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__UserCredential *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UserName1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:UserName", &a->tds__UserCredential::UserName, "xsd:string"))
				{	soap_flag_UserName1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tds:Password", &a->tds__UserCredential::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__UserCredential_Extension(soap, "tds:Extension", &a->tds__UserCredential::Extension, ""))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UserName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tds__UserCredential *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__UserCredential, SOAP_TYPE_tds__UserCredential, sizeof(tds__UserCredential), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__UserCredential * SOAP_FMAC2 soap_instantiate_tds__UserCredential(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__UserCredential(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__UserCredential *p;
	size_t k = sizeof(tds__UserCredential);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__UserCredential, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__UserCredential);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__UserCredential, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__UserCredential location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__UserCredential::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__UserCredential(soap, tag ? tag : "tds:UserCredential", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__UserCredential::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__UserCredential(soap, this, tag, type);
}

SOAP_FMAC3 tds__UserCredential * SOAP_FMAC4 soap_get_tds__UserCredential(struct soap *soap, tds__UserCredential *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__UserCredential(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__MiscCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tds__MiscCapabilities::AuxiliaryCommands = NULL;
}

void tds__MiscCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tds__MiscCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__MiscCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__MiscCapabilities(struct soap *soap, const char *tag, int id, const tds__MiscCapabilities *a, const char *type)
{
	if (((tds__MiscCapabilities*)a)->AuxiliaryCommands)
	{	soap_set_attr(soap, "AuxiliaryCommands", soap_tt__StringAttrList2s(soap, *((tds__MiscCapabilities*)a)->AuxiliaryCommands), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__MiscCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__MiscCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__MiscCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tds__MiscCapabilities * SOAP_FMAC4 soap_in_tds__MiscCapabilities(struct soap *soap, const char *tag, tds__MiscCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__MiscCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__MiscCapabilities, sizeof(tds__MiscCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__MiscCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__MiscCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "AuxiliaryCommands", 1, 0);
		if (t)
		{
			if (!(((tds__MiscCapabilities*)a)->AuxiliaryCommands = soap_new_tt__StringAttrList(soap)))
				return NULL;
			if (soap_s2tt__StringAttrList(soap, t, ((tds__MiscCapabilities*)a)->AuxiliaryCommands))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tds__MiscCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__MiscCapabilities, SOAP_TYPE_tds__MiscCapabilities, sizeof(tds__MiscCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__MiscCapabilities * SOAP_FMAC2 soap_instantiate_tds__MiscCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__MiscCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__MiscCapabilities *p;
	size_t k = sizeof(tds__MiscCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__MiscCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__MiscCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__MiscCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__MiscCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__MiscCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__MiscCapabilities(soap, tag ? tag : "tds:MiscCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__MiscCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__MiscCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tds__MiscCapabilities * SOAP_FMAC4 soap_get_tds__MiscCapabilities(struct soap *soap, tds__MiscCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__MiscCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__SystemCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tds__SystemCapabilities::DiscoveryResolve = NULL;
	this->tds__SystemCapabilities::DiscoveryBye = NULL;
	this->tds__SystemCapabilities::RemoteDiscovery = NULL;
	this->tds__SystemCapabilities::SystemBackup = NULL;
	this->tds__SystemCapabilities::SystemLogging = NULL;
	this->tds__SystemCapabilities::FirmwareUpgrade = NULL;
	this->tds__SystemCapabilities::HttpFirmwareUpgrade = NULL;
	this->tds__SystemCapabilities::HttpSystemBackup = NULL;
	this->tds__SystemCapabilities::HttpSystemLogging = NULL;
	this->tds__SystemCapabilities::HttpSupportInformation = NULL;
	this->tds__SystemCapabilities::StorageConfiguration = NULL;
	this->tds__SystemCapabilities::MaxStorageConfigurations = NULL;
	this->tds__SystemCapabilities::GeoLocationEntries = NULL;
	this->tds__SystemCapabilities::AutoGeo = NULL;
	this->tds__SystemCapabilities::StorageTypesSupported = NULL;
	this->tds__SystemCapabilities::DiscoveryNotSupported = NULL;
	this->tds__SystemCapabilities::NetworkConfigNotSupported = NULL;
	this->tds__SystemCapabilities::UserConfigNotSupported = NULL;
	this->tds__SystemCapabilities::Addons = NULL;
}

void tds__SystemCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tds__SystemCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__SystemCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__SystemCapabilities(struct soap *soap, const char *tag, int id, const tds__SystemCapabilities *a, const char *type)
{
	if (((tds__SystemCapabilities*)a)->DiscoveryResolve)
	{	soap_set_attr(soap, "DiscoveryResolve", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->DiscoveryResolve), 1);
	}
	if (((tds__SystemCapabilities*)a)->DiscoveryBye)
	{	soap_set_attr(soap, "DiscoveryBye", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->DiscoveryBye), 1);
	}
	if (((tds__SystemCapabilities*)a)->RemoteDiscovery)
	{	soap_set_attr(soap, "RemoteDiscovery", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->RemoteDiscovery), 1);
	}
	if (((tds__SystemCapabilities*)a)->SystemBackup)
	{	soap_set_attr(soap, "SystemBackup", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->SystemBackup), 1);
	}
	if (((tds__SystemCapabilities*)a)->SystemLogging)
	{	soap_set_attr(soap, "SystemLogging", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->SystemLogging), 1);
	}
	if (((tds__SystemCapabilities*)a)->FirmwareUpgrade)
	{	soap_set_attr(soap, "FirmwareUpgrade", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->FirmwareUpgrade), 1);
	}
	if (((tds__SystemCapabilities*)a)->HttpFirmwareUpgrade)
	{	soap_set_attr(soap, "HttpFirmwareUpgrade", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->HttpFirmwareUpgrade), 1);
	}
	if (((tds__SystemCapabilities*)a)->HttpSystemBackup)
	{	soap_set_attr(soap, "HttpSystemBackup", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->HttpSystemBackup), 1);
	}
	if (((tds__SystemCapabilities*)a)->HttpSystemLogging)
	{	soap_set_attr(soap, "HttpSystemLogging", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->HttpSystemLogging), 1);
	}
	if (((tds__SystemCapabilities*)a)->HttpSupportInformation)
	{	soap_set_attr(soap, "HttpSupportInformation", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->HttpSupportInformation), 1);
	}
	if (((tds__SystemCapabilities*)a)->StorageConfiguration)
	{	soap_set_attr(soap, "StorageConfiguration", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->StorageConfiguration), 1);
	}
	if (((tds__SystemCapabilities*)a)->MaxStorageConfigurations)
	{	soap_set_attr(soap, "MaxStorageConfigurations", soap_int2s(soap, *((tds__SystemCapabilities*)a)->MaxStorageConfigurations), 1);
	}
	if (((tds__SystemCapabilities*)a)->GeoLocationEntries)
	{	soap_set_attr(soap, "GeoLocationEntries", soap_int2s(soap, *((tds__SystemCapabilities*)a)->GeoLocationEntries), 1);
	}
	if (((tds__SystemCapabilities*)a)->AutoGeo)
	{	soap_set_attr(soap, "AutoGeo", soap_tt__StringAttrList2s(soap, *((tds__SystemCapabilities*)a)->AutoGeo), 1);
	}
	if (((tds__SystemCapabilities*)a)->StorageTypesSupported)
	{	soap_set_attr(soap, "StorageTypesSupported", soap_tt__StringAttrList2s(soap, *((tds__SystemCapabilities*)a)->StorageTypesSupported), 1);
	}
	if (((tds__SystemCapabilities*)a)->DiscoveryNotSupported)
	{	soap_set_attr(soap, "DiscoveryNotSupported", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->DiscoveryNotSupported), 1);
	}
	if (((tds__SystemCapabilities*)a)->NetworkConfigNotSupported)
	{	soap_set_attr(soap, "NetworkConfigNotSupported", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->NetworkConfigNotSupported), 1);
	}
	if (((tds__SystemCapabilities*)a)->UserConfigNotSupported)
	{	soap_set_attr(soap, "UserConfigNotSupported", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->UserConfigNotSupported), 1);
	}
	if (((tds__SystemCapabilities*)a)->Addons)
	{	soap_set_attr(soap, "Addons", soap_tt__StringAttrList2s(soap, *((tds__SystemCapabilities*)a)->Addons), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__SystemCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__SystemCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__SystemCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tds__SystemCapabilities * SOAP_FMAC4 soap_in_tds__SystemCapabilities(struct soap *soap, const char *tag, tds__SystemCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__SystemCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SystemCapabilities, sizeof(tds__SystemCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__SystemCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__SystemCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "DiscoveryResolve", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->DiscoveryResolve = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->DiscoveryResolve))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DiscoveryBye", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->DiscoveryBye = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->DiscoveryBye))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RemoteDiscovery", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->RemoteDiscovery = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->RemoteDiscovery))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SystemBackup", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->SystemBackup = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->SystemBackup))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SystemLogging", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->SystemLogging = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->SystemLogging))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "FirmwareUpgrade", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->FirmwareUpgrade = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->FirmwareUpgrade))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpFirmwareUpgrade", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->HttpFirmwareUpgrade = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->HttpFirmwareUpgrade))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpSystemBackup", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->HttpSystemBackup = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->HttpSystemBackup))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpSystemLogging", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->HttpSystemLogging = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->HttpSystemLogging))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpSupportInformation", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->HttpSupportInformation = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->HttpSupportInformation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "StorageConfiguration", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->StorageConfiguration = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->StorageConfiguration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxStorageConfigurations", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->MaxStorageConfigurations = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SystemCapabilities*)a)->MaxStorageConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoLocationEntries", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->GeoLocationEntries = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SystemCapabilities*)a)->GeoLocationEntries))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AutoGeo", 1, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->AutoGeo = soap_new_tt__StringAttrList(soap)))
				return NULL;
			if (soap_s2tt__StringAttrList(soap, t, ((tds__SystemCapabilities*)a)->AutoGeo))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "StorageTypesSupported", 1, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->StorageTypesSupported = soap_new_tt__StringAttrList(soap)))
				return NULL;
			if (soap_s2tt__StringAttrList(soap, t, ((tds__SystemCapabilities*)a)->StorageTypesSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DiscoveryNotSupported", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->DiscoveryNotSupported = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->DiscoveryNotSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NetworkConfigNotSupported", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->NetworkConfigNotSupported = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->NetworkConfigNotSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "UserConfigNotSupported", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->UserConfigNotSupported = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->UserConfigNotSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Addons", 1, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->Addons = soap_new_tt__StringAttrList(soap)))
				return NULL;
			if (soap_s2tt__StringAttrList(soap, t, ((tds__SystemCapabilities*)a)->Addons))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tds__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__SystemCapabilities, SOAP_TYPE_tds__SystemCapabilities, sizeof(tds__SystemCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tds__SystemCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__SystemCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__SystemCapabilities *p;
	size_t k = sizeof(tds__SystemCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__SystemCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__SystemCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__SystemCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__SystemCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__SystemCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__SystemCapabilities(soap, tag ? tag : "tds:SystemCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__SystemCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__SystemCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tds__SystemCapabilities * SOAP_FMAC4 soap_get_tds__SystemCapabilities(struct soap *soap, tds__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__SecurityCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tds__SecurityCapabilities::TLS1_x002e0 = NULL;
	this->tds__SecurityCapabilities::TLS1_x002e1 = NULL;
	this->tds__SecurityCapabilities::TLS1_x002e2 = NULL;
	this->tds__SecurityCapabilities::OnboardKeyGeneration = NULL;
	this->tds__SecurityCapabilities::AccessPolicyConfig = NULL;
	this->tds__SecurityCapabilities::DefaultAccessPolicy = NULL;
	this->tds__SecurityCapabilities::Dot1X = NULL;
	this->tds__SecurityCapabilities::RemoteUserHandling = NULL;
	this->tds__SecurityCapabilities::X_x002e509Token = NULL;
	this->tds__SecurityCapabilities::SAMLToken = NULL;
	this->tds__SecurityCapabilities::KerberosToken = NULL;
	this->tds__SecurityCapabilities::UsernameToken = NULL;
	this->tds__SecurityCapabilities::HttpDigest = NULL;
	this->tds__SecurityCapabilities::RELToken = NULL;
	this->tds__SecurityCapabilities::SupportedEAPMethods = NULL;
	this->tds__SecurityCapabilities::MaxUsers = NULL;
	this->tds__SecurityCapabilities::MaxUserNameLength = NULL;
	this->tds__SecurityCapabilities::MaxPasswordLength = NULL;
	this->tds__SecurityCapabilities::SecurityPolicies = NULL;
	this->tds__SecurityCapabilities::MaxPasswordHistory = NULL;
	this->tds__SecurityCapabilities::HashingAlgorithms = NULL;
}

void tds__SecurityCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tds__SecurityCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__SecurityCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__SecurityCapabilities(struct soap *soap, const char *tag, int id, const tds__SecurityCapabilities *a, const char *type)
{
	if (((tds__SecurityCapabilities*)a)->TLS1_x002e0)
	{	soap_set_attr(soap, "TLS1.0", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->TLS1_x002e0), 1);
	}
	if (((tds__SecurityCapabilities*)a)->TLS1_x002e1)
	{	soap_set_attr(soap, "TLS1.1", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->TLS1_x002e1), 1);
	}
	if (((tds__SecurityCapabilities*)a)->TLS1_x002e2)
	{	soap_set_attr(soap, "TLS1.2", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->TLS1_x002e2), 1);
	}
	if (((tds__SecurityCapabilities*)a)->OnboardKeyGeneration)
	{	soap_set_attr(soap, "OnboardKeyGeneration", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->OnboardKeyGeneration), 1);
	}
	if (((tds__SecurityCapabilities*)a)->AccessPolicyConfig)
	{	soap_set_attr(soap, "AccessPolicyConfig", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->AccessPolicyConfig), 1);
	}
	if (((tds__SecurityCapabilities*)a)->DefaultAccessPolicy)
	{	soap_set_attr(soap, "DefaultAccessPolicy", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->DefaultAccessPolicy), 1);
	}
	if (((tds__SecurityCapabilities*)a)->Dot1X)
	{	soap_set_attr(soap, "Dot1X", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->Dot1X), 1);
	}
	if (((tds__SecurityCapabilities*)a)->RemoteUserHandling)
	{	soap_set_attr(soap, "RemoteUserHandling", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->RemoteUserHandling), 1);
	}
	if (((tds__SecurityCapabilities*)a)->X_x002e509Token)
	{	soap_set_attr(soap, "X.509Token", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->X_x002e509Token), 1);
	}
	if (((tds__SecurityCapabilities*)a)->SAMLToken)
	{	soap_set_attr(soap, "SAMLToken", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->SAMLToken), 1);
	}
	if (((tds__SecurityCapabilities*)a)->KerberosToken)
	{	soap_set_attr(soap, "KerberosToken", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->KerberosToken), 1);
	}
	if (((tds__SecurityCapabilities*)a)->UsernameToken)
	{	soap_set_attr(soap, "UsernameToken", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->UsernameToken), 1);
	}
	if (((tds__SecurityCapabilities*)a)->HttpDigest)
	{	soap_set_attr(soap, "HttpDigest", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->HttpDigest), 1);
	}
	if (((tds__SecurityCapabilities*)a)->RELToken)
	{	soap_set_attr(soap, "RELToken", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->RELToken), 1);
	}
	if (((tds__SecurityCapabilities*)a)->SupportedEAPMethods)
	{	soap_set_attr(soap, "SupportedEAPMethods", soap_tt__IntList2s(soap, *((tds__SecurityCapabilities*)a)->SupportedEAPMethods), 1);
	}
	if (((tds__SecurityCapabilities*)a)->MaxUsers)
	{	soap_set_attr(soap, "MaxUsers", soap_int2s(soap, *((tds__SecurityCapabilities*)a)->MaxUsers), 1);
	}
	if (((tds__SecurityCapabilities*)a)->MaxUserNameLength)
	{	soap_set_attr(soap, "MaxUserNameLength", soap_int2s(soap, *((tds__SecurityCapabilities*)a)->MaxUserNameLength), 1);
	}
	if (((tds__SecurityCapabilities*)a)->MaxPasswordLength)
	{	soap_set_attr(soap, "MaxPasswordLength", soap_int2s(soap, *((tds__SecurityCapabilities*)a)->MaxPasswordLength), 1);
	}
	if (((tds__SecurityCapabilities*)a)->SecurityPolicies)
	{	soap_set_attr(soap, "SecurityPolicies", soap_tt__StringList2s(soap, *((tds__SecurityCapabilities*)a)->SecurityPolicies), 1);
	}
	if (((tds__SecurityCapabilities*)a)->MaxPasswordHistory)
	{	soap_set_attr(soap, "MaxPasswordHistory", soap_int2s(soap, *((tds__SecurityCapabilities*)a)->MaxPasswordHistory), 1);
	}
	if (((tds__SecurityCapabilities*)a)->HashingAlgorithms)
	{	soap_set_attr(soap, "HashingAlgorithms", soap_tt__StringList2s(soap, *((tds__SecurityCapabilities*)a)->HashingAlgorithms), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__SecurityCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__SecurityCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__SecurityCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tds__SecurityCapabilities * SOAP_FMAC4 soap_in_tds__SecurityCapabilities(struct soap *soap, const char *tag, tds__SecurityCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__SecurityCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(tds__SecurityCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__SecurityCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__SecurityCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "TLS1.0", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->TLS1_x002e0 = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->TLS1_x002e0))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "TLS1.1", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->TLS1_x002e1 = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->TLS1_x002e1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "TLS1.2", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->TLS1_x002e2 = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->TLS1_x002e2))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "OnboardKeyGeneration", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->OnboardKeyGeneration = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->OnboardKeyGeneration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AccessPolicyConfig", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->AccessPolicyConfig = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->AccessPolicyConfig))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DefaultAccessPolicy", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->DefaultAccessPolicy = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->DefaultAccessPolicy))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Dot1X", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->Dot1X = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->Dot1X))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RemoteUserHandling", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->RemoteUserHandling = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->RemoteUserHandling))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "X.509Token", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->X_x002e509Token = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->X_x002e509Token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SAMLToken", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->SAMLToken = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->SAMLToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "KerberosToken", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->KerberosToken = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->KerberosToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "UsernameToken", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->UsernameToken = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->UsernameToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpDigest", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->HttpDigest = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->HttpDigest))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RELToken", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->RELToken = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->RELToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SupportedEAPMethods", 1, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->SupportedEAPMethods = soap_new_tt__IntList(soap)))
				return NULL;
			if (soap_s2tt__IntList(soap, t, ((tds__SecurityCapabilities*)a)->SupportedEAPMethods))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxUsers", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->MaxUsers = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SecurityCapabilities*)a)->MaxUsers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxUserNameLength", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->MaxUserNameLength = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SecurityCapabilities*)a)->MaxUserNameLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxPasswordLength", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->MaxPasswordLength = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SecurityCapabilities*)a)->MaxPasswordLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SecurityPolicies", 1, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->SecurityPolicies = soap_new_tt__StringList(soap)))
				return NULL;
			if (soap_s2tt__StringList(soap, t, ((tds__SecurityCapabilities*)a)->SecurityPolicies))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxPasswordHistory", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->MaxPasswordHistory = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SecurityCapabilities*)a)->MaxPasswordHistory))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HashingAlgorithms", 1, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->HashingAlgorithms = soap_new_tt__StringList(soap)))
				return NULL;
			if (soap_s2tt__StringList(soap, t, ((tds__SecurityCapabilities*)a)->HashingAlgorithms))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tds__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__SecurityCapabilities, SOAP_TYPE_tds__SecurityCapabilities, sizeof(tds__SecurityCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tds__SecurityCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__SecurityCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__SecurityCapabilities *p;
	size_t k = sizeof(tds__SecurityCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__SecurityCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__SecurityCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__SecurityCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__SecurityCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__SecurityCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__SecurityCapabilities(soap, tag ? tag : "tds:SecurityCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__SecurityCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__SecurityCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tds__SecurityCapabilities * SOAP_FMAC4 soap_get_tds__SecurityCapabilities(struct soap *soap, tds__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__NetworkCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tds__NetworkCapabilities::IPFilter = NULL;
	this->tds__NetworkCapabilities::ZeroConfiguration = NULL;
	this->tds__NetworkCapabilities::IPVersion6 = NULL;
	this->tds__NetworkCapabilities::DynDNS = NULL;
	this->tds__NetworkCapabilities::Dot11Configuration = NULL;
	this->tds__NetworkCapabilities::Dot1XConfigurations = NULL;
	this->tds__NetworkCapabilities::HostnameFromDHCP = NULL;
	this->tds__NetworkCapabilities::NTP = NULL;
	this->tds__NetworkCapabilities::DHCPv6 = NULL;
}

void tds__NetworkCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tds__NetworkCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__NetworkCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__NetworkCapabilities(struct soap *soap, const char *tag, int id, const tds__NetworkCapabilities *a, const char *type)
{
	if (((tds__NetworkCapabilities*)a)->IPFilter)
	{	soap_set_attr(soap, "IPFilter", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->IPFilter), 1);
	}
	if (((tds__NetworkCapabilities*)a)->ZeroConfiguration)
	{	soap_set_attr(soap, "ZeroConfiguration", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->ZeroConfiguration), 1);
	}
	if (((tds__NetworkCapabilities*)a)->IPVersion6)
	{	soap_set_attr(soap, "IPVersion6", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->IPVersion6), 1);
	}
	if (((tds__NetworkCapabilities*)a)->DynDNS)
	{	soap_set_attr(soap, "DynDNS", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->DynDNS), 1);
	}
	if (((tds__NetworkCapabilities*)a)->Dot11Configuration)
	{	soap_set_attr(soap, "Dot11Configuration", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->Dot11Configuration), 1);
	}
	if (((tds__NetworkCapabilities*)a)->Dot1XConfigurations)
	{	soap_set_attr(soap, "Dot1XConfigurations", soap_int2s(soap, *((tds__NetworkCapabilities*)a)->Dot1XConfigurations), 1);
	}
	if (((tds__NetworkCapabilities*)a)->HostnameFromDHCP)
	{	soap_set_attr(soap, "HostnameFromDHCP", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->HostnameFromDHCP), 1);
	}
	if (((tds__NetworkCapabilities*)a)->NTP)
	{	soap_set_attr(soap, "NTP", soap_int2s(soap, *((tds__NetworkCapabilities*)a)->NTP), 1);
	}
	if (((tds__NetworkCapabilities*)a)->DHCPv6)
	{	soap_set_attr(soap, "DHCPv6", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->DHCPv6), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__NetworkCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__NetworkCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__NetworkCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tds__NetworkCapabilities * SOAP_FMAC4 soap_in_tds__NetworkCapabilities(struct soap *soap, const char *tag, tds__NetworkCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__NetworkCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(tds__NetworkCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__NetworkCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__NetworkCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "IPFilter", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->IPFilter = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->IPFilter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "ZeroConfiguration", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->ZeroConfiguration = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->ZeroConfiguration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "IPVersion6", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->IPVersion6 = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->IPVersion6))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DynDNS", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->DynDNS = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->DynDNS))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Dot11Configuration", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->Dot11Configuration = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->Dot11Configuration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Dot1XConfigurations", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->Dot1XConfigurations = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__NetworkCapabilities*)a)->Dot1XConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HostnameFromDHCP", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->HostnameFromDHCP = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->HostnameFromDHCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NTP", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->NTP = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__NetworkCapabilities*)a)->NTP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DHCPv6", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->DHCPv6 = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->DHCPv6))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tds__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__NetworkCapabilities, SOAP_TYPE_tds__NetworkCapabilities, sizeof(tds__NetworkCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tds__NetworkCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__NetworkCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__NetworkCapabilities *p;
	size_t k = sizeof(tds__NetworkCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__NetworkCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__NetworkCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__NetworkCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__NetworkCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__NetworkCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__NetworkCapabilities(soap, tag ? tag : "tds:NetworkCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__NetworkCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__NetworkCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tds__NetworkCapabilities * SOAP_FMAC4 soap_get_tds__NetworkCapabilities(struct soap *soap, tds__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__DeviceServiceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tds__DeviceServiceCapabilities::Network = NULL;
	this->tds__DeviceServiceCapabilities::Security = NULL;
	this->tds__DeviceServiceCapabilities::System = NULL;
	this->tds__DeviceServiceCapabilities::Misc = NULL;
}

void tds__DeviceServiceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__NetworkCapabilities(soap, &this->tds__DeviceServiceCapabilities::Network);
	soap_serialize_PointerTotds__SecurityCapabilities(soap, &this->tds__DeviceServiceCapabilities::Security);
	soap_serialize_PointerTotds__SystemCapabilities(soap, &this->tds__DeviceServiceCapabilities::System);
	soap_serialize_PointerTotds__MiscCapabilities(soap, &this->tds__DeviceServiceCapabilities::Misc);
#endif
}

int tds__DeviceServiceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__DeviceServiceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, const tds__DeviceServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__DeviceServiceCapabilities), type))
		return soap->error;
	if (!a->tds__DeviceServiceCapabilities::Network)
	{	if (soap_element_empty(soap, "tds:Network", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__NetworkCapabilities(soap, "tds:Network", -1, &a->tds__DeviceServiceCapabilities::Network, ""))
		return soap->error;
	if (!a->tds__DeviceServiceCapabilities::Security)
	{	if (soap_element_empty(soap, "tds:Security", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__SecurityCapabilities(soap, "tds:Security", -1, &a->tds__DeviceServiceCapabilities::Security, ""))
		return soap->error;
	if (!a->tds__DeviceServiceCapabilities::System)
	{	if (soap_element_empty(soap, "tds:System", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__SystemCapabilities(soap, "tds:System", -1, &a->tds__DeviceServiceCapabilities::System, ""))
		return soap->error;
	if (soap_out_PointerTotds__MiscCapabilities(soap, "tds:Misc", -1, &a->tds__DeviceServiceCapabilities::Misc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__DeviceServiceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__DeviceServiceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_in_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, tds__DeviceServiceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__DeviceServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(tds__DeviceServiceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__DeviceServiceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__DeviceServiceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Network1 = 1;
	size_t soap_flag_Security1 = 1;
	size_t soap_flag_System1 = 1;
	size_t soap_flag_Misc1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Network1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__NetworkCapabilities(soap, "tds:Network", &a->tds__DeviceServiceCapabilities::Network, "tds:NetworkCapabilities"))
				{	soap_flag_Network1--;
					continue;
				}
			}
			if (soap_flag_Security1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__SecurityCapabilities(soap, "tds:Security", &a->tds__DeviceServiceCapabilities::Security, "tds:SecurityCapabilities"))
				{	soap_flag_Security1--;
					continue;
				}
			}
			if (soap_flag_System1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__SystemCapabilities(soap, "tds:System", &a->tds__DeviceServiceCapabilities::System, "tds:SystemCapabilities"))
				{	soap_flag_System1--;
					continue;
				}
			}
			if (soap_flag_Misc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__MiscCapabilities(soap, "tds:Misc", &a->tds__DeviceServiceCapabilities::Misc, "tds:MiscCapabilities"))
				{	soap_flag_Misc1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tds__DeviceServiceCapabilities::Network || !a->tds__DeviceServiceCapabilities::Security || !a->tds__DeviceServiceCapabilities::System))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tds__DeviceServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__DeviceServiceCapabilities, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(tds__DeviceServiceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__DeviceServiceCapabilities * SOAP_FMAC2 soap_instantiate_tds__DeviceServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__DeviceServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__DeviceServiceCapabilities *p;
	size_t k = sizeof(tds__DeviceServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__DeviceServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__DeviceServiceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__DeviceServiceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__DeviceServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__DeviceServiceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__DeviceServiceCapabilities(soap, tag ? tag : "tds:DeviceServiceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__DeviceServiceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__DeviceServiceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_get_tds__DeviceServiceCapabilities(struct soap *soap, tds__DeviceServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__Service::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tds__Service::Namespace);
	soap_default_xsd__anyURI(soap, &this->tds__Service::XAddr);
	this->tds__Service::Capabilities = NULL;
	this->tds__Service::Version = NULL;
}

void tds__Service::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tds__Service::Namespace, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tds__Service::Namespace);
	soap_embedded(soap, &this->tds__Service::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tds__Service::XAddr);
	soap_serialize_PointerTo_tds__Service_Capabilities(soap, &this->tds__Service::Capabilities);
	soap_serialize_PointerTott__OnvifVersion(soap, &this->tds__Service::Version);
#endif
}

int tds__Service::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__Service(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__Service(struct soap *soap, const char *tag, int id, const tds__Service *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__Service), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:Namespace", -1, &a->tds__Service::Namespace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:XAddr", -1, &a->tds__Service::XAddr, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", -1, &a->tds__Service::Capabilities, ""))
		return soap->error;
	if (!a->tds__Service::Version)
	{	if (soap_element_empty(soap, "tds:Version", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OnvifVersion(soap, "tds:Version", -1, &a->tds__Service::Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__Service::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__Service(soap, tag, this, type);
}

SOAP_FMAC3 tds__Service * SOAP_FMAC4 soap_in_tds__Service(struct soap *soap, const char *tag, tds__Service *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__Service*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__Service, sizeof(tds__Service), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__Service)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__Service *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Namespace1 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_Capabilities1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Namespace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:Namespace", &a->tds__Service::Namespace, "xsd:anyURI"))
				{	soap_flag_Namespace1--;
					continue;
				}
			}
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:XAddr", &a->tds__Service::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", &a->tds__Service::Capabilities, ""))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			if (soap_flag_Version1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OnvifVersion(soap, "tds:Version", &a->tds__Service::Version, "tt:OnvifVersion"))
				{	soap_flag_Version1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Namespace1 > 0 || soap_flag_XAddr1 > 0 || !a->tds__Service::Version))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tds__Service *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__Service, SOAP_TYPE_tds__Service, sizeof(tds__Service), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__Service * SOAP_FMAC2 soap_instantiate_tds__Service(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__Service(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__Service *p;
	size_t k = sizeof(tds__Service);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__Service, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__Service);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__Service, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__Service location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__Service::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__Service(soap, tag ? tag : "tds:Service", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__Service::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__Service(soap, this, tag, type);
}

SOAP_FMAC3 tds__Service * SOAP_FMAC4 soap_get_tds__Service(struct soap *soap, tds__Service *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xml__lang(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out__xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__token), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__token, SOAP_TYPE_xsd__token, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "\\+?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__nonNegativeInteger, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__integer, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__duration), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?P(\\d+Y)?(\\d+M)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+(\\.\\d*)?S)?)?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__duration, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 4, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anySimpleType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anySimpleType, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anySimpleType(soap, tag ? tag : "xsd:anySimpleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[\\i-[:]][\\c-[:]]*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__NCName, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__hexBinary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
}

void xsd__hexBinary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__hexBinary);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__hexBinary2s(struct soap *soap, xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

int xsd__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__hexBinary, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__hexBinary(struct soap *soap, const char *s, xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__hexBinary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__hexBinary *p;
	size_t k = sizeof(xsd__hexBinary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__hexBinary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__hexBinary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__hexBinary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__hexBinary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__hexBinary(soap, tag ? tag : "xsd:hexBinary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__QName, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anyType)
		return (xsd__anyType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__anyType *p;
	size_t k = sizeof(xsd__anyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anyType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anyType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anyType(soap, tag ? tag : "xsd:anyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHashingAlgorithm(struct soap *soap, struct __tds__SetHashingAlgorithm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHashingAlgorithm = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHashingAlgorithm(struct soap *soap, const struct __tds__SetHashingAlgorithm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetHashingAlgorithm(soap, &a->tds__SetHashingAlgorithm);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHashingAlgorithm(struct soap *soap, const char *tag, int id, const struct __tds__SetHashingAlgorithm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetHashingAlgorithm(soap, "tds:SetHashingAlgorithm", -1, &a->tds__SetHashingAlgorithm, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHashingAlgorithm * SOAP_FMAC4 soap_in___tds__SetHashingAlgorithm(struct soap *soap, const char *tag, struct __tds__SetHashingAlgorithm *a, const char *type)
{
	size_t soap_flag_tds__SetHashingAlgorithm = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetHashingAlgorithm*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHashingAlgorithm, sizeof(struct __tds__SetHashingAlgorithm), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHashingAlgorithm(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHashingAlgorithm && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetHashingAlgorithm(soap, "tds:SetHashingAlgorithm", &a->tds__SetHashingAlgorithm, ""))
				{	soap_flag_tds__SetHashingAlgorithm--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetHashingAlgorithm * SOAP_FMAC2 soap_instantiate___tds__SetHashingAlgorithm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetHashingAlgorithm(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetHashingAlgorithm *p;
	size_t k = sizeof(struct __tds__SetHashingAlgorithm);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetHashingAlgorithm, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetHashingAlgorithm);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetHashingAlgorithm, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetHashingAlgorithm location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHashingAlgorithm(struct soap *soap, const struct __tds__SetHashingAlgorithm *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetHashingAlgorithm(soap, tag ? tag : "-tds:SetHashingAlgorithm", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHashingAlgorithm * SOAP_FMAC4 soap_get___tds__SetHashingAlgorithm(struct soap *soap, struct __tds__SetHashingAlgorithm *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHashingAlgorithm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteGeoLocation(struct soap *soap, struct __tds__DeleteGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteGeoLocation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteGeoLocation(struct soap *soap, const struct __tds__DeleteGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteGeoLocation(soap, &a->tds__DeleteGeoLocation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteGeoLocation(struct soap *soap, const char *tag, int id, const struct __tds__DeleteGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteGeoLocation(soap, "tds:DeleteGeoLocation", -1, &a->tds__DeleteGeoLocation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteGeoLocation * SOAP_FMAC4 soap_in___tds__DeleteGeoLocation(struct soap *soap, const char *tag, struct __tds__DeleteGeoLocation *a, const char *type)
{
	size_t soap_flag_tds__DeleteGeoLocation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteGeoLocation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteGeoLocation, sizeof(struct __tds__DeleteGeoLocation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteGeoLocation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteGeoLocation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteGeoLocation(soap, "tds:DeleteGeoLocation", &a->tds__DeleteGeoLocation, ""))
				{	soap_flag_tds__DeleteGeoLocation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate___tds__DeleteGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__DeleteGeoLocation *p;
	size_t k = sizeof(struct __tds__DeleteGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__DeleteGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__DeleteGeoLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__DeleteGeoLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__DeleteGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteGeoLocation(struct soap *soap, const struct __tds__DeleteGeoLocation *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteGeoLocation(soap, tag ? tag : "-tds:DeleteGeoLocation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteGeoLocation * SOAP_FMAC4 soap_get___tds__DeleteGeoLocation(struct soap *soap, struct __tds__DeleteGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetGeoLocation(struct soap *soap, struct __tds__SetGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetGeoLocation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetGeoLocation(struct soap *soap, const struct __tds__SetGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetGeoLocation(soap, &a->tds__SetGeoLocation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetGeoLocation(struct soap *soap, const char *tag, int id, const struct __tds__SetGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetGeoLocation(soap, "tds:SetGeoLocation", -1, &a->tds__SetGeoLocation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetGeoLocation * SOAP_FMAC4 soap_in___tds__SetGeoLocation(struct soap *soap, const char *tag, struct __tds__SetGeoLocation *a, const char *type)
{
	size_t soap_flag_tds__SetGeoLocation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetGeoLocation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetGeoLocation, sizeof(struct __tds__SetGeoLocation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetGeoLocation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetGeoLocation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetGeoLocation(soap, "tds:SetGeoLocation", &a->tds__SetGeoLocation, ""))
				{	soap_flag_tds__SetGeoLocation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__SetGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetGeoLocation *p;
	size_t k = sizeof(struct __tds__SetGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetGeoLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetGeoLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetGeoLocation(struct soap *soap, const struct __tds__SetGeoLocation *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetGeoLocation(soap, tag ? tag : "-tds:SetGeoLocation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetGeoLocation * SOAP_FMAC4 soap_get___tds__SetGeoLocation(struct soap *soap, struct __tds__SetGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetGeoLocation(struct soap *soap, struct __tds__GetGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetGeoLocation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetGeoLocation(struct soap *soap, const struct __tds__GetGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetGeoLocation(soap, &a->tds__GetGeoLocation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetGeoLocation(struct soap *soap, const char *tag, int id, const struct __tds__GetGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetGeoLocation(soap, "tds:GetGeoLocation", -1, &a->tds__GetGeoLocation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetGeoLocation * SOAP_FMAC4 soap_in___tds__GetGeoLocation(struct soap *soap, const char *tag, struct __tds__GetGeoLocation *a, const char *type)
{
	size_t soap_flag_tds__GetGeoLocation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetGeoLocation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetGeoLocation, sizeof(struct __tds__GetGeoLocation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetGeoLocation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetGeoLocation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetGeoLocation(soap, "tds:GetGeoLocation", &a->tds__GetGeoLocation, ""))
				{	soap_flag_tds__GetGeoLocation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__GetGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetGeoLocation *p;
	size_t k = sizeof(struct __tds__GetGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetGeoLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetGeoLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetGeoLocation(struct soap *soap, const struct __tds__GetGeoLocation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetGeoLocation(soap, tag ? tag : "-tds:GetGeoLocation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetGeoLocation * SOAP_FMAC4 soap_get___tds__GetGeoLocation(struct soap *soap, struct __tds__GetGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteStorageConfiguration(struct soap *soap, struct __tds__DeleteStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteStorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteStorageConfiguration(struct soap *soap, const struct __tds__DeleteStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteStorageConfiguration(soap, &a->tds__DeleteStorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__DeleteStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteStorageConfiguration(soap, "tds:DeleteStorageConfiguration", -1, &a->tds__DeleteStorageConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_in___tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, struct __tds__DeleteStorageConfiguration *a, const char *type)
{
	size_t soap_flag_tds__DeleteStorageConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteStorageConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteStorageConfiguration, sizeof(struct __tds__DeleteStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteStorageConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteStorageConfiguration(soap, "tds:DeleteStorageConfiguration", &a->tds__DeleteStorageConfiguration, ""))
				{	soap_flag_tds__DeleteStorageConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__DeleteStorageConfiguration *p;
	size_t k = sizeof(struct __tds__DeleteStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__DeleteStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__DeleteStorageConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__DeleteStorageConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__DeleteStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteStorageConfiguration(struct soap *soap, const struct __tds__DeleteStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteStorageConfiguration(soap, tag ? tag : "-tds:DeleteStorageConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_get___tds__DeleteStorageConfiguration(struct soap *soap, struct __tds__DeleteStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetStorageConfiguration(struct soap *soap, struct __tds__SetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetStorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetStorageConfiguration(struct soap *soap, const struct __tds__SetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetStorageConfiguration(soap, &a->tds__SetStorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetStorageConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetStorageConfiguration(soap, "tds:SetStorageConfiguration", -1, &a->tds__SetStorageConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetStorageConfiguration * SOAP_FMAC4 soap_in___tds__SetStorageConfiguration(struct soap *soap, const char *tag, struct __tds__SetStorageConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetStorageConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetStorageConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetStorageConfiguration, sizeof(struct __tds__SetStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetStorageConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetStorageConfiguration(soap, "tds:SetStorageConfiguration", &a->tds__SetStorageConfiguration, ""))
				{	soap_flag_tds__SetStorageConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetStorageConfiguration *p;
	size_t k = sizeof(struct __tds__SetStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetStorageConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetStorageConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetStorageConfiguration(struct soap *soap, const struct __tds__SetStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetStorageConfiguration(soap, tag ? tag : "-tds:SetStorageConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetStorageConfiguration * SOAP_FMAC4 soap_get___tds__SetStorageConfiguration(struct soap *soap, struct __tds__SetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetStorageConfiguration(struct soap *soap, struct __tds__GetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetStorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetStorageConfiguration(struct soap *soap, const struct __tds__GetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetStorageConfiguration(soap, &a->tds__GetStorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetStorageConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetStorageConfiguration(soap, "tds:GetStorageConfiguration", -1, &a->tds__GetStorageConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetStorageConfiguration * SOAP_FMAC4 soap_in___tds__GetStorageConfiguration(struct soap *soap, const char *tag, struct __tds__GetStorageConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetStorageConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetStorageConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetStorageConfiguration, sizeof(struct __tds__GetStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetStorageConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetStorageConfiguration(soap, "tds:GetStorageConfiguration", &a->tds__GetStorageConfiguration, ""))
				{	soap_flag_tds__GetStorageConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetStorageConfiguration *p;
	size_t k = sizeof(struct __tds__GetStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetStorageConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetStorageConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetStorageConfiguration(struct soap *soap, const struct __tds__GetStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetStorageConfiguration(soap, tag ? tag : "-tds:GetStorageConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetStorageConfiguration * SOAP_FMAC4 soap_get___tds__GetStorageConfiguration(struct soap *soap, struct __tds__GetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateStorageConfiguration(struct soap *soap, struct __tds__CreateStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateStorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateStorageConfiguration(struct soap *soap, const struct __tds__CreateStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__CreateStorageConfiguration(soap, &a->tds__CreateStorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateStorageConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__CreateStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__CreateStorageConfiguration(soap, "tds:CreateStorageConfiguration", -1, &a->tds__CreateStorageConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateStorageConfiguration * SOAP_FMAC4 soap_in___tds__CreateStorageConfiguration(struct soap *soap, const char *tag, struct __tds__CreateStorageConfiguration *a, const char *type)
{
	size_t soap_flag_tds__CreateStorageConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__CreateStorageConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateStorageConfiguration, sizeof(struct __tds__CreateStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateStorageConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__CreateStorageConfiguration(soap, "tds:CreateStorageConfiguration", &a->tds__CreateStorageConfiguration, ""))
				{	soap_flag_tds__CreateStorageConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__CreateStorageConfiguration *p;
	size_t k = sizeof(struct __tds__CreateStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__CreateStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__CreateStorageConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__CreateStorageConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__CreateStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateStorageConfiguration(struct soap *soap, const struct __tds__CreateStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__CreateStorageConfiguration(soap, tag ? tag : "-tds:CreateStorageConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateStorageConfiguration * SOAP_FMAC4 soap_get___tds__CreateStorageConfiguration(struct soap *soap, struct __tds__CreateStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetStorageConfigurations(struct soap *soap, struct __tds__GetStorageConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetStorageConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetStorageConfigurations(struct soap *soap, const struct __tds__GetStorageConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetStorageConfigurations(soap, &a->tds__GetStorageConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetStorageConfigurations(struct soap *soap, const char *tag, int id, const struct __tds__GetStorageConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetStorageConfigurations(soap, "tds:GetStorageConfigurations", -1, &a->tds__GetStorageConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetStorageConfigurations * SOAP_FMAC4 soap_in___tds__GetStorageConfigurations(struct soap *soap, const char *tag, struct __tds__GetStorageConfigurations *a, const char *type)
{
	size_t soap_flag_tds__GetStorageConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetStorageConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetStorageConfigurations, sizeof(struct __tds__GetStorageConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetStorageConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetStorageConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetStorageConfigurations(soap, "tds:GetStorageConfigurations", &a->tds__GetStorageConfigurations, ""))
				{	soap_flag_tds__GetStorageConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetStorageConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetStorageConfigurations *p;
	size_t k = sizeof(struct __tds__GetStorageConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetStorageConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetStorageConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetStorageConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetStorageConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetStorageConfigurations(struct soap *soap, const struct __tds__GetStorageConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetStorageConfigurations(soap, tag ? tag : "-tds:GetStorageConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetStorageConfigurations * SOAP_FMAC4 soap_get___tds__GetStorageConfigurations(struct soap *soap, struct __tds__GetStorageConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetStorageConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__StartSystemRestore(struct soap *soap, struct __tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__StartSystemRestore = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__StartSystemRestore(struct soap *soap, const struct __tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__StartSystemRestore(soap, &a->tds__StartSystemRestore);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const struct __tds__StartSystemRestore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__StartSystemRestore(soap, "tds:StartSystemRestore", -1, &a->tds__StartSystemRestore, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartSystemRestore * SOAP_FMAC4 soap_in___tds__StartSystemRestore(struct soap *soap, const char *tag, struct __tds__StartSystemRestore *a, const char *type)
{
	size_t soap_flag_tds__StartSystemRestore = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__StartSystemRestore*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__StartSystemRestore, sizeof(struct __tds__StartSystemRestore), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__StartSystemRestore(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__StartSystemRestore && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__StartSystemRestore(soap, "tds:StartSystemRestore", &a->tds__StartSystemRestore, ""))
				{	soap_flag_tds__StartSystemRestore--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate___tds__StartSystemRestore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__StartSystemRestore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__StartSystemRestore *p;
	size_t k = sizeof(struct __tds__StartSystemRestore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__StartSystemRestore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__StartSystemRestore);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__StartSystemRestore, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__StartSystemRestore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__StartSystemRestore(struct soap *soap, const struct __tds__StartSystemRestore *a, const char *tag, const char *type)
{
	if (soap_out___tds__StartSystemRestore(soap, tag ? tag : "-tds:StartSystemRestore", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartSystemRestore * SOAP_FMAC4 soap_get___tds__StartSystemRestore(struct soap *soap, struct __tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__StartFirmwareUpgrade(struct soap *soap, struct __tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__StartFirmwareUpgrade = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__StartFirmwareUpgrade(struct soap *soap, const struct __tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__StartFirmwareUpgrade(soap, &a->tds__StartFirmwareUpgrade);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const struct __tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__StartFirmwareUpgrade(soap, "tds:StartFirmwareUpgrade", -1, &a->tds__StartFirmwareUpgrade, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in___tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, struct __tds__StartFirmwareUpgrade *a, const char *type)
{
	size_t soap_flag_tds__StartFirmwareUpgrade = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__StartFirmwareUpgrade*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__StartFirmwareUpgrade, sizeof(struct __tds__StartFirmwareUpgrade), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__StartFirmwareUpgrade(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__StartFirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__StartFirmwareUpgrade(soap, "tds:StartFirmwareUpgrade", &a->tds__StartFirmwareUpgrade, ""))
				{	soap_flag_tds__StartFirmwareUpgrade--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate___tds__StartFirmwareUpgrade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__StartFirmwareUpgrade(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__StartFirmwareUpgrade *p;
	size_t k = sizeof(struct __tds__StartFirmwareUpgrade);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__StartFirmwareUpgrade, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__StartFirmwareUpgrade);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__StartFirmwareUpgrade, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__StartFirmwareUpgrade location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__StartFirmwareUpgrade(struct soap *soap, const struct __tds__StartFirmwareUpgrade *a, const char *tag, const char *type)
{
	if (soap_out___tds__StartFirmwareUpgrade(soap, tag ? tag : "-tds:StartFirmwareUpgrade", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get___tds__StartFirmwareUpgrade(struct soap *soap, struct __tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemUris(struct soap *soap, struct __tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemUris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemUris(struct soap *soap, const struct __tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemUris(soap, &a->tds__GetSystemUris);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemUris(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemUris *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemUris(soap, "tds:GetSystemUris", -1, &a->tds__GetSystemUris, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemUris * SOAP_FMAC4 soap_in___tds__GetSystemUris(struct soap *soap, const char *tag, struct __tds__GetSystemUris *a, const char *type)
{
	size_t soap_flag_tds__GetSystemUris = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemUris*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemUris, sizeof(struct __tds__GetSystemUris), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemUris(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemUris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemUris(soap, "tds:GetSystemUris", &a->tds__GetSystemUris, ""))
				{	soap_flag_tds__GetSystemUris--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetSystemUris * SOAP_FMAC2 soap_instantiate___tds__GetSystemUris(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemUris(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetSystemUris *p;
	size_t k = sizeof(struct __tds__GetSystemUris);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetSystemUris, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetSystemUris);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetSystemUris, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetSystemUris location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemUris(struct soap *soap, const struct __tds__GetSystemUris *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemUris(soap, tag ? tag : "-tds:GetSystemUris", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemUris * SOAP_FMAC4 soap_get___tds__GetSystemUris(struct soap *soap, struct __tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__ScanAvailableDot11Networks(struct soap *soap, struct __tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__ScanAvailableDot11Networks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__ScanAvailableDot11Networks(struct soap *soap, const struct __tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__ScanAvailableDot11Networks(soap, &a->tds__ScanAvailableDot11Networks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const struct __tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__ScanAvailableDot11Networks(soap, "tds:ScanAvailableDot11Networks", -1, &a->tds__ScanAvailableDot11Networks, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in___tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, struct __tds__ScanAvailableDot11Networks *a, const char *type)
{
	size_t soap_flag_tds__ScanAvailableDot11Networks = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__ScanAvailableDot11Networks*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__ScanAvailableDot11Networks, sizeof(struct __tds__ScanAvailableDot11Networks), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__ScanAvailableDot11Networks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__ScanAvailableDot11Networks && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__ScanAvailableDot11Networks(soap, "tds:ScanAvailableDot11Networks", &a->tds__ScanAvailableDot11Networks, ""))
				{	soap_flag_tds__ScanAvailableDot11Networks--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate___tds__ScanAvailableDot11Networks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__ScanAvailableDot11Networks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__ScanAvailableDot11Networks *p;
	size_t k = sizeof(struct __tds__ScanAvailableDot11Networks);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__ScanAvailableDot11Networks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__ScanAvailableDot11Networks);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__ScanAvailableDot11Networks, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__ScanAvailableDot11Networks location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__ScanAvailableDot11Networks(struct soap *soap, const struct __tds__ScanAvailableDot11Networks *a, const char *tag, const char *type)
{
	if (soap_out___tds__ScanAvailableDot11Networks(soap, tag ? tag : "-tds:ScanAvailableDot11Networks", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get___tds__ScanAvailableDot11Networks(struct soap *soap, struct __tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot11Status(struct soap *soap, struct __tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot11Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot11Status(struct soap *soap, const struct __tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDot11Status(soap, &a->tds__GetDot11Status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot11Status(struct soap *soap, const char *tag, int id, const struct __tds__GetDot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDot11Status(soap, "tds:GetDot11Status", -1, &a->tds__GetDot11Status, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Status * SOAP_FMAC4 soap_in___tds__GetDot11Status(struct soap *soap, const char *tag, struct __tds__GetDot11Status *a, const char *type)
{
	size_t soap_flag_tds__GetDot11Status = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDot11Status*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot11Status, sizeof(struct __tds__GetDot11Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot11Status(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot11Status && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDot11Status(soap, "tds:GetDot11Status", &a->tds__GetDot11Status, ""))
				{	soap_flag_tds__GetDot11Status--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDot11Status * SOAP_FMAC2 soap_instantiate___tds__GetDot11Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot11Status(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDot11Status *p;
	size_t k = sizeof(struct __tds__GetDot11Status);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDot11Status, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDot11Status);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDot11Status, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDot11Status location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot11Status(struct soap *soap, const struct __tds__GetDot11Status *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDot11Status(soap, tag ? tag : "-tds:GetDot11Status", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Status * SOAP_FMAC4 soap_get___tds__GetDot11Status(struct soap *soap, struct __tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot11Capabilities(struct soap *soap, struct __tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot11Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot11Capabilities(struct soap *soap, const struct __tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDot11Capabilities(soap, &a->tds__GetDot11Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetDot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDot11Capabilities(soap, "tds:GetDot11Capabilities", -1, &a->tds__GetDot11Capabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Capabilities * SOAP_FMAC4 soap_in___tds__GetDot11Capabilities(struct soap *soap, const char *tag, struct __tds__GetDot11Capabilities *a, const char *type)
{
	size_t soap_flag_tds__GetDot11Capabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDot11Capabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot11Capabilities, sizeof(struct __tds__GetDot11Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot11Capabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot11Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDot11Capabilities(soap, "tds:GetDot11Capabilities", &a->tds__GetDot11Capabilities, ""))
				{	soap_flag_tds__GetDot11Capabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate___tds__GetDot11Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot11Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDot11Capabilities *p;
	size_t k = sizeof(struct __tds__GetDot11Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDot11Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDot11Capabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDot11Capabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDot11Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot11Capabilities(struct soap *soap, const struct __tds__GetDot11Capabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDot11Capabilities(soap, tag ? tag : "-tds:GetDot11Capabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Capabilities * SOAP_FMAC4 soap_get___tds__GetDot11Capabilities(struct soap *soap, struct __tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteDot1XConfiguration(struct soap *soap, struct __tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteDot1XConfiguration(struct soap *soap, const struct __tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteDot1XConfiguration(soap, &a->tds__DeleteDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteDot1XConfiguration(soap, "tds:DeleteDot1XConfiguration", -1, &a->tds__DeleteDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in___tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__DeleteDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__DeleteDot1XConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteDot1XConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteDot1XConfiguration, sizeof(struct __tds__DeleteDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteDot1XConfiguration(soap, "tds:DeleteDot1XConfiguration", &a->tds__DeleteDot1XConfiguration, ""))
				{	soap_flag_tds__DeleteDot1XConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__DeleteDot1XConfiguration *p;
	size_t k = sizeof(struct __tds__DeleteDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__DeleteDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__DeleteDot1XConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__DeleteDot1XConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__DeleteDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteDot1XConfiguration(struct soap *soap, const struct __tds__DeleteDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteDot1XConfiguration(soap, tag ? tag : "-tds:DeleteDot1XConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get___tds__DeleteDot1XConfiguration(struct soap *soap, struct __tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot1XConfigurations(struct soap *soap, struct __tds__GetDot1XConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot1XConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot1XConfigurations(struct soap *soap, const struct __tds__GetDot1XConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDot1XConfigurations(soap, &a->tds__GetDot1XConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, const struct __tds__GetDot1XConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDot1XConfigurations(soap, "tds:GetDot1XConfigurations", -1, &a->tds__GetDot1XConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfigurations * SOAP_FMAC4 soap_in___tds__GetDot1XConfigurations(struct soap *soap, const char *tag, struct __tds__GetDot1XConfigurations *a, const char *type)
{
	size_t soap_flag_tds__GetDot1XConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDot1XConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot1XConfigurations, sizeof(struct __tds__GetDot1XConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot1XConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot1XConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDot1XConfigurations(soap, "tds:GetDot1XConfigurations", &a->tds__GetDot1XConfigurations, ""))
				{	soap_flag_tds__GetDot1XConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot1XConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDot1XConfigurations *p;
	size_t k = sizeof(struct __tds__GetDot1XConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDot1XConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDot1XConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDot1XConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDot1XConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot1XConfigurations(struct soap *soap, const struct __tds__GetDot1XConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDot1XConfigurations(soap, tag ? tag : "-tds:GetDot1XConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfigurations * SOAP_FMAC4 soap_get___tds__GetDot1XConfigurations(struct soap *soap, struct __tds__GetDot1XConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot1XConfiguration(struct soap *soap, struct __tds__GetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot1XConfiguration(struct soap *soap, const struct __tds__GetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDot1XConfiguration(soap, &a->tds__GetDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDot1XConfiguration(soap, "tds:GetDot1XConfiguration", -1, &a->tds__GetDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfiguration * SOAP_FMAC4 soap_in___tds__GetDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__GetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetDot1XConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDot1XConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot1XConfiguration, sizeof(struct __tds__GetDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDot1XConfiguration(soap, "tds:GetDot1XConfiguration", &a->tds__GetDot1XConfiguration, ""))
				{	soap_flag_tds__GetDot1XConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDot1XConfiguration *p;
	size_t k = sizeof(struct __tds__GetDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDot1XConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDot1XConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot1XConfiguration(struct soap *soap, const struct __tds__GetDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDot1XConfiguration(soap, tag ? tag : "-tds:GetDot1XConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfiguration * SOAP_FMAC4 soap_get___tds__GetDot1XConfiguration(struct soap *soap, struct __tds__GetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDot1XConfiguration(struct soap *soap, struct __tds__SetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDot1XConfiguration(struct soap *soap, const struct __tds__SetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDot1XConfiguration(soap, &a->tds__SetDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDot1XConfiguration(soap, "tds:SetDot1XConfiguration", -1, &a->tds__SetDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDot1XConfiguration * SOAP_FMAC4 soap_in___tds__SetDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__SetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetDot1XConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDot1XConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDot1XConfiguration, sizeof(struct __tds__SetDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDot1XConfiguration(soap, "tds:SetDot1XConfiguration", &a->tds__SetDot1XConfiguration, ""))
				{	soap_flag_tds__SetDot1XConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetDot1XConfiguration *p;
	size_t k = sizeof(struct __tds__SetDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetDot1XConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetDot1XConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDot1XConfiguration(struct soap *soap, const struct __tds__SetDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDot1XConfiguration(soap, tag ? tag : "-tds:SetDot1XConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDot1XConfiguration * SOAP_FMAC4 soap_get___tds__SetDot1XConfiguration(struct soap *soap, struct __tds__SetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateDot1XConfiguration(struct soap *soap, struct __tds__CreateDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateDot1XConfiguration(struct soap *soap, const struct __tds__CreateDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__CreateDot1XConfiguration(soap, &a->tds__CreateDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__CreateDot1XConfiguration(soap, "tds:CreateDot1XConfiguration", -1, &a->tds__CreateDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_in___tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__CreateDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__CreateDot1XConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__CreateDot1XConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateDot1XConfiguration, sizeof(struct __tds__CreateDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__CreateDot1XConfiguration(soap, "tds:CreateDot1XConfiguration", &a->tds__CreateDot1XConfiguration, ""))
				{	soap_flag_tds__CreateDot1XConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__CreateDot1XConfiguration *p;
	size_t k = sizeof(struct __tds__CreateDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__CreateDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__CreateDot1XConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__CreateDot1XConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__CreateDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateDot1XConfiguration(struct soap *soap, const struct __tds__CreateDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__CreateDot1XConfiguration(soap, tag ? tag : "-tds:CreateDot1XConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_get___tds__CreateDot1XConfiguration(struct soap *soap, struct __tds__CreateDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__LoadCACertificates(struct soap *soap, struct __tds__LoadCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__LoadCACertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__LoadCACertificates(struct soap *soap, const struct __tds__LoadCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__LoadCACertificates(soap, &a->tds__LoadCACertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__LoadCACertificates(struct soap *soap, const char *tag, int id, const struct __tds__LoadCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__LoadCACertificates(soap, "tds:LoadCACertificates", -1, &a->tds__LoadCACertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCACertificates * SOAP_FMAC4 soap_in___tds__LoadCACertificates(struct soap *soap, const char *tag, struct __tds__LoadCACertificates *a, const char *type)
{
	size_t soap_flag_tds__LoadCACertificates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__LoadCACertificates*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__LoadCACertificates, sizeof(struct __tds__LoadCACertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__LoadCACertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__LoadCACertificates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__LoadCACertificates(soap, "tds:LoadCACertificates", &a->tds__LoadCACertificates, ""))
				{	soap_flag_tds__LoadCACertificates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__LoadCACertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__LoadCACertificates *p;
	size_t k = sizeof(struct __tds__LoadCACertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__LoadCACertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__LoadCACertificates);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__LoadCACertificates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__LoadCACertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__LoadCACertificates(struct soap *soap, const struct __tds__LoadCACertificates *a, const char *tag, const char *type)
{
	if (soap_out___tds__LoadCACertificates(soap, tag ? tag : "-tds:LoadCACertificates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCACertificates * SOAP_FMAC4 soap_get___tds__LoadCACertificates(struct soap *soap, struct __tds__LoadCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCertificateInformation(struct soap *soap, struct __tds__GetCertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCertificateInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCertificateInformation(struct soap *soap, const struct __tds__GetCertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCertificateInformation(soap, &a->tds__GetCertificateInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetCertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCertificateInformation(soap, "tds:GetCertificateInformation", -1, &a->tds__GetCertificateInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificateInformation * SOAP_FMAC4 soap_in___tds__GetCertificateInformation(struct soap *soap, const char *tag, struct __tds__GetCertificateInformation *a, const char *type)
{
	size_t soap_flag_tds__GetCertificateInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCertificateInformation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCertificateInformation, sizeof(struct __tds__GetCertificateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCertificateInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCertificateInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCertificateInformation(soap, "tds:GetCertificateInformation", &a->tds__GetCertificateInformation, ""))
				{	soap_flag_tds__GetCertificateInformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate___tds__GetCertificateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCertificateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetCertificateInformation *p;
	size_t k = sizeof(struct __tds__GetCertificateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetCertificateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetCertificateInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetCertificateInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetCertificateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCertificateInformation(struct soap *soap, const struct __tds__GetCertificateInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCertificateInformation(soap, tag ? tag : "-tds:GetCertificateInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificateInformation * SOAP_FMAC4 soap_get___tds__GetCertificateInformation(struct soap *soap, struct __tds__GetCertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__LoadCertificateWithPrivateKey(struct soap *soap, struct __tds__LoadCertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__LoadCertificateWithPrivateKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct __tds__LoadCertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKey(soap, &a->tds__LoadCertificateWithPrivateKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const struct __tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(soap, "tds:LoadCertificateWithPrivateKey", -1, &a->tds__LoadCertificateWithPrivateKey, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_in___tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, struct __tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	size_t soap_flag_tds__LoadCertificateWithPrivateKey = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__LoadCertificateWithPrivateKey*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__LoadCertificateWithPrivateKey, sizeof(struct __tds__LoadCertificateWithPrivateKey), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__LoadCertificateWithPrivateKey(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__LoadCertificateWithPrivateKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(soap, "tds:LoadCertificateWithPrivateKey", &a->tds__LoadCertificateWithPrivateKey, ""))
				{	soap_flag_tds__LoadCertificateWithPrivateKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate___tds__LoadCertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__LoadCertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__LoadCertificateWithPrivateKey *p;
	size_t k = sizeof(struct __tds__LoadCertificateWithPrivateKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__LoadCertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__LoadCertificateWithPrivateKey);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__LoadCertificateWithPrivateKey, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__LoadCertificateWithPrivateKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct __tds__LoadCertificateWithPrivateKey *a, const char *tag, const char *type)
{
	if (soap_out___tds__LoadCertificateWithPrivateKey(soap, tag ? tag : "-tds:LoadCertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_get___tds__LoadCertificateWithPrivateKey(struct soap *soap, struct __tds__LoadCertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCACertificates(struct soap *soap, struct __tds__GetCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCACertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCACertificates(struct soap *soap, const struct __tds__GetCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCACertificates(soap, &a->tds__GetCACertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCACertificates(struct soap *soap, const char *tag, int id, const struct __tds__GetCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCACertificates(soap, "tds:GetCACertificates", -1, &a->tds__GetCACertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCACertificates * SOAP_FMAC4 soap_in___tds__GetCACertificates(struct soap *soap, const char *tag, struct __tds__GetCACertificates *a, const char *type)
{
	size_t soap_flag_tds__GetCACertificates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCACertificates*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCACertificates, sizeof(struct __tds__GetCACertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCACertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCACertificates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCACertificates(soap, "tds:GetCACertificates", &a->tds__GetCACertificates, ""))
				{	soap_flag_tds__GetCACertificates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetCACertificates * SOAP_FMAC2 soap_instantiate___tds__GetCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCACertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetCACertificates *p;
	size_t k = sizeof(struct __tds__GetCACertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetCACertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetCACertificates);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetCACertificates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetCACertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCACertificates(struct soap *soap, const struct __tds__GetCACertificates *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCACertificates(soap, tag ? tag : "-tds:GetCACertificates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCACertificates * SOAP_FMAC4 soap_get___tds__GetCACertificates(struct soap *soap, struct __tds__GetCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SendAuxiliaryCommand(struct soap *soap, struct __tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SendAuxiliaryCommand = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SendAuxiliaryCommand(struct soap *soap, const struct __tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SendAuxiliaryCommand(soap, &a->tds__SendAuxiliaryCommand);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct __tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, "tds:SendAuxiliaryCommand", -1, &a->tds__SendAuxiliaryCommand, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in___tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct __tds__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_tds__SendAuxiliaryCommand = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SendAuxiliaryCommand*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SendAuxiliaryCommand, sizeof(struct __tds__SendAuxiliaryCommand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SendAuxiliaryCommand(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SendAuxiliaryCommand && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, "tds:SendAuxiliaryCommand", &a->tds__SendAuxiliaryCommand, ""))
				{	soap_flag_tds__SendAuxiliaryCommand--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tds__SendAuxiliaryCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SendAuxiliaryCommand(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SendAuxiliaryCommand *p;
	size_t k = sizeof(struct __tds__SendAuxiliaryCommand);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SendAuxiliaryCommand, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SendAuxiliaryCommand);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SendAuxiliaryCommand, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SendAuxiliaryCommand location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SendAuxiliaryCommand(struct soap *soap, const struct __tds__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	if (soap_out___tds__SendAuxiliaryCommand(soap, tag ? tag : "-tds:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get___tds__SendAuxiliaryCommand(struct soap *soap, struct __tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRelayOutputState(struct soap *soap, struct __tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRelayOutputState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRelayOutputState(struct soap *soap, const struct __tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRelayOutputState(soap, &a->tds__SetRelayOutputState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const struct __tds__SetRelayOutputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRelayOutputState(soap, "tds:SetRelayOutputState", -1, &a->tds__SetRelayOutputState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputState * SOAP_FMAC4 soap_in___tds__SetRelayOutputState(struct soap *soap, const char *tag, struct __tds__SetRelayOutputState *a, const char *type)
{
	size_t soap_flag_tds__SetRelayOutputState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRelayOutputState*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRelayOutputState, sizeof(struct __tds__SetRelayOutputState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRelayOutputState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRelayOutputState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetRelayOutputState(soap, "tds:SetRelayOutputState", &a->tds__SetRelayOutputState, ""))
				{	soap_flag_tds__SetRelayOutputState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRelayOutputState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetRelayOutputState *p;
	size_t k = sizeof(struct __tds__SetRelayOutputState);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetRelayOutputState, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetRelayOutputState);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetRelayOutputState, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetRelayOutputState location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRelayOutputState(struct soap *soap, const struct __tds__SetRelayOutputState *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRelayOutputState(soap, tag ? tag : "-tds:SetRelayOutputState", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputState * SOAP_FMAC4 soap_get___tds__SetRelayOutputState(struct soap *soap, struct __tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRelayOutputSettings(struct soap *soap, struct __tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRelayOutputSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRelayOutputSettings(struct soap *soap, const struct __tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRelayOutputSettings(soap, &a->tds__SetRelayOutputSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const struct __tds__SetRelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRelayOutputSettings(soap, "tds:SetRelayOutputSettings", -1, &a->tds__SetRelayOutputSettings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in___tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct __tds__SetRelayOutputSettings *a, const char *type)
{
	size_t soap_flag_tds__SetRelayOutputSettings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRelayOutputSettings*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRelayOutputSettings, sizeof(struct __tds__SetRelayOutputSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRelayOutputSettings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRelayOutputSettings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetRelayOutputSettings(soap, "tds:SetRelayOutputSettings", &a->tds__SetRelayOutputSettings, ""))
				{	soap_flag_tds__SetRelayOutputSettings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRelayOutputSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetRelayOutputSettings *p;
	size_t k = sizeof(struct __tds__SetRelayOutputSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetRelayOutputSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetRelayOutputSettings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetRelayOutputSettings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetRelayOutputSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRelayOutputSettings(struct soap *soap, const struct __tds__SetRelayOutputSettings *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRelayOutputSettings(soap, tag ? tag : "-tds:SetRelayOutputSettings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get___tds__SetRelayOutputSettings(struct soap *soap, struct __tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRelayOutputs(struct soap *soap, struct __tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRelayOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRelayOutputs(struct soap *soap, const struct __tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetRelayOutputs(soap, &a->tds__GetRelayOutputs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const struct __tds__GetRelayOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetRelayOutputs(soap, "tds:GetRelayOutputs", -1, &a->tds__GetRelayOutputs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRelayOutputs * SOAP_FMAC4 soap_in___tds__GetRelayOutputs(struct soap *soap, const char *tag, struct __tds__GetRelayOutputs *a, const char *type)
{
	size_t soap_flag_tds__GetRelayOutputs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetRelayOutputs*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRelayOutputs, sizeof(struct __tds__GetRelayOutputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRelayOutputs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRelayOutputs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetRelayOutputs(soap, "tds:GetRelayOutputs", &a->tds__GetRelayOutputs, ""))
				{	soap_flag_tds__GetRelayOutputs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tds__GetRelayOutputs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetRelayOutputs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetRelayOutputs *p;
	size_t k = sizeof(struct __tds__GetRelayOutputs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetRelayOutputs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetRelayOutputs);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetRelayOutputs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetRelayOutputs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRelayOutputs(struct soap *soap, const struct __tds__GetRelayOutputs *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetRelayOutputs(soap, tag ? tag : "-tds:GetRelayOutputs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRelayOutputs * SOAP_FMAC4 soap_get___tds__GetRelayOutputs(struct soap *soap, struct __tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetClientCertificateMode(struct soap *soap, struct __tds__SetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetClientCertificateMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetClientCertificateMode(struct soap *soap, const struct __tds__SetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetClientCertificateMode(soap, &a->tds__SetClientCertificateMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct __tds__SetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetClientCertificateMode(soap, "tds:SetClientCertificateMode", -1, &a->tds__SetClientCertificateMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetClientCertificateMode * SOAP_FMAC4 soap_in___tds__SetClientCertificateMode(struct soap *soap, const char *tag, struct __tds__SetClientCertificateMode *a, const char *type)
{
	size_t soap_flag_tds__SetClientCertificateMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetClientCertificateMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetClientCertificateMode, sizeof(struct __tds__SetClientCertificateMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetClientCertificateMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetClientCertificateMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetClientCertificateMode(soap, "tds:SetClientCertificateMode", &a->tds__SetClientCertificateMode, ""))
				{	soap_flag_tds__SetClientCertificateMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__SetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetClientCertificateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetClientCertificateMode *p;
	size_t k = sizeof(struct __tds__SetClientCertificateMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetClientCertificateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetClientCertificateMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetClientCertificateMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetClientCertificateMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetClientCertificateMode(struct soap *soap, const struct __tds__SetClientCertificateMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetClientCertificateMode(soap, tag ? tag : "-tds:SetClientCertificateMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetClientCertificateMode * SOAP_FMAC4 soap_get___tds__SetClientCertificateMode(struct soap *soap, struct __tds__SetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetClientCertificateMode(struct soap *soap, struct __tds__GetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetClientCertificateMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetClientCertificateMode(struct soap *soap, const struct __tds__GetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetClientCertificateMode(soap, &a->tds__GetClientCertificateMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct __tds__GetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetClientCertificateMode(soap, "tds:GetClientCertificateMode", -1, &a->tds__GetClientCertificateMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetClientCertificateMode * SOAP_FMAC4 soap_in___tds__GetClientCertificateMode(struct soap *soap, const char *tag, struct __tds__GetClientCertificateMode *a, const char *type)
{
	size_t soap_flag_tds__GetClientCertificateMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetClientCertificateMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetClientCertificateMode, sizeof(struct __tds__GetClientCertificateMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetClientCertificateMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetClientCertificateMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetClientCertificateMode(soap, "tds:GetClientCertificateMode", &a->tds__GetClientCertificateMode, ""))
				{	soap_flag_tds__GetClientCertificateMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__GetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetClientCertificateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetClientCertificateMode *p;
	size_t k = sizeof(struct __tds__GetClientCertificateMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetClientCertificateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetClientCertificateMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetClientCertificateMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetClientCertificateMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetClientCertificateMode(struct soap *soap, const struct __tds__GetClientCertificateMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetClientCertificateMode(soap, tag ? tag : "-tds:GetClientCertificateMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetClientCertificateMode * SOAP_FMAC4 soap_get___tds__GetClientCertificateMode(struct soap *soap, struct __tds__GetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__LoadCertificates(struct soap *soap, struct __tds__LoadCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__LoadCertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__LoadCertificates(struct soap *soap, const struct __tds__LoadCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__LoadCertificates(soap, &a->tds__LoadCertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__LoadCertificates(struct soap *soap, const char *tag, int id, const struct __tds__LoadCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__LoadCertificates(soap, "tds:LoadCertificates", -1, &a->tds__LoadCertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificates * SOAP_FMAC4 soap_in___tds__LoadCertificates(struct soap *soap, const char *tag, struct __tds__LoadCertificates *a, const char *type)
{
	size_t soap_flag_tds__LoadCertificates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__LoadCertificates*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__LoadCertificates, sizeof(struct __tds__LoadCertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__LoadCertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__LoadCertificates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__LoadCertificates(soap, "tds:LoadCertificates", &a->tds__LoadCertificates, ""))
				{	soap_flag_tds__LoadCertificates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__LoadCertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__LoadCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__LoadCertificates *p;
	size_t k = sizeof(struct __tds__LoadCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__LoadCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__LoadCertificates);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__LoadCertificates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__LoadCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__LoadCertificates(struct soap *soap, const struct __tds__LoadCertificates *a, const char *tag, const char *type)
{
	if (soap_out___tds__LoadCertificates(soap, tag ? tag : "-tds:LoadCertificates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificates * SOAP_FMAC4 soap_get___tds__LoadCertificates(struct soap *soap, struct __tds__LoadCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetPkcs10Request(struct soap *soap, struct __tds__GetPkcs10Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetPkcs10Request = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetPkcs10Request(struct soap *soap, const struct __tds__GetPkcs10Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetPkcs10Request(soap, &a->tds__GetPkcs10Request);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, const struct __tds__GetPkcs10Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetPkcs10Request(soap, "tds:GetPkcs10Request", -1, &a->tds__GetPkcs10Request, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPkcs10Request * SOAP_FMAC4 soap_in___tds__GetPkcs10Request(struct soap *soap, const char *tag, struct __tds__GetPkcs10Request *a, const char *type)
{
	size_t soap_flag_tds__GetPkcs10Request = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetPkcs10Request*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetPkcs10Request, sizeof(struct __tds__GetPkcs10Request), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetPkcs10Request(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetPkcs10Request && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetPkcs10Request(soap, "tds:GetPkcs10Request", &a->tds__GetPkcs10Request, ""))
				{	soap_flag_tds__GetPkcs10Request--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate___tds__GetPkcs10Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetPkcs10Request(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetPkcs10Request *p;
	size_t k = sizeof(struct __tds__GetPkcs10Request);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetPkcs10Request, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetPkcs10Request);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetPkcs10Request, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetPkcs10Request location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetPkcs10Request(struct soap *soap, const struct __tds__GetPkcs10Request *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetPkcs10Request(soap, tag ? tag : "-tds:GetPkcs10Request", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPkcs10Request * SOAP_FMAC4 soap_get___tds__GetPkcs10Request(struct soap *soap, struct __tds__GetPkcs10Request *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteCertificates(struct soap *soap, struct __tds__DeleteCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteCertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteCertificates(struct soap *soap, const struct __tds__DeleteCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteCertificates(soap, &a->tds__DeleteCertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteCertificates(struct soap *soap, const char *tag, int id, const struct __tds__DeleteCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteCertificates(soap, "tds:DeleteCertificates", -1, &a->tds__DeleteCertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteCertificates * SOAP_FMAC4 soap_in___tds__DeleteCertificates(struct soap *soap, const char *tag, struct __tds__DeleteCertificates *a, const char *type)
{
	size_t soap_flag_tds__DeleteCertificates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteCertificates*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteCertificates, sizeof(struct __tds__DeleteCertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteCertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteCertificates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteCertificates(soap, "tds:DeleteCertificates", &a->tds__DeleteCertificates, ""))
				{	soap_flag_tds__DeleteCertificates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate___tds__DeleteCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__DeleteCertificates *p;
	size_t k = sizeof(struct __tds__DeleteCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__DeleteCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__DeleteCertificates);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__DeleteCertificates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__DeleteCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteCertificates(struct soap *soap, const struct __tds__DeleteCertificates *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteCertificates(soap, tag ? tag : "-tds:DeleteCertificates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteCertificates * SOAP_FMAC4 soap_get___tds__DeleteCertificates(struct soap *soap, struct __tds__DeleteCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetCertificatesStatus(struct soap *soap, struct __tds__SetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetCertificatesStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetCertificatesStatus(struct soap *soap, const struct __tds__SetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetCertificatesStatus(soap, &a->tds__SetCertificatesStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct __tds__SetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetCertificatesStatus(soap, "tds:SetCertificatesStatus", -1, &a->tds__SetCertificatesStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetCertificatesStatus * SOAP_FMAC4 soap_in___tds__SetCertificatesStatus(struct soap *soap, const char *tag, struct __tds__SetCertificatesStatus *a, const char *type)
{
	size_t soap_flag_tds__SetCertificatesStatus = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetCertificatesStatus*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetCertificatesStatus, sizeof(struct __tds__SetCertificatesStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetCertificatesStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetCertificatesStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetCertificatesStatus(soap, "tds:SetCertificatesStatus", &a->tds__SetCertificatesStatus, ""))
				{	soap_flag_tds__SetCertificatesStatus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__SetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetCertificatesStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetCertificatesStatus *p;
	size_t k = sizeof(struct __tds__SetCertificatesStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetCertificatesStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetCertificatesStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetCertificatesStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetCertificatesStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetCertificatesStatus(struct soap *soap, const struct __tds__SetCertificatesStatus *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetCertificatesStatus(soap, tag ? tag : "-tds:SetCertificatesStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetCertificatesStatus * SOAP_FMAC4 soap_get___tds__SetCertificatesStatus(struct soap *soap, struct __tds__SetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCertificatesStatus(struct soap *soap, struct __tds__GetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCertificatesStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCertificatesStatus(struct soap *soap, const struct __tds__GetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCertificatesStatus(soap, &a->tds__GetCertificatesStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct __tds__GetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCertificatesStatus(soap, "tds:GetCertificatesStatus", -1, &a->tds__GetCertificatesStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificatesStatus * SOAP_FMAC4 soap_in___tds__GetCertificatesStatus(struct soap *soap, const char *tag, struct __tds__GetCertificatesStatus *a, const char *type)
{
	size_t soap_flag_tds__GetCertificatesStatus = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCertificatesStatus*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCertificatesStatus, sizeof(struct __tds__GetCertificatesStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCertificatesStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCertificatesStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCertificatesStatus(soap, "tds:GetCertificatesStatus", &a->tds__GetCertificatesStatus, ""))
				{	soap_flag_tds__GetCertificatesStatus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__GetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCertificatesStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetCertificatesStatus *p;
	size_t k = sizeof(struct __tds__GetCertificatesStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetCertificatesStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetCertificatesStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetCertificatesStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetCertificatesStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCertificatesStatus(struct soap *soap, const struct __tds__GetCertificatesStatus *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCertificatesStatus(soap, tag ? tag : "-tds:GetCertificatesStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificatesStatus * SOAP_FMAC4 soap_get___tds__GetCertificatesStatus(struct soap *soap, struct __tds__GetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCertificates(struct soap *soap, struct __tds__GetCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCertificates(struct soap *soap, const struct __tds__GetCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCertificates(soap, &a->tds__GetCertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCertificates(struct soap *soap, const char *tag, int id, const struct __tds__GetCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCertificates(soap, "tds:GetCertificates", -1, &a->tds__GetCertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificates * SOAP_FMAC4 soap_in___tds__GetCertificates(struct soap *soap, const char *tag, struct __tds__GetCertificates *a, const char *type)
{
	size_t soap_flag_tds__GetCertificates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCertificates*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCertificates, sizeof(struct __tds__GetCertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCertificates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCertificates(soap, "tds:GetCertificates", &a->tds__GetCertificates, ""))
				{	soap_flag_tds__GetCertificates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetCertificates * SOAP_FMAC2 soap_instantiate___tds__GetCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetCertificates *p;
	size_t k = sizeof(struct __tds__GetCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetCertificates);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetCertificates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCertificates(struct soap *soap, const struct __tds__GetCertificates *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCertificates(soap, tag ? tag : "-tds:GetCertificates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificates * SOAP_FMAC4 soap_get___tds__GetCertificates(struct soap *soap, struct __tds__GetCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateCertificate(struct soap *soap, struct __tds__CreateCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateCertificate(struct soap *soap, const struct __tds__CreateCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__CreateCertificate(soap, &a->tds__CreateCertificate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateCertificate(struct soap *soap, const char *tag, int id, const struct __tds__CreateCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__CreateCertificate(soap, "tds:CreateCertificate", -1, &a->tds__CreateCertificate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateCertificate * SOAP_FMAC4 soap_in___tds__CreateCertificate(struct soap *soap, const char *tag, struct __tds__CreateCertificate *a, const char *type)
{
	size_t soap_flag_tds__CreateCertificate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__CreateCertificate*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateCertificate, sizeof(struct __tds__CreateCertificate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateCertificate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateCertificate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__CreateCertificate(soap, "tds:CreateCertificate", &a->tds__CreateCertificate, ""))
				{	soap_flag_tds__CreateCertificate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__CreateCertificate * SOAP_FMAC2 soap_instantiate___tds__CreateCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateCertificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__CreateCertificate *p;
	size_t k = sizeof(struct __tds__CreateCertificate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__CreateCertificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__CreateCertificate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__CreateCertificate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__CreateCertificate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateCertificate(struct soap *soap, const struct __tds__CreateCertificate *a, const char *tag, const char *type)
{
	if (soap_out___tds__CreateCertificate(soap, tag ? tag : "-tds:CreateCertificate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateCertificate * SOAP_FMAC4 soap_get___tds__CreateCertificate(struct soap *soap, struct __tds__CreateCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetAccessPolicy(struct soap *soap, struct __tds__SetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetAccessPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetAccessPolicy(struct soap *soap, const struct __tds__SetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetAccessPolicy(soap, &a->tds__SetAccessPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, const struct __tds__SetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetAccessPolicy(soap, "tds:SetAccessPolicy", -1, &a->tds__SetAccessPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetAccessPolicy * SOAP_FMAC4 soap_in___tds__SetAccessPolicy(struct soap *soap, const char *tag, struct __tds__SetAccessPolicy *a, const char *type)
{
	size_t soap_flag_tds__SetAccessPolicy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetAccessPolicy*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetAccessPolicy, sizeof(struct __tds__SetAccessPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetAccessPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetAccessPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetAccessPolicy(soap, "tds:SetAccessPolicy", &a->tds__SetAccessPolicy, ""))
				{	soap_flag_tds__SetAccessPolicy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__SetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetAccessPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetAccessPolicy *p;
	size_t k = sizeof(struct __tds__SetAccessPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetAccessPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetAccessPolicy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetAccessPolicy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetAccessPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetAccessPolicy(struct soap *soap, const struct __tds__SetAccessPolicy *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetAccessPolicy(soap, tag ? tag : "-tds:SetAccessPolicy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetAccessPolicy * SOAP_FMAC4 soap_get___tds__SetAccessPolicy(struct soap *soap, struct __tds__SetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetAccessPolicy(struct soap *soap, struct __tds__GetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetAccessPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetAccessPolicy(struct soap *soap, const struct __tds__GetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetAccessPolicy(soap, &a->tds__GetAccessPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, const struct __tds__GetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetAccessPolicy(soap, "tds:GetAccessPolicy", -1, &a->tds__GetAccessPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAccessPolicy * SOAP_FMAC4 soap_in___tds__GetAccessPolicy(struct soap *soap, const char *tag, struct __tds__GetAccessPolicy *a, const char *type)
{
	size_t soap_flag_tds__GetAccessPolicy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetAccessPolicy*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetAccessPolicy, sizeof(struct __tds__GetAccessPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetAccessPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetAccessPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetAccessPolicy(soap, "tds:GetAccessPolicy", &a->tds__GetAccessPolicy, ""))
				{	soap_flag_tds__GetAccessPolicy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__GetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetAccessPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetAccessPolicy *p;
	size_t k = sizeof(struct __tds__GetAccessPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetAccessPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetAccessPolicy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetAccessPolicy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetAccessPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetAccessPolicy(struct soap *soap, const struct __tds__GetAccessPolicy *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetAccessPolicy(soap, tag ? tag : "-tds:GetAccessPolicy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAccessPolicy * SOAP_FMAC4 soap_get___tds__GetAccessPolicy(struct soap *soap, struct __tds__GetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RemoveIPAddressFilter(struct soap *soap, struct __tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RemoveIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RemoveIPAddressFilter(struct soap *soap, const struct __tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__RemoveIPAddressFilter(soap, &a->tds__RemoveIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, "tds:RemoveIPAddressFilter", -1, &a->tds__RemoveIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in___tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, struct __tds__RemoveIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__RemoveIPAddressFilter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__RemoveIPAddressFilter*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RemoveIPAddressFilter, sizeof(struct __tds__RemoveIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RemoveIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RemoveIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, "tds:RemoveIPAddressFilter", &a->tds__RemoveIPAddressFilter, ""))
				{	soap_flag_tds__RemoveIPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__RemoveIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__RemoveIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__RemoveIPAddressFilter *p;
	size_t k = sizeof(struct __tds__RemoveIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__RemoveIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__RemoveIPAddressFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__RemoveIPAddressFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__RemoveIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RemoveIPAddressFilter(struct soap *soap, const struct __tds__RemoveIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out___tds__RemoveIPAddressFilter(soap, tag ? tag : "-tds:RemoveIPAddressFilter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get___tds__RemoveIPAddressFilter(struct soap *soap, struct __tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__AddIPAddressFilter(struct soap *soap, struct __tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__AddIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__AddIPAddressFilter(struct soap *soap, const struct __tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__AddIPAddressFilter(soap, &a->tds__AddIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__AddIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__AddIPAddressFilter(soap, "tds:AddIPAddressFilter", -1, &a->tds__AddIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddIPAddressFilter * SOAP_FMAC4 soap_in___tds__AddIPAddressFilter(struct soap *soap, const char *tag, struct __tds__AddIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__AddIPAddressFilter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__AddIPAddressFilter*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__AddIPAddressFilter, sizeof(struct __tds__AddIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__AddIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__AddIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__AddIPAddressFilter(soap, "tds:AddIPAddressFilter", &a->tds__AddIPAddressFilter, ""))
				{	soap_flag_tds__AddIPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__AddIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__AddIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__AddIPAddressFilter *p;
	size_t k = sizeof(struct __tds__AddIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__AddIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__AddIPAddressFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__AddIPAddressFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__AddIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__AddIPAddressFilter(struct soap *soap, const struct __tds__AddIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out___tds__AddIPAddressFilter(soap, tag ? tag : "-tds:AddIPAddressFilter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddIPAddressFilter * SOAP_FMAC4 soap_get___tds__AddIPAddressFilter(struct soap *soap, struct __tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetIPAddressFilter(struct soap *soap, struct __tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetIPAddressFilter(struct soap *soap, const struct __tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetIPAddressFilter(soap, &a->tds__SetIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__SetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetIPAddressFilter(soap, "tds:SetIPAddressFilter", -1, &a->tds__SetIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetIPAddressFilter * SOAP_FMAC4 soap_in___tds__SetIPAddressFilter(struct soap *soap, const char *tag, struct __tds__SetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__SetIPAddressFilter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetIPAddressFilter*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetIPAddressFilter, sizeof(struct __tds__SetIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetIPAddressFilter(soap, "tds:SetIPAddressFilter", &a->tds__SetIPAddressFilter, ""))
				{	soap_flag_tds__SetIPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__SetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetIPAddressFilter *p;
	size_t k = sizeof(struct __tds__SetIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetIPAddressFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetIPAddressFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetIPAddressFilter(struct soap *soap, const struct __tds__SetIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetIPAddressFilter(soap, tag ? tag : "-tds:SetIPAddressFilter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetIPAddressFilter * SOAP_FMAC4 soap_get___tds__SetIPAddressFilter(struct soap *soap, struct __tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetIPAddressFilter(struct soap *soap, struct __tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetIPAddressFilter(struct soap *soap, const struct __tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetIPAddressFilter(soap, &a->tds__GetIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__GetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetIPAddressFilter(soap, "tds:GetIPAddressFilter", -1, &a->tds__GetIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetIPAddressFilter * SOAP_FMAC4 soap_in___tds__GetIPAddressFilter(struct soap *soap, const char *tag, struct __tds__GetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__GetIPAddressFilter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetIPAddressFilter*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetIPAddressFilter, sizeof(struct __tds__GetIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetIPAddressFilter(soap, "tds:GetIPAddressFilter", &a->tds__GetIPAddressFilter, ""))
				{	soap_flag_tds__GetIPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__GetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetIPAddressFilter *p;
	size_t k = sizeof(struct __tds__GetIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetIPAddressFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetIPAddressFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetIPAddressFilter(struct soap *soap, const struct __tds__GetIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetIPAddressFilter(soap, tag ? tag : "-tds:GetIPAddressFilter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetIPAddressFilter * SOAP_FMAC4 soap_get___tds__GetIPAddressFilter(struct soap *soap, struct __tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetZeroConfiguration(struct soap *soap, struct __tds__SetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetZeroConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetZeroConfiguration(struct soap *soap, const struct __tds__SetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetZeroConfiguration(soap, &a->tds__SetZeroConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetZeroConfiguration(soap, "tds:SetZeroConfiguration", -1, &a->tds__SetZeroConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetZeroConfiguration * SOAP_FMAC4 soap_in___tds__SetZeroConfiguration(struct soap *soap, const char *tag, struct __tds__SetZeroConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetZeroConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetZeroConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetZeroConfiguration, sizeof(struct __tds__SetZeroConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetZeroConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetZeroConfiguration(soap, "tds:SetZeroConfiguration", &a->tds__SetZeroConfiguration, ""))
				{	soap_flag_tds__SetZeroConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetZeroConfiguration *p;
	size_t k = sizeof(struct __tds__SetZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetZeroConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetZeroConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetZeroConfiguration(struct soap *soap, const struct __tds__SetZeroConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetZeroConfiguration(soap, tag ? tag : "-tds:SetZeroConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetZeroConfiguration * SOAP_FMAC4 soap_get___tds__SetZeroConfiguration(struct soap *soap, struct __tds__SetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetZeroConfiguration(struct soap *soap, struct __tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetZeroConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetZeroConfiguration(struct soap *soap, const struct __tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetZeroConfiguration(soap, &a->tds__GetZeroConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetZeroConfiguration(soap, "tds:GetZeroConfiguration", -1, &a->tds__GetZeroConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetZeroConfiguration * SOAP_FMAC4 soap_in___tds__GetZeroConfiguration(struct soap *soap, const char *tag, struct __tds__GetZeroConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetZeroConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetZeroConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetZeroConfiguration, sizeof(struct __tds__GetZeroConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetZeroConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetZeroConfiguration(soap, "tds:GetZeroConfiguration", &a->tds__GetZeroConfiguration, ""))
				{	soap_flag_tds__GetZeroConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetZeroConfiguration *p;
	size_t k = sizeof(struct __tds__GetZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetZeroConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetZeroConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetZeroConfiguration(struct soap *soap, const struct __tds__GetZeroConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetZeroConfiguration(soap, tag ? tag : "-tds:GetZeroConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetZeroConfiguration * SOAP_FMAC4 soap_get___tds__GetZeroConfiguration(struct soap *soap, struct __tds__GetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkDefaultGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkDefaultGateway(struct soap *soap, const struct __tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(soap, &a->tds__SetNetworkDefaultGateway);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, "tds:SetNetworkDefaultGateway", -1, &a->tds__SetNetworkDefaultGateway, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in___tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct __tds__SetNetworkDefaultGateway *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkDefaultGateway = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNetworkDefaultGateway*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkDefaultGateway, sizeof(struct __tds__SetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkDefaultGateway(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, "tds:SetNetworkDefaultGateway", &a->tds__SetNetworkDefaultGateway, ""))
				{	soap_flag_tds__SetNetworkDefaultGateway--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__SetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNetworkDefaultGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetNetworkDefaultGateway *p;
	size_t k = sizeof(struct __tds__SetNetworkDefaultGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetNetworkDefaultGateway);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetNetworkDefaultGateway, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetNetworkDefaultGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkDefaultGateway(struct soap *soap, const struct __tds__SetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNetworkDefaultGateway(soap, tag ? tag : "-tds:SetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkDefaultGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkDefaultGateway(struct soap *soap, const struct __tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(soap, &a->tds__GetNetworkDefaultGateway);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, "tds:GetNetworkDefaultGateway", -1, &a->tds__GetNetworkDefaultGateway, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in___tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct __tds__GetNetworkDefaultGateway *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkDefaultGateway = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNetworkDefaultGateway*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkDefaultGateway, sizeof(struct __tds__GetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkDefaultGateway(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, "tds:GetNetworkDefaultGateway", &a->tds__GetNetworkDefaultGateway, ""))
				{	soap_flag_tds__GetNetworkDefaultGateway--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__GetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNetworkDefaultGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetNetworkDefaultGateway *p;
	size_t k = sizeof(struct __tds__GetNetworkDefaultGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetNetworkDefaultGateway);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetNetworkDefaultGateway, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetNetworkDefaultGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkDefaultGateway(struct soap *soap, const struct __tds__GetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNetworkDefaultGateway(soap, tag ? tag : "-tds:GetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkProtocols(struct soap *soap, const struct __tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNetworkProtocols(soap, &a->tds__SetNetworkProtocols);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, "tds:SetNetworkProtocols", -1, &a->tds__SetNetworkProtocols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_in___tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct __tds__SetNetworkProtocols *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkProtocols = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNetworkProtocols*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkProtocols, sizeof(struct __tds__SetNetworkProtocols), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkProtocols(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNetworkProtocols(soap, "tds:SetNetworkProtocols", &a->tds__SetNetworkProtocols, ""))
				{	soap_flag_tds__SetNetworkProtocols--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__SetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNetworkProtocols(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetNetworkProtocols *p;
	size_t k = sizeof(struct __tds__SetNetworkProtocols);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetNetworkProtocols, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetNetworkProtocols);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetNetworkProtocols, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetNetworkProtocols location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkProtocols(struct soap *soap, const struct __tds__SetNetworkProtocols *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNetworkProtocols(soap, tag ? tag : "-tds:SetNetworkProtocols", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_get___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkProtocols(struct soap *soap, const struct __tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNetworkProtocols(soap, &a->tds__GetNetworkProtocols);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, "tds:GetNetworkProtocols", -1, &a->tds__GetNetworkProtocols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_in___tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct __tds__GetNetworkProtocols *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkProtocols = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNetworkProtocols*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkProtocols, sizeof(struct __tds__GetNetworkProtocols), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkProtocols(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNetworkProtocols(soap, "tds:GetNetworkProtocols", &a->tds__GetNetworkProtocols, ""))
				{	soap_flag_tds__GetNetworkProtocols--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__GetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNetworkProtocols(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetNetworkProtocols *p;
	size_t k = sizeof(struct __tds__GetNetworkProtocols);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetNetworkProtocols, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetNetworkProtocols);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetNetworkProtocols, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetNetworkProtocols location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkProtocols(struct soap *soap, const struct __tds__GetNetworkProtocols *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNetworkProtocols(soap, tag ? tag : "-tds:GetNetworkProtocols", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_get___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkInterfaces(struct soap *soap, const struct __tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNetworkInterfaces(soap, &a->tds__SetNetworkInterfaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, "tds:SetNetworkInterfaces", -1, &a->tds__SetNetworkInterfaces, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in___tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct __tds__SetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkInterfaces = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNetworkInterfaces*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkInterfaces, sizeof(struct __tds__SetNetworkInterfaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkInterfaces(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNetworkInterfaces(soap, "tds:SetNetworkInterfaces", &a->tds__SetNetworkInterfaces, ""))
				{	soap_flag_tds__SetNetworkInterfaces--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__SetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNetworkInterfaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetNetworkInterfaces *p;
	size_t k = sizeof(struct __tds__SetNetworkInterfaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetNetworkInterfaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetNetworkInterfaces);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetNetworkInterfaces, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetNetworkInterfaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkInterfaces(struct soap *soap, const struct __tds__SetNetworkInterfaces *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNetworkInterfaces(soap, tag ? tag : "-tds:SetNetworkInterfaces", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkInterfaces(struct soap *soap, const struct __tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNetworkInterfaces(soap, &a->tds__GetNetworkInterfaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, "tds:GetNetworkInterfaces", -1, &a->tds__GetNetworkInterfaces, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in___tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct __tds__GetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkInterfaces = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNetworkInterfaces*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkInterfaces, sizeof(struct __tds__GetNetworkInterfaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkInterfaces(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNetworkInterfaces(soap, "tds:GetNetworkInterfaces", &a->tds__GetNetworkInterfaces, ""))
				{	soap_flag_tds__GetNetworkInterfaces--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__GetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNetworkInterfaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetNetworkInterfaces *p;
	size_t k = sizeof(struct __tds__GetNetworkInterfaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetNetworkInterfaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetNetworkInterfaces);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetNetworkInterfaces, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetNetworkInterfaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkInterfaces(struct soap *soap, const struct __tds__GetNetworkInterfaces *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNetworkInterfaces(soap, tag ? tag : "-tds:GetNetworkInterfaces", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDynamicDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDynamicDNS(struct soap *soap, const struct __tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDynamicDNS(soap, &a->tds__SetDynamicDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const struct __tds__SetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, "tds:SetDynamicDNS", -1, &a->tds__SetDynamicDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_in___tds__SetDynamicDNS(struct soap *soap, const char *tag, struct __tds__SetDynamicDNS *a, const char *type)
{
	size_t soap_flag_tds__SetDynamicDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDynamicDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDynamicDNS, sizeof(struct __tds__SetDynamicDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDynamicDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDynamicDNS(soap, "tds:SetDynamicDNS", &a->tds__SetDynamicDNS, ""))
				{	soap_flag_tds__SetDynamicDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__SetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDynamicDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetDynamicDNS *p;
	size_t k = sizeof(struct __tds__SetDynamicDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetDynamicDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetDynamicDNS);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetDynamicDNS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetDynamicDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDynamicDNS(struct soap *soap, const struct __tds__SetDynamicDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDynamicDNS(soap, tag ? tag : "-tds:SetDynamicDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_get___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDynamicDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDynamicDNS(struct soap *soap, const struct __tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDynamicDNS(soap, &a->tds__GetDynamicDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, "tds:GetDynamicDNS", -1, &a->tds__GetDynamicDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_in___tds__GetDynamicDNS(struct soap *soap, const char *tag, struct __tds__GetDynamicDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDynamicDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDynamicDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDynamicDNS, sizeof(struct __tds__GetDynamicDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDynamicDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDynamicDNS(soap, "tds:GetDynamicDNS", &a->tds__GetDynamicDNS, ""))
				{	soap_flag_tds__GetDynamicDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__GetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDynamicDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDynamicDNS *p;
	size_t k = sizeof(struct __tds__GetDynamicDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDynamicDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDynamicDNS);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDynamicDNS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDynamicDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDynamicDNS(struct soap *soap, const struct __tds__GetDynamicDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDynamicDNS(soap, tag ? tag : "-tds:GetDynamicDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_get___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNTP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNTP(struct soap *soap, const struct __tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNTP(soap, &a->tds__SetNTP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNTP(struct soap *soap, const char *tag, int id, const struct __tds__SetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNTP(soap, "tds:SetNTP", -1, &a->tds__SetNTP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_in___tds__SetNTP(struct soap *soap, const char *tag, struct __tds__SetNTP *a, const char *type)
{
	size_t soap_flag_tds__SetNTP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNTP*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNTP, sizeof(struct __tds__SetNTP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNTP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNTP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNTP(soap, "tds:SetNTP", &a->tds__SetNTP, ""))
				{	soap_flag_tds__SetNTP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetNTP * SOAP_FMAC2 soap_instantiate___tds__SetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNTP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetNTP *p;
	size_t k = sizeof(struct __tds__SetNTP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetNTP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetNTP);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetNTP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetNTP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNTP(struct soap *soap, const struct __tds__SetNTP *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNTP(soap, tag ? tag : "-tds:SetNTP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_get___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNTP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNTP(struct soap *soap, const struct __tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNTP(soap, &a->tds__GetNTP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNTP(struct soap *soap, const char *tag, int id, const struct __tds__GetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNTP(soap, "tds:GetNTP", -1, &a->tds__GetNTP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_in___tds__GetNTP(struct soap *soap, const char *tag, struct __tds__GetNTP *a, const char *type)
{
	size_t soap_flag_tds__GetNTP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNTP*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNTP, sizeof(struct __tds__GetNTP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNTP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNTP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNTP(soap, "tds:GetNTP", &a->tds__GetNTP, ""))
				{	soap_flag_tds__GetNTP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetNTP * SOAP_FMAC2 soap_instantiate___tds__GetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNTP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetNTP *p;
	size_t k = sizeof(struct __tds__GetNTP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetNTP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetNTP);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetNTP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetNTP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNTP(struct soap *soap, const struct __tds__GetNTP *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNTP(soap, tag ? tag : "-tds:GetNTP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_get___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDNS(struct soap *soap, const struct __tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDNS(soap, &a->tds__SetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDNS(struct soap *soap, const char *tag, int id, const struct __tds__SetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDNS(soap, "tds:SetDNS", -1, &a->tds__SetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_in___tds__SetDNS(struct soap *soap, const char *tag, struct __tds__SetDNS *a, const char *type)
{
	size_t soap_flag_tds__SetDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDNS, sizeof(struct __tds__SetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDNS(soap, "tds:SetDNS", &a->tds__SetDNS, ""))
				{	soap_flag_tds__SetDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetDNS * SOAP_FMAC2 soap_instantiate___tds__SetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetDNS *p;
	size_t k = sizeof(struct __tds__SetDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetDNS);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetDNS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDNS(struct soap *soap, const struct __tds__SetDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDNS(soap, tag ? tag : "-tds:SetDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_get___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDNS(soap, &a->tds__GetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDNS(soap, "tds:GetDNS", -1, &a->tds__GetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_in___tds__GetDNS(struct soap *soap, const char *tag, struct __tds__GetDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDNS, sizeof(struct __tds__GetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDNS(soap, "tds:GetDNS", &a->tds__GetDNS, ""))
				{	soap_flag_tds__GetDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDNS * SOAP_FMAC2 soap_instantiate___tds__GetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDNS *p;
	size_t k = sizeof(struct __tds__GetDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDNS);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDNS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDNS(soap, tag ? tag : "-tds:GetDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_get___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostnameFromDHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetHostnameFromDHCP(soap, &a->tds__SetHostnameFromDHCP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", -1, &a->tds__SetHostnameFromDHCP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	size_t soap_flag_tds__SetHostnameFromDHCP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetHostnameFromDHCP*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostnameFromDHCP, sizeof(struct __tds__SetHostnameFromDHCP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHostnameFromDHCP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHostnameFromDHCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", &a->tds__SetHostnameFromDHCP, ""))
				{	soap_flag_tds__SetHostnameFromDHCP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate___tds__SetHostnameFromDHCP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetHostnameFromDHCP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetHostnameFromDHCP *p;
	size_t k = sizeof(struct __tds__SetHostnameFromDHCP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetHostnameFromDHCP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetHostnameFromDHCP);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetHostnameFromDHCP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetHostnameFromDHCP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetHostnameFromDHCP(soap, tag ? tag : "-tds:SetHostnameFromDHCP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetHostname(soap, &a->tds__SetHostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostname(struct soap *soap, const char *tag, int id, const struct __tds__SetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetHostname(soap, "tds:SetHostname", -1, &a->tds__SetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_in___tds__SetHostname(struct soap *soap, const char *tag, struct __tds__SetHostname *a, const char *type)
{
	size_t soap_flag_tds__SetHostname = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetHostname*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostname, sizeof(struct __tds__SetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHostname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHostname && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetHostname(soap, "tds:SetHostname", &a->tds__SetHostname, ""))
				{	soap_flag_tds__SetHostname--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetHostname * SOAP_FMAC2 soap_instantiate___tds__SetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetHostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetHostname *p;
	size_t k = sizeof(struct __tds__SetHostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetHostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetHostname);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetHostname, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetHostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetHostname(soap, tag ? tag : "-tds:SetHostname", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_get___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetHostname(soap, &a->tds__GetHostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetHostname(struct soap *soap, const char *tag, int id, const struct __tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetHostname(soap, "tds:GetHostname", -1, &a->tds__GetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_in___tds__GetHostname(struct soap *soap, const char *tag, struct __tds__GetHostname *a, const char *type)
{
	size_t soap_flag_tds__GetHostname = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetHostname*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetHostname, sizeof(struct __tds__GetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetHostname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetHostname && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetHostname(soap, "tds:GetHostname", &a->tds__GetHostname, ""))
				{	soap_flag_tds__GetHostname--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetHostname * SOAP_FMAC2 soap_instantiate___tds__GetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetHostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetHostname *p;
	size_t k = sizeof(struct __tds__GetHostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetHostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetHostname);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetHostname, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetHostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetHostname(soap, tag ? tag : "-tds:GetHostname", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_get___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDPAddresses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDPAddresses(struct soap *soap, const struct __tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDPAddresses(soap, &a->tds__SetDPAddresses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const struct __tds__SetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDPAddresses(soap, "tds:SetDPAddresses", -1, &a->tds__SetDPAddresses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_in___tds__SetDPAddresses(struct soap *soap, const char *tag, struct __tds__SetDPAddresses *a, const char *type)
{
	size_t soap_flag_tds__SetDPAddresses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDPAddresses*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDPAddresses, sizeof(struct __tds__SetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDPAddresses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDPAddresses(soap, "tds:SetDPAddresses", &a->tds__SetDPAddresses, ""))
				{	soap_flag_tds__SetDPAddresses--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__SetDPAddresses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDPAddresses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetDPAddresses *p;
	size_t k = sizeof(struct __tds__SetDPAddresses);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetDPAddresses, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetDPAddresses);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetDPAddresses, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetDPAddresses location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDPAddresses(struct soap *soap, const struct __tds__SetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDPAddresses(soap, tag ? tag : "-tds:SetDPAddresses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_get___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCapabilities(soap, &a->tds__GetCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", -1, &a->tds__GetCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_in___tds__GetCapabilities(struct soap *soap, const char *tag, struct __tds__GetCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCapabilities, sizeof(struct __tds__GetCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", &a->tds__GetCapabilities, ""))
				{	soap_flag_tds__GetCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetCapabilities *p;
	size_t k = sizeof(struct __tds__GetCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCapabilities(soap, tag ? tag : "-tds:GetCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_get___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetAuthFailureWarningConfiguration(struct soap *soap, struct __tds__SetAuthFailureWarningConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetAuthFailureWarningConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetAuthFailureWarningConfiguration(struct soap *soap, const struct __tds__SetAuthFailureWarningConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, &a->tds__SetAuthFailureWarningConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, "tds:SetAuthFailureWarningConfiguration", -1, &a->tds__SetAuthFailureWarningConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_in___tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, struct __tds__SetAuthFailureWarningConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetAuthFailureWarningConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetAuthFailureWarningConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetAuthFailureWarningConfiguration, sizeof(struct __tds__SetAuthFailureWarningConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetAuthFailureWarningConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetAuthFailureWarningConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, "tds:SetAuthFailureWarningConfiguration", &a->tds__SetAuthFailureWarningConfiguration, ""))
				{	soap_flag_tds__SetAuthFailureWarningConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetAuthFailureWarningConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetAuthFailureWarningConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetAuthFailureWarningConfiguration *p;
	size_t k = sizeof(struct __tds__SetAuthFailureWarningConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetAuthFailureWarningConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetAuthFailureWarningConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetAuthFailureWarningConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetAuthFailureWarningConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetAuthFailureWarningConfiguration(struct soap *soap, const struct __tds__SetAuthFailureWarningConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetAuthFailureWarningConfiguration(soap, tag ? tag : "-tds:SetAuthFailureWarningConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_get___tds__SetAuthFailureWarningConfiguration(struct soap *soap, struct __tds__SetAuthFailureWarningConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetAuthFailureWarningConfiguration(struct soap *soap, struct __tds__GetAuthFailureWarningConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetAuthFailureWarningConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetAuthFailureWarningConfiguration(struct soap *soap, const struct __tds__GetAuthFailureWarningConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, &a->tds__GetAuthFailureWarningConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, "tds:GetAuthFailureWarningConfiguration", -1, &a->tds__GetAuthFailureWarningConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_in___tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, struct __tds__GetAuthFailureWarningConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetAuthFailureWarningConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetAuthFailureWarningConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetAuthFailureWarningConfiguration, sizeof(struct __tds__GetAuthFailureWarningConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetAuthFailureWarningConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetAuthFailureWarningConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, "tds:GetAuthFailureWarningConfiguration", &a->tds__GetAuthFailureWarningConfiguration, ""))
				{	soap_flag_tds__GetAuthFailureWarningConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetAuthFailureWarningConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetAuthFailureWarningConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetAuthFailureWarningConfiguration *p;
	size_t k = sizeof(struct __tds__GetAuthFailureWarningConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetAuthFailureWarningConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetAuthFailureWarningConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetAuthFailureWarningConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetAuthFailureWarningConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetAuthFailureWarningConfiguration(struct soap *soap, const struct __tds__GetAuthFailureWarningConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetAuthFailureWarningConfiguration(soap, tag ? tag : "-tds:GetAuthFailureWarningConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_get___tds__GetAuthFailureWarningConfiguration(struct soap *soap, struct __tds__GetAuthFailureWarningConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetAuthFailureWarningOptions(struct soap *soap, struct __tds__GetAuthFailureWarningOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetAuthFailureWarningOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetAuthFailureWarningOptions(struct soap *soap, const struct __tds__GetAuthFailureWarningOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetAuthFailureWarningOptions(soap, &a->tds__GetAuthFailureWarningOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, int id, const struct __tds__GetAuthFailureWarningOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetAuthFailureWarningOptions(soap, "tds:GetAuthFailureWarningOptions", -1, &a->tds__GetAuthFailureWarningOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAuthFailureWarningOptions * SOAP_FMAC4 soap_in___tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, struct __tds__GetAuthFailureWarningOptions *a, const char *type)
{
	size_t soap_flag_tds__GetAuthFailureWarningOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetAuthFailureWarningOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetAuthFailureWarningOptions, sizeof(struct __tds__GetAuthFailureWarningOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetAuthFailureWarningOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetAuthFailureWarningOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetAuthFailureWarningOptions(soap, "tds:GetAuthFailureWarningOptions", &a->tds__GetAuthFailureWarningOptions, ""))
				{	soap_flag_tds__GetAuthFailureWarningOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetAuthFailureWarningOptions * SOAP_FMAC2 soap_instantiate___tds__GetAuthFailureWarningOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetAuthFailureWarningOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetAuthFailureWarningOptions *p;
	size_t k = sizeof(struct __tds__GetAuthFailureWarningOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetAuthFailureWarningOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetAuthFailureWarningOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetAuthFailureWarningOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetAuthFailureWarningOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetAuthFailureWarningOptions(struct soap *soap, const struct __tds__GetAuthFailureWarningOptions *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetAuthFailureWarningOptions(soap, tag ? tag : "-tds:GetAuthFailureWarningOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAuthFailureWarningOptions * SOAP_FMAC4 soap_get___tds__GetAuthFailureWarningOptions(struct soap *soap, struct __tds__GetAuthFailureWarningOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetAuthFailureWarningOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetPasswordHistoryConfiguration(struct soap *soap, struct __tds__SetPasswordHistoryConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetPasswordHistoryConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetPasswordHistoryConfiguration(struct soap *soap, const struct __tds__SetPasswordHistoryConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetPasswordHistoryConfiguration(soap, &a->tds__SetPasswordHistoryConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetPasswordHistoryConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetPasswordHistoryConfiguration(soap, "tds:SetPasswordHistoryConfiguration", -1, &a->tds__SetPasswordHistoryConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetPasswordHistoryConfiguration * SOAP_FMAC4 soap_in___tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, struct __tds__SetPasswordHistoryConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetPasswordHistoryConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetPasswordHistoryConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetPasswordHistoryConfiguration, sizeof(struct __tds__SetPasswordHistoryConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetPasswordHistoryConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetPasswordHistoryConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetPasswordHistoryConfiguration(soap, "tds:SetPasswordHistoryConfiguration", &a->tds__SetPasswordHistoryConfiguration, ""))
				{	soap_flag_tds__SetPasswordHistoryConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetPasswordHistoryConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetPasswordHistoryConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetPasswordHistoryConfiguration *p;
	size_t k = sizeof(struct __tds__SetPasswordHistoryConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetPasswordHistoryConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetPasswordHistoryConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetPasswordHistoryConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetPasswordHistoryConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetPasswordHistoryConfiguration(struct soap *soap, const struct __tds__SetPasswordHistoryConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetPasswordHistoryConfiguration(soap, tag ? tag : "-tds:SetPasswordHistoryConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetPasswordHistoryConfiguration * SOAP_FMAC4 soap_get___tds__SetPasswordHistoryConfiguration(struct soap *soap, struct __tds__SetPasswordHistoryConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetPasswordHistoryConfiguration(struct soap *soap, struct __tds__GetPasswordHistoryConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetPasswordHistoryConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetPasswordHistoryConfiguration(struct soap *soap, const struct __tds__GetPasswordHistoryConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetPasswordHistoryConfiguration(soap, &a->tds__GetPasswordHistoryConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetPasswordHistoryConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetPasswordHistoryConfiguration(soap, "tds:GetPasswordHistoryConfiguration", -1, &a->tds__GetPasswordHistoryConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordHistoryConfiguration * SOAP_FMAC4 soap_in___tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, struct __tds__GetPasswordHistoryConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetPasswordHistoryConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetPasswordHistoryConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetPasswordHistoryConfiguration, sizeof(struct __tds__GetPasswordHistoryConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetPasswordHistoryConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetPasswordHistoryConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetPasswordHistoryConfiguration(soap, "tds:GetPasswordHistoryConfiguration", &a->tds__GetPasswordHistoryConfiguration, ""))
				{	soap_flag_tds__GetPasswordHistoryConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetPasswordHistoryConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetPasswordHistoryConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetPasswordHistoryConfiguration *p;
	size_t k = sizeof(struct __tds__GetPasswordHistoryConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetPasswordHistoryConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetPasswordHistoryConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetPasswordHistoryConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetPasswordHistoryConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetPasswordHistoryConfiguration(struct soap *soap, const struct __tds__GetPasswordHistoryConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetPasswordHistoryConfiguration(soap, tag ? tag : "-tds:GetPasswordHistoryConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordHistoryConfiguration * SOAP_FMAC4 soap_get___tds__GetPasswordHistoryConfiguration(struct soap *soap, struct __tds__GetPasswordHistoryConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetPasswordComplexityConfiguration(struct soap *soap, struct __tds__SetPasswordComplexityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetPasswordComplexityConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetPasswordComplexityConfiguration(struct soap *soap, const struct __tds__SetPasswordComplexityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetPasswordComplexityConfiguration(soap, &a->tds__SetPasswordComplexityConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetPasswordComplexityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetPasswordComplexityConfiguration(soap, "tds:SetPasswordComplexityConfiguration", -1, &a->tds__SetPasswordComplexityConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetPasswordComplexityConfiguration * SOAP_FMAC4 soap_in___tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, struct __tds__SetPasswordComplexityConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetPasswordComplexityConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetPasswordComplexityConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetPasswordComplexityConfiguration, sizeof(struct __tds__SetPasswordComplexityConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetPasswordComplexityConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetPasswordComplexityConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetPasswordComplexityConfiguration(soap, "tds:SetPasswordComplexityConfiguration", &a->tds__SetPasswordComplexityConfiguration, ""))
				{	soap_flag_tds__SetPasswordComplexityConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetPasswordComplexityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetPasswordComplexityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetPasswordComplexityConfiguration *p;
	size_t k = sizeof(struct __tds__SetPasswordComplexityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetPasswordComplexityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetPasswordComplexityConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetPasswordComplexityConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetPasswordComplexityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetPasswordComplexityConfiguration(struct soap *soap, const struct __tds__SetPasswordComplexityConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetPasswordComplexityConfiguration(soap, tag ? tag : "-tds:SetPasswordComplexityConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetPasswordComplexityConfiguration * SOAP_FMAC4 soap_get___tds__SetPasswordComplexityConfiguration(struct soap *soap, struct __tds__SetPasswordComplexityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetPasswordComplexityConfiguration(struct soap *soap, struct __tds__GetPasswordComplexityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetPasswordComplexityConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetPasswordComplexityConfiguration(struct soap *soap, const struct __tds__GetPasswordComplexityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetPasswordComplexityConfiguration(soap, &a->tds__GetPasswordComplexityConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetPasswordComplexityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetPasswordComplexityConfiguration(soap, "tds:GetPasswordComplexityConfiguration", -1, &a->tds__GetPasswordComplexityConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordComplexityConfiguration * SOAP_FMAC4 soap_in___tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, struct __tds__GetPasswordComplexityConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetPasswordComplexityConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetPasswordComplexityConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetPasswordComplexityConfiguration, sizeof(struct __tds__GetPasswordComplexityConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetPasswordComplexityConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetPasswordComplexityConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetPasswordComplexityConfiguration(soap, "tds:GetPasswordComplexityConfiguration", &a->tds__GetPasswordComplexityConfiguration, ""))
				{	soap_flag_tds__GetPasswordComplexityConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetPasswordComplexityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetPasswordComplexityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetPasswordComplexityConfiguration *p;
	size_t k = sizeof(struct __tds__GetPasswordComplexityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetPasswordComplexityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetPasswordComplexityConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetPasswordComplexityConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetPasswordComplexityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetPasswordComplexityConfiguration(struct soap *soap, const struct __tds__GetPasswordComplexityConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetPasswordComplexityConfiguration(soap, tag ? tag : "-tds:GetPasswordComplexityConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordComplexityConfiguration * SOAP_FMAC4 soap_get___tds__GetPasswordComplexityConfiguration(struct soap *soap, struct __tds__GetPasswordComplexityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetPasswordComplexityOptions(struct soap *soap, struct __tds__GetPasswordComplexityOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetPasswordComplexityOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetPasswordComplexityOptions(struct soap *soap, const struct __tds__GetPasswordComplexityOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetPasswordComplexityOptions(soap, &a->tds__GetPasswordComplexityOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, int id, const struct __tds__GetPasswordComplexityOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetPasswordComplexityOptions(soap, "tds:GetPasswordComplexityOptions", -1, &a->tds__GetPasswordComplexityOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordComplexityOptions * SOAP_FMAC4 soap_in___tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, struct __tds__GetPasswordComplexityOptions *a, const char *type)
{
	size_t soap_flag_tds__GetPasswordComplexityOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetPasswordComplexityOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetPasswordComplexityOptions, sizeof(struct __tds__GetPasswordComplexityOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetPasswordComplexityOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetPasswordComplexityOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetPasswordComplexityOptions(soap, "tds:GetPasswordComplexityOptions", &a->tds__GetPasswordComplexityOptions, ""))
				{	soap_flag_tds__GetPasswordComplexityOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetPasswordComplexityOptions * SOAP_FMAC2 soap_instantiate___tds__GetPasswordComplexityOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetPasswordComplexityOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetPasswordComplexityOptions *p;
	size_t k = sizeof(struct __tds__GetPasswordComplexityOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetPasswordComplexityOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetPasswordComplexityOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetPasswordComplexityOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetPasswordComplexityOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetPasswordComplexityOptions(struct soap *soap, const struct __tds__GetPasswordComplexityOptions *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetPasswordComplexityOptions(soap, tag ? tag : "-tds:GetPasswordComplexityOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordComplexityOptions * SOAP_FMAC4 soap_get___tds__GetPasswordComplexityOptions(struct soap *soap, struct __tds__GetPasswordComplexityOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetPasswordComplexityOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetWsdlUrl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetWsdlUrl(struct soap *soap, const struct __tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetWsdlUrl(soap, &a->tds__GetWsdlUrl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const struct __tds__GetWsdlUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetWsdlUrl(soap, "tds:GetWsdlUrl", -1, &a->tds__GetWsdlUrl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_in___tds__GetWsdlUrl(struct soap *soap, const char *tag, struct __tds__GetWsdlUrl *a, const char *type)
{
	size_t soap_flag_tds__GetWsdlUrl = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetWsdlUrl*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetWsdlUrl, sizeof(struct __tds__GetWsdlUrl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetWsdlUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetWsdlUrl && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetWsdlUrl(soap, "tds:GetWsdlUrl", &a->tds__GetWsdlUrl, ""))
				{	soap_flag_tds__GetWsdlUrl--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate___tds__GetWsdlUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetWsdlUrl(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetWsdlUrl *p;
	size_t k = sizeof(struct __tds__GetWsdlUrl);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetWsdlUrl, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetWsdlUrl);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetWsdlUrl, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetWsdlUrl location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetWsdlUrl(struct soap *soap, const struct __tds__GetWsdlUrl *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetWsdlUrl(soap, tag ? tag : "-tds:GetWsdlUrl", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_get___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetUser(struct soap *soap, struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetUser(soap, &a->tds__SetUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetUser(struct soap *soap, const char *tag, int id, const struct __tds__SetUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetUser(soap, "tds:SetUser", -1, &a->tds__SetUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_in___tds__SetUser(struct soap *soap, const char *tag, struct __tds__SetUser *a, const char *type)
{
	size_t soap_flag_tds__SetUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetUser*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetUser, sizeof(struct __tds__SetUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetUser(soap, "tds:SetUser", &a->tds__SetUser, ""))
				{	soap_flag_tds__SetUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetUser * SOAP_FMAC2 soap_instantiate___tds__SetUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetUser *p;
	size_t k = sizeof(struct __tds__SetUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetUser(soap, tag ? tag : "-tds:SetUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_get___tds__SetUser(struct soap *soap, struct __tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteUsers(soap, &a->tds__DeleteUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct __tds__DeleteUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", -1, &a->tds__DeleteUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_in___tds__DeleteUsers(struct soap *soap, const char *tag, struct __tds__DeleteUsers *a, const char *type)
{
	size_t soap_flag_tds__DeleteUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteUsers*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteUsers, sizeof(struct __tds__DeleteUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", &a->tds__DeleteUsers, ""))
				{	soap_flag_tds__DeleteUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__DeleteUsers * SOAP_FMAC2 soap_instantiate___tds__DeleteUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__DeleteUsers *p;
	size_t k = sizeof(struct __tds__DeleteUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__DeleteUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__DeleteUsers);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__DeleteUsers, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__DeleteUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteUsers(soap, tag ? tag : "-tds:DeleteUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_get___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__CreateUsers(soap, &a->tds__CreateUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct __tds__CreateUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", -1, &a->tds__CreateUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_in___tds__CreateUsers(struct soap *soap, const char *tag, struct __tds__CreateUsers *a, const char *type)
{
	size_t soap_flag_tds__CreateUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__CreateUsers*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateUsers, sizeof(struct __tds__CreateUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", &a->tds__CreateUsers, ""))
				{	soap_flag_tds__CreateUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__CreateUsers * SOAP_FMAC2 soap_instantiate___tds__CreateUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__CreateUsers *p;
	size_t k = sizeof(struct __tds__CreateUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__CreateUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__CreateUsers);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__CreateUsers, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__CreateUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__CreateUsers(soap, tag ? tag : "-tds:CreateUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_get___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetUsers(soap, &a->tds__GetUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetUsers(struct soap *soap, const char *tag, int id, const struct __tds__GetUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetUsers(soap, "tds:GetUsers", -1, &a->tds__GetUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_in___tds__GetUsers(struct soap *soap, const char *tag, struct __tds__GetUsers *a, const char *type)
{
	size_t soap_flag_tds__GetUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetUsers*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetUsers, sizeof(struct __tds__GetUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetUsers(soap, "tds:GetUsers", &a->tds__GetUsers, ""))
				{	soap_flag_tds__GetUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetUsers * SOAP_FMAC2 soap_instantiate___tds__GetUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetUsers *p;
	size_t k = sizeof(struct __tds__GetUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetUsers);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetUsers, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetUsers(soap, tag ? tag : "-tds:GetUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_get___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRemoteUser(struct soap *soap, const struct __tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRemoteUser(soap, &a->tds__SetRemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const struct __tds__SetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRemoteUser(soap, "tds:SetRemoteUser", -1, &a->tds__SetRemoteUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_in___tds__SetRemoteUser(struct soap *soap, const char *tag, struct __tds__SetRemoteUser *a, const char *type)
{
	size_t soap_flag_tds__SetRemoteUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRemoteUser*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRemoteUser, sizeof(struct __tds__SetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRemoteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetRemoteUser(soap, "tds:SetRemoteUser", &a->tds__SetRemoteUser, ""))
				{	soap_flag_tds__SetRemoteUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__SetRemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetRemoteUser *p;
	size_t k = sizeof(struct __tds__SetRemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetRemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetRemoteUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetRemoteUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetRemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRemoteUser(struct soap *soap, const struct __tds__SetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRemoteUser(soap, tag ? tag : "-tds:SetRemoteUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_get___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRemoteUser(struct soap *soap, const struct __tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetRemoteUser(soap, &a->tds__GetRemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const struct __tds__GetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetRemoteUser(soap, "tds:GetRemoteUser", -1, &a->tds__GetRemoteUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_in___tds__GetRemoteUser(struct soap *soap, const char *tag, struct __tds__GetRemoteUser *a, const char *type)
{
	size_t soap_flag_tds__GetRemoteUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetRemoteUser*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRemoteUser, sizeof(struct __tds__GetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRemoteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetRemoteUser(soap, "tds:GetRemoteUser", &a->tds__GetRemoteUser, ""))
				{	soap_flag_tds__GetRemoteUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__GetRemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetRemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetRemoteUser *p;
	size_t k = sizeof(struct __tds__GetRemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetRemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetRemoteUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetRemoteUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetRemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRemoteUser(struct soap *soap, const struct __tds__GetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetRemoteUser(soap, tag ? tag : "-tds:GetRemoteUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_get___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetEndpointReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetEndpointReference(struct soap *soap, const struct __tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetEndpointReference(soap, &a->tds__GetEndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const struct __tds__GetEndpointReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetEndpointReference(soap, "tds:GetEndpointReference", -1, &a->tds__GetEndpointReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_in___tds__GetEndpointReference(struct soap *soap, const char *tag, struct __tds__GetEndpointReference *a, const char *type)
{
	size_t soap_flag_tds__GetEndpointReference = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetEndpointReference*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetEndpointReference, sizeof(struct __tds__GetEndpointReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetEndpointReference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetEndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetEndpointReference(soap, "tds:GetEndpointReference", &a->tds__GetEndpointReference, ""))
				{	soap_flag_tds__GetEndpointReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate___tds__GetEndpointReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetEndpointReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetEndpointReference *p;
	size_t k = sizeof(struct __tds__GetEndpointReference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetEndpointReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetEndpointReference);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetEndpointReference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetEndpointReference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetEndpointReference(struct soap *soap, const struct __tds__GetEndpointReference *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetEndpointReference(soap, tag ? tag : "-tds:GetEndpointReference", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_get___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDPAddresses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDPAddresses(struct soap *soap, const struct __tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDPAddresses(soap, &a->tds__GetDPAddresses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const struct __tds__GetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDPAddresses(soap, "tds:GetDPAddresses", -1, &a->tds__GetDPAddresses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_in___tds__GetDPAddresses(struct soap *soap, const char *tag, struct __tds__GetDPAddresses *a, const char *type)
{
	size_t soap_flag_tds__GetDPAddresses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDPAddresses*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDPAddresses, sizeof(struct __tds__GetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDPAddresses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDPAddresses(soap, "tds:GetDPAddresses", &a->tds__GetDPAddresses, ""))
				{	soap_flag_tds__GetDPAddresses--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__GetDPAddresses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDPAddresses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDPAddresses *p;
	size_t k = sizeof(struct __tds__GetDPAddresses);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDPAddresses, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDPAddresses);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDPAddresses, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDPAddresses location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDPAddresses(struct soap *soap, const struct __tds__GetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDPAddresses(soap, tag ? tag : "-tds:GetDPAddresses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_get___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRemoteDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRemoteDiscoveryMode(struct soap *soap, const struct __tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(soap, &a->tds__SetRemoteDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, "tds:SetRemoteDiscoveryMode", -1, &a->tds__SetRemoteDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct __tds__SetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__SetRemoteDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRemoteDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRemoteDiscoveryMode, sizeof(struct __tds__SetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRemoteDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, "tds:SetRemoteDiscoveryMode", &a->tds__SetRemoteDiscoveryMode, ""))
				{	soap_flag_tds__SetRemoteDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetRemoteDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRemoteDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetRemoteDiscoveryMode *p;
	size_t k = sizeof(struct __tds__SetRemoteDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetRemoteDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetRemoteDiscoveryMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetRemoteDiscoveryMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetRemoteDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRemoteDiscoveryMode(struct soap *soap, const struct __tds__SetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRemoteDiscoveryMode(soap, tag ? tag : "-tds:SetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRemoteDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRemoteDiscoveryMode(struct soap *soap, const struct __tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(soap, &a->tds__GetRemoteDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, "tds:GetRemoteDiscoveryMode", -1, &a->tds__GetRemoteDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct __tds__GetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__GetRemoteDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetRemoteDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRemoteDiscoveryMode, sizeof(struct __tds__GetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRemoteDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, "tds:GetRemoteDiscoveryMode", &a->tds__GetRemoteDiscoveryMode, ""))
				{	soap_flag_tds__GetRemoteDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetRemoteDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetRemoteDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetRemoteDiscoveryMode *p;
	size_t k = sizeof(struct __tds__GetRemoteDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetRemoteDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetRemoteDiscoveryMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetRemoteDiscoveryMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetRemoteDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRemoteDiscoveryMode(struct soap *soap, const struct __tds__GetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetRemoteDiscoveryMode(soap, tag ? tag : "-tds:GetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDiscoveryMode(struct soap *soap, const struct __tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDiscoveryMode(soap, &a->tds__SetDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__SetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDiscoveryMode(soap, "tds:SetDiscoveryMode", -1, &a->tds__SetDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_in___tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct __tds__SetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__SetDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDiscoveryMode, sizeof(struct __tds__SetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDiscoveryMode(soap, "tds:SetDiscoveryMode", &a->tds__SetDiscoveryMode, ""))
				{	soap_flag_tds__SetDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetDiscoveryMode *p;
	size_t k = sizeof(struct __tds__SetDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetDiscoveryMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetDiscoveryMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDiscoveryMode(struct soap *soap, const struct __tds__SetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDiscoveryMode(soap, tag ? tag : "-tds:SetDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_get___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDiscoveryMode(struct soap *soap, const struct __tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDiscoveryMode(soap, &a->tds__GetDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__GetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDiscoveryMode(soap, "tds:GetDiscoveryMode", -1, &a->tds__GetDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_in___tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct __tds__GetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__GetDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDiscoveryMode, sizeof(struct __tds__GetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDiscoveryMode(soap, "tds:GetDiscoveryMode", &a->tds__GetDiscoveryMode, ""))
				{	soap_flag_tds__GetDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDiscoveryMode *p;
	size_t k = sizeof(struct __tds__GetDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDiscoveryMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDiscoveryMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDiscoveryMode(struct soap *soap, const struct __tds__GetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDiscoveryMode(soap, tag ? tag : "-tds:GetDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_get___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RemoveScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RemoveScopes(struct soap *soap, const struct __tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__RemoveScopes(soap, &a->tds__RemoveScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RemoveScopes(struct soap *soap, const char *tag, int id, const struct __tds__RemoveScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__RemoveScopes(soap, "tds:RemoveScopes", -1, &a->tds__RemoveScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_in___tds__RemoveScopes(struct soap *soap, const char *tag, struct __tds__RemoveScopes *a, const char *type)
{
	size_t soap_flag_tds__RemoveScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__RemoveScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RemoveScopes, sizeof(struct __tds__RemoveScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RemoveScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RemoveScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__RemoveScopes(soap, "tds:RemoveScopes", &a->tds__RemoveScopes, ""))
				{	soap_flag_tds__RemoveScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__RemoveScopes * SOAP_FMAC2 soap_instantiate___tds__RemoveScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__RemoveScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__RemoveScopes *p;
	size_t k = sizeof(struct __tds__RemoveScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__RemoveScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__RemoveScopes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__RemoveScopes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__RemoveScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RemoveScopes(struct soap *soap, const struct __tds__RemoveScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__RemoveScopes(soap, tag ? tag : "-tds:RemoveScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_get___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__AddScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__AddScopes(struct soap *soap, const struct __tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__AddScopes(soap, &a->tds__AddScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__AddScopes(struct soap *soap, const char *tag, int id, const struct __tds__AddScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__AddScopes(soap, "tds:AddScopes", -1, &a->tds__AddScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_in___tds__AddScopes(struct soap *soap, const char *tag, struct __tds__AddScopes *a, const char *type)
{
	size_t soap_flag_tds__AddScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__AddScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__AddScopes, sizeof(struct __tds__AddScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__AddScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__AddScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__AddScopes(soap, "tds:AddScopes", &a->tds__AddScopes, ""))
				{	soap_flag_tds__AddScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__AddScopes * SOAP_FMAC2 soap_instantiate___tds__AddScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__AddScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__AddScopes *p;
	size_t k = sizeof(struct __tds__AddScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__AddScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__AddScopes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__AddScopes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__AddScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__AddScopes(struct soap *soap, const struct __tds__AddScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__AddScopes(soap, tag ? tag : "-tds:AddScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_get___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetScopes(struct soap *soap, const struct __tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetScopes(soap, &a->tds__SetScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetScopes(struct soap *soap, const char *tag, int id, const struct __tds__SetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetScopes(soap, "tds:SetScopes", -1, &a->tds__SetScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_in___tds__SetScopes(struct soap *soap, const char *tag, struct __tds__SetScopes *a, const char *type)
{
	size_t soap_flag_tds__SetScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetScopes, sizeof(struct __tds__SetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetScopes(soap, "tds:SetScopes", &a->tds__SetScopes, ""))
				{	soap_flag_tds__SetScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetScopes * SOAP_FMAC2 soap_instantiate___tds__SetScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetScopes *p;
	size_t k = sizeof(struct __tds__SetScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetScopes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetScopes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetScopes(struct soap *soap, const struct __tds__SetScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetScopes(soap, tag ? tag : "-tds:SetScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_get___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetScopes(struct soap *soap, const struct __tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetScopes(soap, &a->tds__GetScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetScopes(struct soap *soap, const char *tag, int id, const struct __tds__GetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetScopes(soap, "tds:GetScopes", -1, &a->tds__GetScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_in___tds__GetScopes(struct soap *soap, const char *tag, struct __tds__GetScopes *a, const char *type)
{
	size_t soap_flag_tds__GetScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetScopes, sizeof(struct __tds__GetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetScopes(soap, "tds:GetScopes", &a->tds__GetScopes, ""))
				{	soap_flag_tds__GetScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetScopes * SOAP_FMAC2 soap_instantiate___tds__GetScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetScopes *p;
	size_t k = sizeof(struct __tds__GetScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetScopes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetScopes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetScopes(struct soap *soap, const struct __tds__GetScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetScopes(soap, tag ? tag : "-tds:GetScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_get___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemSupportInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemSupportInformation(struct soap *soap, const struct __tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemSupportInformation(soap, &a->tds__GetSystemSupportInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemSupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, "tds:GetSystemSupportInformation", -1, &a->tds__GetSystemSupportInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in___tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct __tds__GetSystemSupportInformation *a, const char *type)
{
	size_t soap_flag_tds__GetSystemSupportInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemSupportInformation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemSupportInformation, sizeof(struct __tds__GetSystemSupportInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemSupportInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemSupportInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemSupportInformation(soap, "tds:GetSystemSupportInformation", &a->tds__GetSystemSupportInformation, ""))
				{	soap_flag_tds__GetSystemSupportInformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate___tds__GetSystemSupportInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemSupportInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetSystemSupportInformation *p;
	size_t k = sizeof(struct __tds__GetSystemSupportInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetSystemSupportInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetSystemSupportInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetSystemSupportInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetSystemSupportInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemSupportInformation(struct soap *soap, const struct __tds__GetSystemSupportInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemSupportInformation(soap, tag ? tag : "-tds:GetSystemSupportInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemLog(struct soap *soap, const struct __tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemLog(soap, &a->tds__GetSystemLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemLog(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemLog(soap, "tds:GetSystemLog", -1, &a->tds__GetSystemLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_in___tds__GetSystemLog(struct soap *soap, const char *tag, struct __tds__GetSystemLog *a, const char *type)
{
	size_t soap_flag_tds__GetSystemLog = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemLog*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemLog, sizeof(struct __tds__GetSystemLog), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemLog && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemLog(soap, "tds:GetSystemLog", &a->tds__GetSystemLog, ""))
				{	soap_flag_tds__GetSystemLog--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetSystemLog * SOAP_FMAC2 soap_instantiate___tds__GetSystemLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetSystemLog *p;
	size_t k = sizeof(struct __tds__GetSystemLog);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetSystemLog, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetSystemLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetSystemLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetSystemLog location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemLog(struct soap *soap, const struct __tds__GetSystemLog *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemLog(soap, tag ? tag : "-tds:GetSystemLog", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_get___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemBackup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemBackup(struct soap *soap, const struct __tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemBackup(soap, &a->tds__GetSystemBackup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemBackup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, "tds:GetSystemBackup", -1, &a->tds__GetSystemBackup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_in___tds__GetSystemBackup(struct soap *soap, const char *tag, struct __tds__GetSystemBackup *a, const char *type)
{
	size_t soap_flag_tds__GetSystemBackup = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemBackup*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemBackup, sizeof(struct __tds__GetSystemBackup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemBackup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemBackup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemBackup(soap, "tds:GetSystemBackup", &a->tds__GetSystemBackup, ""))
				{	soap_flag_tds__GetSystemBackup--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate___tds__GetSystemBackup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemBackup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetSystemBackup *p;
	size_t k = sizeof(struct __tds__GetSystemBackup);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetSystemBackup, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetSystemBackup);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetSystemBackup, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetSystemBackup location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemBackup(struct soap *soap, const struct __tds__GetSystemBackup *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemBackup(soap, tag ? tag : "-tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_get___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RestoreSystem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RestoreSystem(struct soap *soap, const struct __tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__RestoreSystem(soap, &a->tds__RestoreSystem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RestoreSystem(struct soap *soap, const char *tag, int id, const struct __tds__RestoreSystem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__RestoreSystem(soap, "tds:RestoreSystem", -1, &a->tds__RestoreSystem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_in___tds__RestoreSystem(struct soap *soap, const char *tag, struct __tds__RestoreSystem *a, const char *type)
{
	size_t soap_flag_tds__RestoreSystem = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__RestoreSystem*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RestoreSystem, sizeof(struct __tds__RestoreSystem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RestoreSystem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RestoreSystem && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__RestoreSystem(soap, "tds:RestoreSystem", &a->tds__RestoreSystem, ""))
				{	soap_flag_tds__RestoreSystem--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__RestoreSystem * SOAP_FMAC2 soap_instantiate___tds__RestoreSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__RestoreSystem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__RestoreSystem *p;
	size_t k = sizeof(struct __tds__RestoreSystem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__RestoreSystem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__RestoreSystem);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__RestoreSystem, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__RestoreSystem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RestoreSystem(struct soap *soap, const struct __tds__RestoreSystem *a, const char *tag, const char *type)
{
	if (soap_out___tds__RestoreSystem(soap, tag ? tag : "-tds:RestoreSystem", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_get___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SystemReboot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SystemReboot(soap, &a->tds__SystemReboot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct __tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", -1, &a->tds__SystemReboot, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_in___tds__SystemReboot(struct soap *soap, const char *tag, struct __tds__SystemReboot *a, const char *type)
{
	size_t soap_flag_tds__SystemReboot = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SystemReboot*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SystemReboot, sizeof(struct __tds__SystemReboot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SystemReboot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SystemReboot && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", &a->tds__SystemReboot, ""))
				{	soap_flag_tds__SystemReboot--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SystemReboot * SOAP_FMAC2 soap_instantiate___tds__SystemReboot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SystemReboot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SystemReboot *p;
	size_t k = sizeof(struct __tds__SystemReboot);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SystemReboot, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SystemReboot);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SystemReboot, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SystemReboot location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a, const char *tag, const char *type)
{
	if (soap_out___tds__SystemReboot(soap, tag ? tag : "-tds:SystemReboot", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_get___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__UpgradeSystemFirmware = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__UpgradeSystemFirmware(struct soap *soap, const struct __tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__UpgradeSystemFirmware(soap, &a->tds__UpgradeSystemFirmware);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, const struct __tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, "tds:UpgradeSystemFirmware", -1, &a->tds__UpgradeSystemFirmware, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_in___tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct __tds__UpgradeSystemFirmware *a, const char *type)
{
	size_t soap_flag_tds__UpgradeSystemFirmware = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__UpgradeSystemFirmware*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__UpgradeSystemFirmware, sizeof(struct __tds__UpgradeSystemFirmware), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__UpgradeSystemFirmware(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__UpgradeSystemFirmware && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, "tds:UpgradeSystemFirmware", &a->tds__UpgradeSystemFirmware, ""))
				{	soap_flag_tds__UpgradeSystemFirmware--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate___tds__UpgradeSystemFirmware(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__UpgradeSystemFirmware(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__UpgradeSystemFirmware *p;
	size_t k = sizeof(struct __tds__UpgradeSystemFirmware);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__UpgradeSystemFirmware, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__UpgradeSystemFirmware);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__UpgradeSystemFirmware, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__UpgradeSystemFirmware location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__UpgradeSystemFirmware(struct soap *soap, const struct __tds__UpgradeSystemFirmware *a, const char *tag, const char *type)
{
	if (soap_out___tds__UpgradeSystemFirmware(soap, tag ? tag : "-tds:UpgradeSystemFirmware", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_get___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemFactoryDefault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetSystemFactoryDefault(soap, &a->tds__SetSystemFactoryDefault);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", -1, &a->tds__SetSystemFactoryDefault, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	size_t soap_flag_tds__SetSystemFactoryDefault = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetSystemFactoryDefault*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemFactoryDefault, sizeof(struct __tds__SetSystemFactoryDefault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetSystemFactoryDefault(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetSystemFactoryDefault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", &a->tds__SetSystemFactoryDefault, ""))
				{	soap_flag_tds__SetSystemFactoryDefault--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate___tds__SetSystemFactoryDefault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetSystemFactoryDefault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetSystemFactoryDefault *p;
	size_t k = sizeof(struct __tds__SetSystemFactoryDefault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetSystemFactoryDefault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetSystemFactoryDefault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetSystemFactoryDefault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetSystemFactoryDefault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetSystemFactoryDefault(soap, tag ? tag : "-tds:SetSystemFactoryDefault", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemDateAndTime(soap, &a->tds__GetSystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", -1, &a->tds__GetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__GetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__GetSystemDateAndTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemDateAndTime*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemDateAndTime, sizeof(struct __tds__GetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemDateAndTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", &a->tds__GetSystemDateAndTime, ""))
				{	soap_flag_tds__GetSystemDateAndTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__GetSystemDateAndTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemDateAndTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetSystemDateAndTime *p;
	size_t k = sizeof(struct __tds__GetSystemDateAndTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetSystemDateAndTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetSystemDateAndTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetSystemDateAndTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetSystemDateAndTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemDateAndTime(soap, tag ? tag : "-tds:GetSystemDateAndTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetSystemDateAndTime(soap, &a->tds__SetSystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", -1, &a->tds__SetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__SetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__SetSystemDateAndTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetSystemDateAndTime*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemDateAndTime, sizeof(struct __tds__SetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetSystemDateAndTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", &a->tds__SetSystemDateAndTime, ""))
				{	soap_flag_tds__SetSystemDateAndTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__SetSystemDateAndTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetSystemDateAndTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetSystemDateAndTime *p;
	size_t k = sizeof(struct __tds__SetSystemDateAndTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetSystemDateAndTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetSystemDateAndTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetSystemDateAndTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetSystemDateAndTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetSystemDateAndTime(soap, tag ? tag : "-tds:SetSystemDateAndTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDeviceInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDeviceInformation(soap, &a->tds__GetDeviceInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", -1, &a->tds__GetDeviceInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_in___tds__GetDeviceInformation(struct soap *soap, const char *tag, struct __tds__GetDeviceInformation *a, const char *type)
{
	size_t soap_flag_tds__GetDeviceInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDeviceInformation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDeviceInformation, sizeof(struct __tds__GetDeviceInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDeviceInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDeviceInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", &a->tds__GetDeviceInformation, ""))
				{	soap_flag_tds__GetDeviceInformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate___tds__GetDeviceInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDeviceInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDeviceInformation *p;
	size_t k = sizeof(struct __tds__GetDeviceInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDeviceInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDeviceInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDeviceInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDeviceInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDeviceInformation(soap, tag ? tag : "-tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_get___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetServiceCapabilities(soap, &a->tds__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", -1, &a->tds__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_in___tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tds__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServiceCapabilities, sizeof(struct __tds__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", &a->tds__GetServiceCapabilities, ""))
				{	soap_flag_tds__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetServiceCapabilities *p;
	size_t k = sizeof(struct __tds__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetServiceCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetServiceCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetServiceCapabilities(soap, tag ? tag : "-tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_get___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServices(struct soap *soap, struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServices = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetServices(soap, &a->tds__GetServices);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServices(struct soap *soap, const char *tag, int id, const struct __tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetServices(soap, "tds:GetServices", -1, &a->tds__GetServices, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_in___tds__GetServices(struct soap *soap, const char *tag, struct __tds__GetServices *a, const char *type)
{
	size_t soap_flag_tds__GetServices = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetServices*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServices, sizeof(struct __tds__GetServices), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServices(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServices && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetServices(soap, "tds:GetServices", &a->tds__GetServices, ""))
				{	soap_flag_tds__GetServices--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetServices * SOAP_FMAC2 soap_instantiate___tds__GetServices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetServices(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetServices *p;
	size_t k = sizeof(struct __tds__GetServices);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetServices, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetServices);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetServices, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetServices location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetServices(soap, tag ? tag : "-tds:GetServices", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_get___tds__GetServices(struct soap *soap, struct __tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SOAP_ENV__Header = NULL;
	a->SOAP_ENV__Body = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Header(soap, &a->SOAP_ENV__Header);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Envelope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Envelope), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", -1, &a->SOAP_ENV__Header, ""))
		return soap->error;
	if (soap_outliteral(soap, "SOAP-ENV:Body", (char*const*)&a->SOAP_ENV__Body, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Header = 1;
	size_t soap_flag_SOAP_ENV__Body = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Envelope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Envelope(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Header && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", &a->SOAP_ENV__Header, ""))
				{	soap_flag_SOAP_ENV__Header--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "SOAP-ENV:Body", (char**)&a->SOAP_ENV__Body))
				{	soap_flag_SOAP_ENV__Body--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Envelope, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Envelope * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Envelope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Envelope *p;
	size_t k = sizeof(struct SOAP_ENV__Envelope);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Envelope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Envelope);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Envelope, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Envelope location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Envelope(soap, tag ? tag : "SOAP-ENV:Envelope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	if (a->wsa5__IsReferenceParameter != (enum _wsa5__IsReferenceParameter)0)
	{	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 5, 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_chan__ChannelInstanceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct chan__ChannelInstanceType *p;
	size_t k = sizeof(struct chan__ChannelInstanceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_chan__ChannelInstanceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct chan__ChannelInstanceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct chan__ChannelInstanceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct chan__ChannelInstanceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	if (soap_out_chan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemAction(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemAction(soap, tag ? tag : "wsa5:ProblemAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__FaultTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__From(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReplyTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RelatesTo(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Metadata(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Metadata(soap, tag ? tag : "wsa5:Metadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReferenceParameters(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReferenceParameters(soap, tag ? tag : "wsa5:ReferenceParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__EndpointReference(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__EndpointReference(soap, tag ? tag : "wsa5:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Action);
	soap_serialize_string(soap, (char*const*)&a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, (char*const*)&a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, (char*const*)&a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ProblemActionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Action", (char**)&a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:SoapAction", (char**)&a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ProblemActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ProblemActionType *p;
	size_t k = sizeof(struct wsa5__ProblemActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ProblemActionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ProblemActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ProblemActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ProblemActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ProblemActionType(soap, tag ? tag : "wsa5:ProblemActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_wsa5__RelationshipTypeOpenEnum2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2wsa5__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__RelatesToType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__RelatesToType *p;
	size_t k = sizeof(struct wsa5__RelatesToType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__RelatesToType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__RelatesToType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__RelatesToType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__RelatesToType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelatesToType(soap, tag ? tag : "wsa5:RelatesToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__MetadataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__MetadataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__MetadataType *p;
	size_t k = sizeof(struct wsa5__MetadataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__MetadataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__MetadataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__MetadataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__MetadataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ReferenceParametersType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ReferenceParametersType *p;
	size_t k = sizeof(struct wsa5__ReferenceParametersType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ReferenceParametersType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ReferenceParametersType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ReferenceParametersType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ReferenceParametersType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa5:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa5:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__EndpointReferenceType *p;
	size_t k = sizeof(struct wsa5__EndpointReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__EndpointReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, const struct _xop__Include *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_attachment_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE__xop__Include, a->id, a->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__xop__Include2s(struct soap *soap, struct _xop__Include a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE__xop__Include);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE__xop__Include, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_xop__Include(struct soap *soap, const char *s, struct _xop__Include *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xop__Include(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _xop__Include *p;
	size_t k = sizeof(struct _xop__Include);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__xop__Include, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _xop__Include);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _xop__Include, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _xop__Include location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	if (soap_out__xop__Include(soap, tag ? tag : "xop:Include", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, _tds__SetHashingAlgorithm *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHashingAlgorithm))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, const char *tag, int id, _tds__SetHashingAlgorithm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHashingAlgorithm, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetHashingAlgorithm ? type : NULL);
}

SOAP_FMAC3 _tds__SetHashingAlgorithm ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, const char *tag, _tds__SetHashingAlgorithm **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetHashingAlgorithm **)soap_malloc(soap, sizeof(_tds__SetHashingAlgorithm *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetHashingAlgorithm *)soap_instantiate__tds__SetHashingAlgorithm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetHashingAlgorithm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHashingAlgorithm, sizeof(_tds__SetHashingAlgorithm), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, _tds__SetHashingAlgorithm *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetHashingAlgorithm(soap, tag ? tag : "tds:SetHashingAlgorithm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetHashingAlgorithm ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, _tds__SetHashingAlgorithm **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHashingAlgorithm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteGeoLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteGeoLocation(struct soap *soap, const char *tag, int id, _tds__DeleteGeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteGeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__DeleteGeoLocation ? type : NULL);
}

SOAP_FMAC3 _tds__DeleteGeoLocation ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteGeoLocation(struct soap *soap, const char *tag, _tds__DeleteGeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteGeoLocation **)soap_malloc(soap, sizeof(_tds__DeleteGeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteGeoLocation *)soap_instantiate__tds__DeleteGeoLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__DeleteGeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(_tds__DeleteGeoLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteGeoLocation(soap, tag ? tag : "tds:DeleteGeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteGeoLocation ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetGeoLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetGeoLocation(struct soap *soap, const char *tag, int id, _tds__SetGeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetGeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetGeoLocation ? type : NULL);
}

SOAP_FMAC3 _tds__SetGeoLocation ** SOAP_FMAC4 soap_in_PointerTo_tds__SetGeoLocation(struct soap *soap, const char *tag, _tds__SetGeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetGeoLocation **)soap_malloc(soap, sizeof(_tds__SetGeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetGeoLocation *)soap_instantiate__tds__SetGeoLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetGeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetGeoLocation, sizeof(_tds__SetGeoLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetGeoLocation(soap, tag ? tag : "tds:SetGeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetGeoLocation ** SOAP_FMAC4 soap_get_PointerTo_tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetGeoLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetGeoLocation(struct soap *soap, const char *tag, int id, _tds__GetGeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetGeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetGeoLocation ? type : NULL);
}

SOAP_FMAC3 _tds__GetGeoLocation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetGeoLocation(struct soap *soap, const char *tag, _tds__GetGeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetGeoLocation **)soap_malloc(soap, sizeof(_tds__GetGeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetGeoLocation *)soap_instantiate__tds__GetGeoLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetGeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetGeoLocation, sizeof(_tds__GetGeoLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetGeoLocation(soap, tag ? tag : "tds:GetGeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetGeoLocation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteStorageConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, int id, _tds__DeleteStorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteStorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__DeleteStorageConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__DeleteStorageConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, _tds__DeleteStorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteStorageConfiguration **)soap_malloc(soap, sizeof(_tds__DeleteStorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteStorageConfiguration *)soap_instantiate__tds__DeleteStorageConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__DeleteStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(_tds__DeleteStorageConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteStorageConfiguration(soap, tag ? tag : "tds:DeleteStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteStorageConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetStorageConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetStorageConfiguration(struct soap *soap, const char *tag, int id, _tds__SetStorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetStorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetStorageConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetStorageConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetStorageConfiguration(struct soap *soap, const char *tag, _tds__SetStorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetStorageConfiguration **)soap_malloc(soap, sizeof(_tds__SetStorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetStorageConfiguration *)soap_instantiate__tds__SetStorageConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(_tds__SetStorageConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetStorageConfiguration(soap, tag ? tag : "tds:SetStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetStorageConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetStorageConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetStorageConfiguration(struct soap *soap, const char *tag, int id, _tds__GetStorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetStorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetStorageConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetStorageConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetStorageConfiguration(struct soap *soap, const char *tag, _tds__GetStorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetStorageConfiguration **)soap_malloc(soap, sizeof(_tds__GetStorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetStorageConfiguration *)soap_instantiate__tds__GetStorageConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(_tds__GetStorageConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetStorageConfiguration(soap, tag ? tag : "tds:GetStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetStorageConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateStorageConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, const char *tag, int id, _tds__CreateStorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateStorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__CreateStorageConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__CreateStorageConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, const char *tag, _tds__CreateStorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateStorageConfiguration **)soap_malloc(soap, sizeof(_tds__CreateStorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateStorageConfiguration *)soap_instantiate__tds__CreateStorageConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__CreateStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(_tds__CreateStorageConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__CreateStorageConfiguration(soap, tag ? tag : "tds:CreateStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateStorageConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetStorageConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetStorageConfigurations(struct soap *soap, const char *tag, int id, _tds__GetStorageConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetStorageConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetStorageConfigurations ? type : NULL);
}

SOAP_FMAC3 _tds__GetStorageConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tds__GetStorageConfigurations(struct soap *soap, const char *tag, _tds__GetStorageConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetStorageConfigurations **)soap_malloc(soap, sizeof(_tds__GetStorageConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetStorageConfigurations *)soap_instantiate__tds__GetStorageConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetStorageConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(_tds__GetStorageConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetStorageConfigurations(soap, tag ? tag : "tds:GetStorageConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetStorageConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetStorageConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartSystemRestore))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartSystemRestore(struct soap *soap, const char *tag, int id, _tds__StartSystemRestore *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartSystemRestore, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__StartSystemRestore ? type : NULL);
}

SOAP_FMAC3 _tds__StartSystemRestore ** SOAP_FMAC4 soap_in_PointerTo_tds__StartSystemRestore(struct soap *soap, const char *tag, _tds__StartSystemRestore **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__StartSystemRestore **)soap_malloc(soap, sizeof(_tds__StartSystemRestore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__StartSystemRestore *)soap_instantiate__tds__StartSystemRestore(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__StartSystemRestore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartSystemRestore, sizeof(_tds__StartSystemRestore), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__StartSystemRestore(soap, tag ? tag : "tds:StartSystemRestore", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__StartSystemRestore ** SOAP_FMAC4 soap_get_PointerTo_tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartFirmwareUpgrade))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, _tds__StartFirmwareUpgrade *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartFirmwareUpgrade, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__StartFirmwareUpgrade ? type : NULL);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade ** SOAP_FMAC4 soap_in_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, _tds__StartFirmwareUpgrade **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__StartFirmwareUpgrade **)soap_malloc(soap, sizeof(_tds__StartFirmwareUpgrade *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__StartFirmwareUpgrade *)soap_instantiate__tds__StartFirmwareUpgrade(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__StartFirmwareUpgrade **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(_tds__StartFirmwareUpgrade), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__StartFirmwareUpgrade(soap, tag ? tag : "tds:StartFirmwareUpgrade", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade ** SOAP_FMAC4 soap_get_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUris))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUris(struct soap *soap, const char *tag, int id, _tds__GetSystemUris *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUris, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemUris ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemUris ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUris(struct soap *soap, const char *tag, _tds__GetSystemUris **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemUris **)soap_malloc(soap, sizeof(_tds__GetSystemUris *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemUris *)soap_instantiate__tds__GetSystemUris(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemUris **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUris, sizeof(_tds__GetSystemUris), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemUris(soap, tag ? tag : "tds:GetSystemUris", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemUris ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__ScanAvailableDot11Networks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, _tds__ScanAvailableDot11Networks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__ScanAvailableDot11Networks, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__ScanAvailableDot11Networks ? type : NULL);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks ** SOAP_FMAC4 soap_in_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, _tds__ScanAvailableDot11Networks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__ScanAvailableDot11Networks **)soap_malloc(soap, sizeof(_tds__ScanAvailableDot11Networks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__ScanAvailableDot11Networks *)soap_instantiate__tds__ScanAvailableDot11Networks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__ScanAvailableDot11Networks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(_tds__ScanAvailableDot11Networks), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__ScanAvailableDot11Networks(soap, tag ? tag : "tds:ScanAvailableDot11Networks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks ** SOAP_FMAC4 soap_get_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11Status))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11Status(struct soap *soap, const char *tag, int id, _tds__GetDot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11Status, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDot11Status ? type : NULL);
}

SOAP_FMAC3 _tds__GetDot11Status ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11Status(struct soap *soap, const char *tag, _tds__GetDot11Status **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot11Status **)soap_malloc(soap, sizeof(_tds__GetDot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot11Status *)soap_instantiate__tds__GetDot11Status(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Status, sizeof(_tds__GetDot11Status), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDot11Status(soap, tag ? tag : "tds:GetDot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot11Status ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, _tds__GetDot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDot11Capabilities ? type : NULL);
}

SOAP_FMAC3 _tds__GetDot11Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11Capabilities(struct soap *soap, const char *tag, _tds__GetDot11Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot11Capabilities **)soap_malloc(soap, sizeof(_tds__GetDot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot11Capabilities *)soap_instantiate__tds__GetDot11Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(_tds__GetDot11Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDot11Capabilities(soap, tag ? tag : "tds:GetDot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot11Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__DeleteDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteDot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__DeleteDot1XConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, _tds__DeleteDot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__DeleteDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteDot1XConfiguration *)soap_instantiate__tds__DeleteDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__DeleteDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(_tds__DeleteDot1XConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteDot1XConfiguration(soap, tag ? tag : "tds:DeleteDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, _tds__GetDot1XConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDot1XConfigurations ? type : NULL);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, const char *tag, _tds__GetDot1XConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot1XConfigurations **)soap_malloc(soap, sizeof(_tds__GetDot1XConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot1XConfigurations *)soap_instantiate__tds__GetDot1XConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDot1XConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(_tds__GetDot1XConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDot1XConfigurations(soap, tag ? tag : "tds:GetDot1XConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__GetDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDot1XConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, const char *tag, _tds__GetDot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__GetDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot1XConfiguration *)soap_instantiate__tds__GetDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(_tds__GetDot1XConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDot1XConfiguration(soap, tag ? tag : "tds:GetDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__SetDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetDot1XConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, const char *tag, _tds__SetDot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__SetDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDot1XConfiguration *)soap_instantiate__tds__SetDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(_tds__SetDot1XConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetDot1XConfiguration(soap, tag ? tag : "tds:SetDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__CreateDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateDot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__CreateDot1XConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, _tds__CreateDot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__CreateDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateDot1XConfiguration *)soap_instantiate__tds__CreateDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__CreateDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(_tds__CreateDot1XConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__CreateDot1XConfiguration(soap, tag ? tag : "tds:CreateDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCACertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCACertificates(struct soap *soap, const char *tag, int id, _tds__LoadCACertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCACertificates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__LoadCACertificates ? type : NULL);
}

SOAP_FMAC3 _tds__LoadCACertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCACertificates(struct soap *soap, const char *tag, _tds__LoadCACertificates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCACertificates **)soap_malloc(soap, sizeof(_tds__LoadCACertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCACertificates *)soap_instantiate__tds__LoadCACertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__LoadCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCACertificates, sizeof(_tds__LoadCACertificates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__LoadCACertificates(soap, tag ? tag : "tds:LoadCACertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCACertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificateInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, _tds__GetCertificateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificateInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetCertificateInformation ? type : NULL);
}

SOAP_FMAC3 _tds__GetCertificateInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificateInformation(struct soap *soap, const char *tag, _tds__GetCertificateInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificateInformation **)soap_malloc(soap, sizeof(_tds__GetCertificateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificateInformation *)soap_instantiate__tds__GetCertificateInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetCertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(_tds__GetCertificateInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCertificateInformation(soap, tag ? tag : "tds:GetCertificateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificateInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, _tds__LoadCertificateWithPrivateKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__LoadCertificateWithPrivateKey ? type : NULL);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKey **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCertificateWithPrivateKey **)soap_malloc(soap, sizeof(_tds__LoadCertificateWithPrivateKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCertificateWithPrivateKey *)soap_instantiate__tds__LoadCertificateWithPrivateKey(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__LoadCertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(_tds__LoadCertificateWithPrivateKey), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag ? tag : "tds:LoadCertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCACertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCACertificates(struct soap *soap, const char *tag, int id, _tds__GetCACertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCACertificates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetCACertificates ? type : NULL);
}

SOAP_FMAC3 _tds__GetCACertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCACertificates(struct soap *soap, const char *tag, _tds__GetCACertificates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCACertificates **)soap_malloc(soap, sizeof(_tds__GetCACertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCACertificates *)soap_instantiate__tds__GetCACertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCACertificates, sizeof(_tds__GetCACertificates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCACertificates(soap, tag ? tag : "tds:GetCACertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCACertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SendAuxiliaryCommand))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, _tds__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SendAuxiliaryCommand, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SendAuxiliaryCommand ? type : NULL);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommand **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(_tds__SendAuxiliaryCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SendAuxiliaryCommand *)soap_instantiate__tds__SendAuxiliaryCommand(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(_tds__SendAuxiliaryCommand), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, tag ? tag : "tds:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, _tds__SetRelayOutputState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputState, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetRelayOutputState ? type : NULL);
}

SOAP_FMAC3 _tds__SetRelayOutputState ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, _tds__SetRelayOutputState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRelayOutputState **)soap_malloc(soap, sizeof(_tds__SetRelayOutputState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRelayOutputState *)soap_instantiate__tds__SetRelayOutputState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetRelayOutputState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(_tds__SetRelayOutputState), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetRelayOutputState(soap, tag ? tag : "tds:SetRelayOutputState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRelayOutputState ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, _tds__SetRelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputSettings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetRelayOutputSettings ? type : NULL);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, _tds__SetRelayOutputSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRelayOutputSettings **)soap_malloc(soap, sizeof(_tds__SetRelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRelayOutputSettings *)soap_instantiate__tds__SetRelayOutputSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetRelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(_tds__SetRelayOutputSettings), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetRelayOutputSettings(soap, tag ? tag : "tds:SetRelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRelayOutputs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, _tds__GetRelayOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRelayOutputs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetRelayOutputs ? type : NULL);
}

SOAP_FMAC3 _tds__GetRelayOutputs ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, _tds__GetRelayOutputs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRelayOutputs **)soap_malloc(soap, sizeof(_tds__GetRelayOutputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRelayOutputs *)soap_instantiate__tds__GetRelayOutputs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetRelayOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(_tds__GetRelayOutputs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetRelayOutputs(soap, tag ? tag : "tds:GetRelayOutputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRelayOutputs ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetClientCertificateMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, _tds__SetClientCertificateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetClientCertificateMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetClientCertificateMode ? type : NULL);
}

SOAP_FMAC3 _tds__SetClientCertificateMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetClientCertificateMode(struct soap *soap, const char *tag, _tds__SetClientCertificateMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetClientCertificateMode **)soap_malloc(soap, sizeof(_tds__SetClientCertificateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetClientCertificateMode *)soap_instantiate__tds__SetClientCertificateMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(_tds__SetClientCertificateMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetClientCertificateMode(soap, tag ? tag : "tds:SetClientCertificateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetClientCertificateMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetClientCertificateMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, _tds__GetClientCertificateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetClientCertificateMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetClientCertificateMode ? type : NULL);
}

SOAP_FMAC3 _tds__GetClientCertificateMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetClientCertificateMode(struct soap *soap, const char *tag, _tds__GetClientCertificateMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetClientCertificateMode **)soap_malloc(soap, sizeof(_tds__GetClientCertificateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetClientCertificateMode *)soap_instantiate__tds__GetClientCertificateMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(_tds__GetClientCertificateMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetClientCertificateMode(soap, tag ? tag : "tds:GetClientCertificateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetClientCertificateMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificates(struct soap *soap, const char *tag, int id, _tds__LoadCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__LoadCertificates ? type : NULL);
}

SOAP_FMAC3 _tds__LoadCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificates(struct soap *soap, const char *tag, _tds__LoadCertificates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCertificates **)soap_malloc(soap, sizeof(_tds__LoadCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCertificates *)soap_instantiate__tds__LoadCertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__LoadCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificates, sizeof(_tds__LoadCertificates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__LoadCertificates(soap, tag ? tag : "tds:LoadCertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPkcs10Request))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, _tds__GetPkcs10Request *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPkcs10Request, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetPkcs10Request ? type : NULL);
}

SOAP_FMAC3 _tds__GetPkcs10Request ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPkcs10Request(struct soap *soap, const char *tag, _tds__GetPkcs10Request **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetPkcs10Request **)soap_malloc(soap, sizeof(_tds__GetPkcs10Request *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetPkcs10Request *)soap_instantiate__tds__GetPkcs10Request(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetPkcs10Request **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(_tds__GetPkcs10Request), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetPkcs10Request(soap, tag ? tag : "tds:GetPkcs10Request", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetPkcs10Request ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteCertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteCertificates(struct soap *soap, const char *tag, int id, _tds__DeleteCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteCertificates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__DeleteCertificates ? type : NULL);
}

SOAP_FMAC3 _tds__DeleteCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteCertificates(struct soap *soap, const char *tag, _tds__DeleteCertificates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteCertificates **)soap_malloc(soap, sizeof(_tds__DeleteCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteCertificates *)soap_instantiate__tds__DeleteCertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__DeleteCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteCertificates, sizeof(_tds__DeleteCertificates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteCertificates(soap, tag ? tag : "tds:DeleteCertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetCertificatesStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, _tds__SetCertificatesStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetCertificatesStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetCertificatesStatus ? type : NULL);
}

SOAP_FMAC3 _tds__SetCertificatesStatus ** SOAP_FMAC4 soap_in_PointerTo_tds__SetCertificatesStatus(struct soap *soap, const char *tag, _tds__SetCertificatesStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetCertificatesStatus **)soap_malloc(soap, sizeof(_tds__SetCertificatesStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetCertificatesStatus *)soap_instantiate__tds__SetCertificatesStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(_tds__SetCertificatesStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetCertificatesStatus(soap, tag ? tag : "tds:SetCertificatesStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetCertificatesStatus ** SOAP_FMAC4 soap_get_PointerTo_tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, _tds__GetCertificatesStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetCertificatesStatus ? type : NULL);
}

SOAP_FMAC3 _tds__GetCertificatesStatus ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesStatus(struct soap *soap, const char *tag, _tds__GetCertificatesStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificatesStatus **)soap_malloc(soap, sizeof(_tds__GetCertificatesStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificatesStatus *)soap_instantiate__tds__GetCertificatesStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(_tds__GetCertificatesStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCertificatesStatus(soap, tag ? tag : "tds:GetCertificatesStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificatesStatus ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificates(struct soap *soap, _tds__GetCertificates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificates(struct soap *soap, const char *tag, int id, _tds__GetCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetCertificates ? type : NULL);
}

SOAP_FMAC3 _tds__GetCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificates(struct soap *soap, const char *tag, _tds__GetCertificates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificates **)soap_malloc(soap, sizeof(_tds__GetCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificates *)soap_instantiate__tds__GetCertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificates, sizeof(_tds__GetCertificates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificates(struct soap *soap, _tds__GetCertificates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCertificates(soap, tag ? tag : "tds:GetCertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificates(struct soap *soap, _tds__GetCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateCertificate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateCertificate(struct soap *soap, const char *tag, int id, _tds__CreateCertificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateCertificate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__CreateCertificate ? type : NULL);
}

SOAP_FMAC3 _tds__CreateCertificate ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateCertificate(struct soap *soap, const char *tag, _tds__CreateCertificate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateCertificate **)soap_malloc(soap, sizeof(_tds__CreateCertificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateCertificate *)soap_instantiate__tds__CreateCertificate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__CreateCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateCertificate, sizeof(_tds__CreateCertificate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__CreateCertificate(soap, tag ? tag : "tds:CreateCertificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateCertificate ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetAccessPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, _tds__SetAccessPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetAccessPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetAccessPolicy ? type : NULL);
}

SOAP_FMAC3 _tds__SetAccessPolicy ** SOAP_FMAC4 soap_in_PointerTo_tds__SetAccessPolicy(struct soap *soap, const char *tag, _tds__SetAccessPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetAccessPolicy **)soap_malloc(soap, sizeof(_tds__SetAccessPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetAccessPolicy *)soap_instantiate__tds__SetAccessPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(_tds__SetAccessPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetAccessPolicy(soap, tag ? tag : "tds:SetAccessPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetAccessPolicy ** SOAP_FMAC4 soap_get_PointerTo_tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAccessPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, _tds__GetAccessPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAccessPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetAccessPolicy ? type : NULL);
}

SOAP_FMAC3 _tds__GetAccessPolicy ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAccessPolicy(struct soap *soap, const char *tag, _tds__GetAccessPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetAccessPolicy **)soap_malloc(soap, sizeof(_tds__GetAccessPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetAccessPolicy *)soap_instantiate__tds__GetAccessPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(_tds__GetAccessPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetAccessPolicy(soap, tag ? tag : "tds:GetAccessPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetAccessPolicy ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__RemoveIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveIPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__RemoveIPAddressFilter ? type : NULL);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RemoveIPAddressFilter **)soap_malloc(soap, sizeof(_tds__RemoveIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RemoveIPAddressFilter *)soap_instantiate__tds__RemoveIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__RemoveIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(_tds__RemoveIPAddressFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, tag ? tag : "tds:RemoveIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__AddIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddIPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__AddIPAddressFilter ? type : NULL);
}

SOAP_FMAC3 _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, _tds__AddIPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__AddIPAddressFilter **)soap_malloc(soap, sizeof(_tds__AddIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__AddIPAddressFilter *)soap_instantiate__tds__AddIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__AddIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(_tds__AddIPAddressFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__AddIPAddressFilter(soap, tag ? tag : "tds:AddIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__SetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetIPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetIPAddressFilter ? type : NULL);
}

SOAP_FMAC3 _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, _tds__SetIPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetIPAddressFilter **)soap_malloc(soap, sizeof(_tds__SetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetIPAddressFilter *)soap_instantiate__tds__SetIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(_tds__SetIPAddressFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetIPAddressFilter(soap, tag ? tag : "tds:SetIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__GetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetIPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetIPAddressFilter ? type : NULL);
}

SOAP_FMAC3 _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, _tds__GetIPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetIPAddressFilter **)soap_malloc(soap, sizeof(_tds__GetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetIPAddressFilter *)soap_instantiate__tds__GetIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(_tds__GetIPAddressFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetIPAddressFilter(soap, tag ? tag : "tds:GetIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetZeroConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, _tds__SetZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetZeroConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetZeroConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetZeroConfiguration(struct soap *soap, const char *tag, _tds__SetZeroConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetZeroConfiguration **)soap_malloc(soap, sizeof(_tds__SetZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetZeroConfiguration *)soap_instantiate__tds__SetZeroConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(_tds__SetZeroConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetZeroConfiguration(soap, tag ? tag : "tds:SetZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetZeroConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, _tds__GetZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetZeroConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetZeroConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetZeroConfiguration(struct soap *soap, const char *tag, _tds__GetZeroConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetZeroConfiguration **)soap_malloc(soap, sizeof(_tds__GetZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetZeroConfiguration *)soap_instantiate__tds__GetZeroConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(_tds__GetZeroConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetZeroConfiguration(soap, tag ? tag : "tds:GetZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkDefaultGateway))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, _tds__SetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkDefaultGateway, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetNetworkDefaultGateway ? type : NULL);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGateway **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkDefaultGateway **)soap_malloc(soap, sizeof(_tds__SetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkDefaultGateway *)soap_instantiate__tds__SetNetworkDefaultGateway(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(_tds__SetNetworkDefaultGateway), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, tag ? tag : "tds:SetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkDefaultGateway))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, _tds__GetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkDefaultGateway, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetNetworkDefaultGateway ? type : NULL);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGateway **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkDefaultGateway **)soap_malloc(soap, sizeof(_tds__GetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkDefaultGateway *)soap_instantiate__tds__GetNetworkDefaultGateway(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(_tds__GetNetworkDefaultGateway), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, tag ? tag : "tds:GetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkProtocols))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, _tds__SetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkProtocols, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetNetworkProtocols ? type : NULL);
}

SOAP_FMAC3 _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, _tds__SetNetworkProtocols **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkProtocols **)soap_malloc(soap, sizeof(_tds__SetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkProtocols *)soap_instantiate__tds__SetNetworkProtocols(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(_tds__SetNetworkProtocols), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, tag ? tag : "tds:SetNetworkProtocols", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkProtocols))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, _tds__GetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkProtocols, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetNetworkProtocols ? type : NULL);
}

SOAP_FMAC3 _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, _tds__GetNetworkProtocols **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkProtocols **)soap_malloc(soap, sizeof(_tds__GetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkProtocols *)soap_instantiate__tds__GetNetworkProtocols(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(_tds__GetNetworkProtocols), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, tag ? tag : "tds:GetNetworkProtocols", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkInterfaces))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, _tds__SetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkInterfaces, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetNetworkInterfaces ? type : NULL);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, _tds__SetNetworkInterfaces **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkInterfaces **)soap_malloc(soap, sizeof(_tds__SetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkInterfaces *)soap_instantiate__tds__SetNetworkInterfaces(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(_tds__SetNetworkInterfaces), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, tag ? tag : "tds:SetNetworkInterfaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkInterfaces))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, _tds__GetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkInterfaces, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetNetworkInterfaces ? type : NULL);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, _tds__GetNetworkInterfaces **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkInterfaces **)soap_malloc(soap, sizeof(_tds__GetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkInterfaces *)soap_instantiate__tds__GetNetworkInterfaces(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(_tds__GetNetworkInterfaces), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, tag ? tag : "tds:GetNetworkInterfaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDynamicDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, _tds__SetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDynamicDNS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetDynamicDNS ? type : NULL);
}

SOAP_FMAC3 _tds__SetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, _tds__SetDynamicDNS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDynamicDNS **)soap_malloc(soap, sizeof(_tds__SetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDynamicDNS *)soap_instantiate__tds__SetDynamicDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(_tds__SetDynamicDNS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, tag ? tag : "tds:SetDynamicDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDynamicDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, _tds__GetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDynamicDNS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDynamicDNS ? type : NULL);
}

SOAP_FMAC3 _tds__GetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, _tds__GetDynamicDNS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDynamicDNS **)soap_malloc(soap, sizeof(_tds__GetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDynamicDNS *)soap_instantiate__tds__GetDynamicDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(_tds__GetDynamicDNS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, tag ? tag : "tds:GetDynamicDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNTP(struct soap *soap, _tds__SetNTP *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNTP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, int id, _tds__SetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNTP, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetNTP ? type : NULL);
}

SOAP_FMAC3 _tds__SetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, _tds__SetNTP **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNTP **)soap_malloc(soap, sizeof(_tds__SetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNTP *)soap_instantiate__tds__SetNTP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTP, sizeof(_tds__SetNTP), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNTP(struct soap *soap, _tds__SetNTP *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetNTP(soap, tag ? tag : "tds:SetNTP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNTP(struct soap *soap, _tds__SetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNTP(struct soap *soap, _tds__GetNTP *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNTP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, int id, _tds__GetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNTP, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetNTP ? type : NULL);
}

SOAP_FMAC3 _tds__GetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, _tds__GetNTP **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNTP **)soap_malloc(soap, sizeof(_tds__GetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNTP *)soap_instantiate__tds__GetNTP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTP, sizeof(_tds__GetNTP), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNTP(struct soap *soap, _tds__GetNTP *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetNTP(soap, tag ? tag : "tds:GetNTP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNTP(struct soap *soap, _tds__GetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDNS(struct soap *soap, _tds__SetDNS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, int id, _tds__SetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDNS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetDNS ? type : NULL);
}

SOAP_FMAC3 _tds__SetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, _tds__SetDNS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDNS **)soap_malloc(soap, sizeof(_tds__SetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDNS *)soap_instantiate__tds__SetDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNS, sizeof(_tds__SetDNS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDNS(struct soap *soap, _tds__SetDNS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetDNS(soap, tag ? tag : "tds:SetDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDNS(struct soap *soap, _tds__SetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDNS(struct soap *soap, _tds__GetDNS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, int id, _tds__GetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDNS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDNS ? type : NULL);
}

SOAP_FMAC3 _tds__GetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, _tds__GetDNS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDNS **)soap_malloc(soap, sizeof(_tds__GetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDNS *)soap_instantiate__tds__GetDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNS, sizeof(_tds__GetDNS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDNS(struct soap *soap, _tds__GetDNS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDNS(soap, tag ? tag : "tds:GetDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDNS(struct soap *soap, _tds__GetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameFromDHCP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, _tds__SetHostnameFromDHCP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameFromDHCP, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetHostnameFromDHCP ? type : NULL);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCP **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetHostnameFromDHCP **)soap_malloc(soap, sizeof(_tds__SetHostnameFromDHCP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetHostnameFromDHCP *)soap_instantiate__tds__SetHostnameFromDHCP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetHostnameFromDHCP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(_tds__SetHostnameFromDHCP), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, tag ? tag : "tds:SetHostnameFromDHCP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostname(struct soap *soap, _tds__SetHostname *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostname))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, int id, _tds__SetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostname, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetHostname ? type : NULL);
}

SOAP_FMAC3 _tds__SetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, _tds__SetHostname **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetHostname **)soap_malloc(soap, sizeof(_tds__SetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetHostname *)soap_instantiate__tds__SetHostname(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostname, sizeof(_tds__SetHostname), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostname(struct soap *soap, _tds__SetHostname *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetHostname(soap, tag ? tag : "tds:SetHostname", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostname(struct soap *soap, _tds__SetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetHostname(struct soap *soap, _tds__GetHostname *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetHostname))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, int id, _tds__GetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetHostname, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetHostname ? type : NULL);
}

SOAP_FMAC3 _tds__GetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, _tds__GetHostname **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetHostname **)soap_malloc(soap, sizeof(_tds__GetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetHostname *)soap_instantiate__tds__GetHostname(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostname, sizeof(_tds__GetHostname), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetHostname(struct soap *soap, _tds__GetHostname *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetHostname(soap, tag ? tag : "tds:GetHostname", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__GetHostname(struct soap *soap, _tds__GetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDPAddresses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDPAddresses(struct soap *soap, const char *tag, int id, _tds__SetDPAddresses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDPAddresses, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetDPAddresses ? type : NULL);
}

SOAP_FMAC3 _tds__SetDPAddresses ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDPAddresses(struct soap *soap, const char *tag, _tds__SetDPAddresses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDPAddresses **)soap_malloc(soap, sizeof(_tds__SetDPAddresses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDPAddresses *)soap_instantiate__tds__SetDPAddresses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDPAddresses, sizeof(_tds__SetDPAddresses), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetDPAddresses(soap, tag ? tag : "tds:SetDPAddresses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDPAddresses ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, int id, _tds__GetCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetCapabilities ? type : NULL);
}

SOAP_FMAC3 _tds__GetCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, _tds__GetCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCapabilities **)soap_malloc(soap, sizeof(_tds__GetCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCapabilities *)soap_instantiate__tds__GetCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilities, sizeof(_tds__GetCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCapabilities(soap, tag ? tag : "tds:GetCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, _tds__SetAuthFailureWarningConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, _tds__SetAuthFailureWarningConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetAuthFailureWarningConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, _tds__SetAuthFailureWarningConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetAuthFailureWarningConfiguration **)soap_malloc(soap, sizeof(_tds__SetAuthFailureWarningConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetAuthFailureWarningConfiguration *)soap_instantiate__tds__SetAuthFailureWarningConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetAuthFailureWarningConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, sizeof(_tds__SetAuthFailureWarningConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, _tds__SetAuthFailureWarningConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, tag ? tag : "tds:SetAuthFailureWarningConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, _tds__SetAuthFailureWarningConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, _tds__GetAuthFailureWarningConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, _tds__GetAuthFailureWarningConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetAuthFailureWarningConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetAuthFailureWarningConfiguration **)soap_malloc(soap, sizeof(_tds__GetAuthFailureWarningConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetAuthFailureWarningConfiguration *)soap_instantiate__tds__GetAuthFailureWarningConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetAuthFailureWarningConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, sizeof(_tds__GetAuthFailureWarningConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, _tds__GetAuthFailureWarningConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, tag ? tag : "tds:GetAuthFailureWarningConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, _tds__GetAuthFailureWarningConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, _tds__GetAuthFailureWarningOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAuthFailureWarningOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, int id, _tds__GetAuthFailureWarningOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAuthFailureWarningOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetAuthFailureWarningOptions ? type : NULL);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptions ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetAuthFailureWarningOptions **)soap_malloc(soap, sizeof(_tds__GetAuthFailureWarningOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetAuthFailureWarningOptions *)soap_instantiate__tds__GetAuthFailureWarningOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetAuthFailureWarningOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAuthFailureWarningOptions, sizeof(_tds__GetAuthFailureWarningOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, _tds__GetAuthFailureWarningOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetAuthFailureWarningOptions(soap, tag ? tag : "tds:GetAuthFailureWarningOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptions ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, _tds__GetAuthFailureWarningOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAuthFailureWarningOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, _tds__SetPasswordHistoryConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetPasswordHistoryConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, _tds__SetPasswordHistoryConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetPasswordHistoryConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, _tds__SetPasswordHistoryConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetPasswordHistoryConfiguration **)soap_malloc(soap, sizeof(_tds__SetPasswordHistoryConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetPasswordHistoryConfiguration *)soap_instantiate__tds__SetPasswordHistoryConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetPasswordHistoryConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, sizeof(_tds__SetPasswordHistoryConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, _tds__SetPasswordHistoryConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetPasswordHistoryConfiguration(soap, tag ? tag : "tds:SetPasswordHistoryConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, _tds__SetPasswordHistoryConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, _tds__GetPasswordHistoryConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPasswordHistoryConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, _tds__GetPasswordHistoryConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetPasswordHistoryConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, _tds__GetPasswordHistoryConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetPasswordHistoryConfiguration **)soap_malloc(soap, sizeof(_tds__GetPasswordHistoryConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetPasswordHistoryConfiguration *)soap_instantiate__tds__GetPasswordHistoryConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetPasswordHistoryConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, sizeof(_tds__GetPasswordHistoryConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, _tds__GetPasswordHistoryConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetPasswordHistoryConfiguration(soap, tag ? tag : "tds:GetPasswordHistoryConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, _tds__GetPasswordHistoryConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, _tds__SetPasswordComplexityConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetPasswordComplexityConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, _tds__SetPasswordComplexityConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetPasswordComplexityConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, _tds__SetPasswordComplexityConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetPasswordComplexityConfiguration **)soap_malloc(soap, sizeof(_tds__SetPasswordComplexityConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetPasswordComplexityConfiguration *)soap_instantiate__tds__SetPasswordComplexityConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetPasswordComplexityConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, sizeof(_tds__SetPasswordComplexityConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, _tds__SetPasswordComplexityConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetPasswordComplexityConfiguration(soap, tag ? tag : "tds:SetPasswordComplexityConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, _tds__SetPasswordComplexityConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, _tds__GetPasswordComplexityConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPasswordComplexityConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, _tds__GetPasswordComplexityConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetPasswordComplexityConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, _tds__GetPasswordComplexityConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetPasswordComplexityConfiguration **)soap_malloc(soap, sizeof(_tds__GetPasswordComplexityConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetPasswordComplexityConfiguration *)soap_instantiate__tds__GetPasswordComplexityConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetPasswordComplexityConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, sizeof(_tds__GetPasswordComplexityConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, _tds__GetPasswordComplexityConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetPasswordComplexityConfiguration(soap, tag ? tag : "tds:GetPasswordComplexityConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, _tds__GetPasswordComplexityConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, _tds__GetPasswordComplexityOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPasswordComplexityOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, int id, _tds__GetPasswordComplexityOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPasswordComplexityOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetPasswordComplexityOptions ? type : NULL);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptions ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, _tds__GetPasswordComplexityOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetPasswordComplexityOptions **)soap_malloc(soap, sizeof(_tds__GetPasswordComplexityOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetPasswordComplexityOptions *)soap_instantiate__tds__GetPasswordComplexityOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetPasswordComplexityOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPasswordComplexityOptions, sizeof(_tds__GetPasswordComplexityOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, _tds__GetPasswordComplexityOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetPasswordComplexityOptions(soap, tag ? tag : "tds:GetPasswordComplexityOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptions ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, _tds__GetPasswordComplexityOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPasswordComplexityOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetWsdlUrl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, _tds__GetWsdlUrl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetWsdlUrl, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetWsdlUrl ? type : NULL);
}

SOAP_FMAC3 _tds__GetWsdlUrl ** SOAP_FMAC4 soap_in_PointerTo_tds__GetWsdlUrl(struct soap *soap, const char *tag, _tds__GetWsdlUrl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetWsdlUrl **)soap_malloc(soap, sizeof(_tds__GetWsdlUrl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetWsdlUrl *)soap_instantiate__tds__GetWsdlUrl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetWsdlUrl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(_tds__GetWsdlUrl), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetWsdlUrl(soap, tag ? tag : "tds:GetWsdlUrl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetWsdlUrl ** SOAP_FMAC4 soap_get_PointerTo_tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetUser(struct soap *soap, _tds__SetUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetUser(struct soap *soap, const char *tag, int id, _tds__SetUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetUser, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetUser ? type : NULL);
}

SOAP_FMAC3 _tds__SetUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetUser(struct soap *soap, const char *tag, _tds__SetUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetUser **)soap_malloc(soap, sizeof(_tds__SetUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetUser *)soap_instantiate__tds__SetUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUser, sizeof(_tds__SetUser), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetUser(struct soap *soap, _tds__SetUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetUser(soap, tag ? tag : "tds:SetUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetUser(struct soap *soap, _tds__SetUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteUsers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, int id, _tds__DeleteUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteUsers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__DeleteUsers ? type : NULL);
}

SOAP_FMAC3 _tds__DeleteUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, _tds__DeleteUsers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteUsers **)soap_malloc(soap, sizeof(_tds__DeleteUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteUsers *)soap_instantiate__tds__DeleteUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__DeleteUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsers, sizeof(_tds__DeleteUsers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteUsers(soap, tag ? tag : "tds:DeleteUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateUsers(struct soap *soap, _tds__CreateUsers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateUsers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, int id, _tds__CreateUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateUsers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__CreateUsers ? type : NULL);
}

SOAP_FMAC3 _tds__CreateUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, _tds__CreateUsers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateUsers **)soap_malloc(soap, sizeof(_tds__CreateUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateUsers *)soap_instantiate__tds__CreateUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__CreateUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsers, sizeof(_tds__CreateUsers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateUsers(struct soap *soap, _tds__CreateUsers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__CreateUsers(soap, tag ? tag : "tds:CreateUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateUsers(struct soap *soap, _tds__CreateUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetUsers(struct soap *soap, _tds__GetUsers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetUsers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, int id, _tds__GetUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetUsers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetUsers ? type : NULL);
}

SOAP_FMAC3 _tds__GetUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, _tds__GetUsers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetUsers **)soap_malloc(soap, sizeof(_tds__GetUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetUsers *)soap_instantiate__tds__GetUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsers, sizeof(_tds__GetUsers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetUsers(struct soap *soap, _tds__GetUsers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetUsers(soap, tag ? tag : "tds:GetUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__GetUsers(struct soap *soap, _tds__GetUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteUser(struct soap *soap, const char *tag, int id, _tds__SetRemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteUser, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetRemoteUser ? type : NULL);
}

SOAP_FMAC3 _tds__SetRemoteUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteUser(struct soap *soap, const char *tag, _tds__SetRemoteUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRemoteUser **)soap_malloc(soap, sizeof(_tds__SetRemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRemoteUser *)soap_instantiate__tds__SetRemoteUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteUser, sizeof(_tds__SetRemoteUser), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetRemoteUser(soap, tag ? tag : "tds:SetRemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRemoteUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteUser(struct soap *soap, const char *tag, int id, _tds__GetRemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteUser, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetRemoteUser ? type : NULL);
}

SOAP_FMAC3 _tds__GetRemoteUser ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteUser(struct soap *soap, const char *tag, _tds__GetRemoteUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRemoteUser **)soap_malloc(soap, sizeof(_tds__GetRemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRemoteUser *)soap_instantiate__tds__GetRemoteUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteUser, sizeof(_tds__GetRemoteUser), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetRemoteUser(soap, tag ? tag : "tds:GetRemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRemoteUser ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetEndpointReference))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetEndpointReference(struct soap *soap, const char *tag, int id, _tds__GetEndpointReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetEndpointReference, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetEndpointReference ? type : NULL);
}

SOAP_FMAC3 _tds__GetEndpointReference ** SOAP_FMAC4 soap_in_PointerTo_tds__GetEndpointReference(struct soap *soap, const char *tag, _tds__GetEndpointReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetEndpointReference **)soap_malloc(soap, sizeof(_tds__GetEndpointReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetEndpointReference *)soap_instantiate__tds__GetEndpointReference(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetEndpointReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetEndpointReference, sizeof(_tds__GetEndpointReference), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetEndpointReference(soap, tag ? tag : "tds:GetEndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetEndpointReference ** SOAP_FMAC4 soap_get_PointerTo_tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDPAddresses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDPAddresses(struct soap *soap, const char *tag, int id, _tds__GetDPAddresses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDPAddresses, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDPAddresses ? type : NULL);
}

SOAP_FMAC3 _tds__GetDPAddresses ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDPAddresses(struct soap *soap, const char *tag, _tds__GetDPAddresses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDPAddresses **)soap_malloc(soap, sizeof(_tds__GetDPAddresses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDPAddresses *)soap_instantiate__tds__GetDPAddresses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDPAddresses, sizeof(_tds__GetDPAddresses), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDPAddresses(soap, tag ? tag : "tds:GetDPAddresses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDPAddresses ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__SetRemoteDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteDiscoveryMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetRemoteDiscoveryMode ? type : NULL);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, _tds__SetRemoteDiscoveryMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(_tds__SetRemoteDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRemoteDiscoveryMode *)soap_instantiate__tds__SetRemoteDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(_tds__SetRemoteDiscoveryMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag ? tag : "tds:SetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__GetRemoteDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteDiscoveryMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetRemoteDiscoveryMode ? type : NULL);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, _tds__GetRemoteDiscoveryMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(_tds__GetRemoteDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRemoteDiscoveryMode *)soap_instantiate__tds__GetRemoteDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(_tds__GetRemoteDiscoveryMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag ? tag : "tds:GetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__SetDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDiscoveryMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetDiscoveryMode ? type : NULL);
}

SOAP_FMAC3 _tds__SetDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDiscoveryMode(struct soap *soap, const char *tag, _tds__SetDiscoveryMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDiscoveryMode **)soap_malloc(soap, sizeof(_tds__SetDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDiscoveryMode *)soap_instantiate__tds__SetDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(_tds__SetDiscoveryMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetDiscoveryMode(soap, tag ? tag : "tds:SetDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__GetDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDiscoveryMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDiscoveryMode ? type : NULL);
}

SOAP_FMAC3 _tds__GetDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDiscoveryMode(struct soap *soap, const char *tag, _tds__GetDiscoveryMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDiscoveryMode **)soap_malloc(soap, sizeof(_tds__GetDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDiscoveryMode *)soap_instantiate__tds__GetDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(_tds__GetDiscoveryMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDiscoveryMode(soap, tag ? tag : "tds:GetDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveScopes(struct soap *soap, const char *tag, int id, _tds__RemoveScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveScopes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__RemoveScopes ? type : NULL);
}

SOAP_FMAC3 _tds__RemoveScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveScopes(struct soap *soap, const char *tag, _tds__RemoveScopes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RemoveScopes **)soap_malloc(soap, sizeof(_tds__RemoveScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RemoveScopes *)soap_instantiate__tds__RemoveScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__RemoveScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveScopes, sizeof(_tds__RemoveScopes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__RemoveScopes(soap, tag ? tag : "tds:RemoveScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RemoveScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddScopes(struct soap *soap, _tds__AddScopes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddScopes(struct soap *soap, const char *tag, int id, _tds__AddScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddScopes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__AddScopes ? type : NULL);
}

SOAP_FMAC3 _tds__AddScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__AddScopes(struct soap *soap, const char *tag, _tds__AddScopes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__AddScopes **)soap_malloc(soap, sizeof(_tds__AddScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__AddScopes *)soap_instantiate__tds__AddScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__AddScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddScopes, sizeof(_tds__AddScopes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddScopes(struct soap *soap, _tds__AddScopes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__AddScopes(soap, tag ? tag : "tds:AddScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__AddScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__AddScopes(struct soap *soap, _tds__AddScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, int id, _tds__SetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetScopes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetScopes ? type : NULL);
}

SOAP_FMAC3 _tds__SetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, _tds__SetScopes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetScopes **)soap_malloc(soap, sizeof(_tds__SetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetScopes *)soap_instantiate__tds__SetScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopes, sizeof(_tds__SetScopes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetScopes(soap, tag ? tag : "tds:SetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, int id, _tds__GetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetScopes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetScopes ? type : NULL);
}

SOAP_FMAC3 _tds__GetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, _tds__GetScopes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetScopes **)soap_malloc(soap, sizeof(_tds__GetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetScopes *)soap_instantiate__tds__GetScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopes, sizeof(_tds__GetScopes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetScopes(soap, tag ? tag : "tds:GetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemSupportInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, _tds__GetSystemSupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemSupportInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemSupportInformation ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, _tds__GetSystemSupportInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemSupportInformation **)soap_malloc(soap, sizeof(_tds__GetSystemSupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemSupportInformation *)soap_instantiate__tds__GetSystemSupportInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemSupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(_tds__GetSystemSupportInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, tag ? tag : "tds:GetSystemSupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, int id, _tds__GetSystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemLog, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemLog ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemLog ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, _tds__GetSystemLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemLog **)soap_malloc(soap, sizeof(_tds__GetSystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemLog *)soap_instantiate__tds__GetSystemLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLog, sizeof(_tds__GetSystemLog), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemLog(soap, tag ? tag : "tds:GetSystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemLog ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, int id, _tds__GetSystemBackup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemBackup ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemBackup ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, _tds__GetSystemBackup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemBackup **)soap_malloc(soap, sizeof(_tds__GetSystemBackup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemBackup *)soap_instantiate__tds__GetSystemBackup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemBackup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackup, sizeof(_tds__GetSystemBackup), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, tag ? tag : "tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemBackup ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, int id, _tds__RestoreSystem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__RestoreSystem ? type : NULL);
}

SOAP_FMAC3 _tds__RestoreSystem ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, _tds__RestoreSystem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RestoreSystem **)soap_malloc(soap, sizeof(_tds__RestoreSystem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RestoreSystem *)soap_instantiate__tds__RestoreSystem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__RestoreSystem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystem, sizeof(_tds__RestoreSystem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__RestoreSystem(soap, tag ? tag : "tds:RestoreSystem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RestoreSystem ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemReboot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, int id, _tds__SystemReboot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemReboot, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SystemReboot ? type : NULL);
}

SOAP_FMAC3 _tds__SystemReboot ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, _tds__SystemReboot **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SystemReboot **)soap_malloc(soap, sizeof(_tds__SystemReboot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SystemReboot *)soap_instantiate__tds__SystemReboot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SystemReboot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemReboot, sizeof(_tds__SystemReboot), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SystemReboot(soap, tag ? tag : "tds:SystemReboot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SystemReboot ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmware))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, _tds__UpgradeSystemFirmware *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmware, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__UpgradeSystemFirmware ? type : NULL);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, _tds__UpgradeSystemFirmware **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__UpgradeSystemFirmware **)soap_malloc(soap, sizeof(_tds__UpgradeSystemFirmware *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__UpgradeSystemFirmware *)soap_instantiate__tds__UpgradeSystemFirmware(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__UpgradeSystemFirmware **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(_tds__UpgradeSystemFirmware), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, tag ? tag : "tds:UpgradeSystemFirmware", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, _tds__SetSystemFactoryDefault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetSystemFactoryDefault ? type : NULL);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, _tds__SetSystemFactoryDefault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetSystemFactoryDefault **)soap_malloc(soap, sizeof(_tds__SetSystemFactoryDefault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetSystemFactoryDefault *)soap_instantiate__tds__SetSystemFactoryDefault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetSystemFactoryDefault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(_tds__SetSystemFactoryDefault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, tag ? tag : "tds:SetSystemFactoryDefault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, _tds__GetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemDateAndTime ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, _tds__GetSystemDateAndTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemDateAndTime **)soap_malloc(soap, sizeof(_tds__GetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemDateAndTime *)soap_instantiate__tds__GetSystemDateAndTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(_tds__GetSystemDateAndTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, tag ? tag : "tds:GetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, _tds__SetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetSystemDateAndTime ? type : NULL);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, _tds__SetSystemDateAndTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetSystemDateAndTime **)soap_malloc(soap, sizeof(_tds__SetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetSystemDateAndTime *)soap_instantiate__tds__SetSystemDateAndTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(_tds__SetSystemDateAndTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, tag ? tag : "tds:SetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, _tds__GetDeviceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDeviceInformation ? type : NULL);
}

SOAP_FMAC3 _tds__GetDeviceInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, _tds__GetDeviceInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDeviceInformation **)soap_malloc(soap, sizeof(_tds__GetDeviceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDeviceInformation *)soap_instantiate__tds__GetDeviceInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDeviceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(_tds__GetDeviceInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, tag ? tag : "tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDeviceInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _tds__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetServiceCapabilities ? type : NULL);
}

SOAP_FMAC3 _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, _tds__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetServiceCapabilities **)soap_malloc(soap, sizeof(_tds__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetServiceCapabilities *)soap_instantiate__tds__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(_tds__GetServiceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, tag ? tag : "tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServices))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServices(struct soap *soap, const char *tag, int id, _tds__GetServices *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServices, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetServices ? type : NULL);
}

SOAP_FMAC3 _tds__GetServices ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServices(struct soap *soap, const char *tag, _tds__GetServices **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetServices **)soap_malloc(soap, sizeof(_tds__GetServices *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetServices *)soap_instantiate__tds__GetServices(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetServices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServices, sizeof(_tds__GetServices), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServices(soap, tag ? tag : "tds:GetServices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetServices ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(tt__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceExtension *)soap_instantiate_tt__NetworkInterfaceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, tag ? tag : "tt:NetworkInterfaceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterface))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, tt__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv6NetworkInterface ? type : NULL);
}

SOAP_FMAC3 tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, tt__IPv6NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6NetworkInterface *)soap_instantiate_tt__IPv6NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, tag ? tag : "tt:IPv6NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterface))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, tt__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv4NetworkInterface ? type : NULL);
}

SOAP_FMAC3 tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, tt__IPv4NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4NetworkInterface *)soap_instantiate_tt__IPv4NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, tag ? tag : "tt:IPv4NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceLink))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceLink, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceLink ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, tt__NetworkInterfaceLink **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(tt__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceLink *)soap_instantiate_tt__NetworkInterfaceLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, tag ? tag : "tt:NetworkInterfaceLink", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceInfo ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, tt__NetworkInterfaceInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(tt__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceInfo *)soap_instantiate_tt__NetworkInterfaceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, tag ? tag : "tt:NetworkInterfaceInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocalOrientation(struct soap *soap, tt__LocalOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocalOrientation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocalOrientation(struct soap *soap, const char *tag, int id, tt__LocalOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocalOrientation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LocalOrientation ? type : NULL);
}

SOAP_FMAC3 tt__LocalOrientation ** SOAP_FMAC4 soap_in_PointerTott__LocalOrientation(struct soap *soap, const char *tag, tt__LocalOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LocalOrientation **)soap_malloc(soap, sizeof(tt__LocalOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LocalOrientation *)soap_instantiate_tt__LocalOrientation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LocalOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalOrientation, sizeof(tt__LocalOrientation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocalOrientation(struct soap *soap, tt__LocalOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocalOrientation(soap, tag ? tag : "tt:LocalOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LocalOrientation ** SOAP_FMAC4 soap_get_PointerTott__LocalOrientation(struct soap *soap, tt__LocalOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocalOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocalLocation(struct soap *soap, tt__LocalLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocalLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocalLocation(struct soap *soap, const char *tag, int id, tt__LocalLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocalLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LocalLocation ? type : NULL);
}

SOAP_FMAC3 tt__LocalLocation ** SOAP_FMAC4 soap_in_PointerTott__LocalLocation(struct soap *soap, const char *tag, tt__LocalLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LocalLocation **)soap_malloc(soap, sizeof(tt__LocalLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LocalLocation *)soap_instantiate_tt__LocalLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LocalLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalLocation, sizeof(tt__LocalLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocalLocation(struct soap *soap, tt__LocalLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocalLocation(soap, tag ? tag : "tt:LocalLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LocalLocation ** SOAP_FMAC4 soap_get_PointerTott__LocalLocation(struct soap *soap, tt__LocalLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocalLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoOrientation(struct soap *soap, tt__GeoOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoOrientation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoOrientation(struct soap *soap, const char *tag, int id, tt__GeoOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoOrientation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__GeoOrientation ? type : NULL);
}

SOAP_FMAC3 tt__GeoOrientation ** SOAP_FMAC4 soap_in_PointerTott__GeoOrientation(struct soap *soap, const char *tag, tt__GeoOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GeoOrientation **)soap_malloc(soap, sizeof(tt__GeoOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GeoOrientation *)soap_instantiate_tt__GeoOrientation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__GeoOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoOrientation, sizeof(tt__GeoOrientation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoOrientation(struct soap *soap, tt__GeoOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoOrientation(soap, tag ? tag : "tt:GeoOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GeoOrientation ** SOAP_FMAC4 soap_get_PointerTott__GeoOrientation(struct soap *soap, tt__GeoOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoLocation(struct soap *soap, const char *tag, int id, tt__GeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__GeoLocation ? type : NULL);
}

SOAP_FMAC3 tt__GeoLocation ** SOAP_FMAC4 soap_in_PointerTott__GeoLocation(struct soap *soap, const char *tag, tt__GeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GeoLocation **)soap_malloc(soap, sizeof(tt__GeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GeoLocation *)soap_instantiate_tt__GeoLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__GeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GeoLocation ** SOAP_FMAC4 soap_get_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTofloat(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodouble(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EapMethodExtension(struct soap *soap, tt__EapMethodExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EapMethodExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EapMethodExtension(struct soap *soap, const char *tag, int id, tt__EapMethodExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EapMethodExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EapMethodExtension ? type : NULL);
}

SOAP_FMAC3 tt__EapMethodExtension ** SOAP_FMAC4 soap_in_PointerTott__EapMethodExtension(struct soap *soap, const char *tag, tt__EapMethodExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EapMethodExtension **)soap_malloc(soap, sizeof(tt__EapMethodExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EapMethodExtension *)soap_instantiate_tt__EapMethodExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EapMethodExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EapMethodExtension, sizeof(tt__EapMethodExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EapMethodExtension(struct soap *soap, tt__EapMethodExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EapMethodExtension(soap, tag ? tag : "tt:EapMethodExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EapMethodExtension ** SOAP_FMAC4 soap_get_PointerTott__EapMethodExtension(struct soap *soap, tt__EapMethodExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EapMethodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TLSConfiguration(struct soap *soap, tt__TLSConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TLSConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TLSConfiguration(struct soap *soap, const char *tag, int id, tt__TLSConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TLSConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__TLSConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__TLSConfiguration ** SOAP_FMAC4 soap_in_PointerTott__TLSConfiguration(struct soap *soap, const char *tag, tt__TLSConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TLSConfiguration **)soap_malloc(soap, sizeof(tt__TLSConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TLSConfiguration *)soap_instantiate_tt__TLSConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__TLSConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TLSConfiguration, sizeof(tt__TLSConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TLSConfiguration(struct soap *soap, tt__TLSConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TLSConfiguration(soap, tag ? tag : "tt:TLSConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TLSConfiguration ** SOAP_FMAC4 soap_get_PointerTott__TLSConfiguration(struct soap *soap, tt__TLSConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TLSConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot1XConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot1XConfigurationExtension(struct soap *soap, const char *tag, int id, tt__Dot1XConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot1XConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot1XConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__Dot1XConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot1XConfigurationExtension(struct soap *soap, const char *tag, tt__Dot1XConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot1XConfigurationExtension **)soap_malloc(soap, sizeof(tt__Dot1XConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot1XConfigurationExtension *)soap_instantiate_tt__Dot1XConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot1XConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(tt__Dot1XConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot1XConfigurationExtension(soap, tag ? tag : "tt:Dot1XConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot1XConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot1XConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EAPMethodConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EAPMethodConfiguration(struct soap *soap, const char *tag, int id, tt__EAPMethodConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EAPMethodConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EAPMethodConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__EAPMethodConfiguration ** SOAP_FMAC4 soap_in_PointerTott__EAPMethodConfiguration(struct soap *soap, const char *tag, tt__EAPMethodConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EAPMethodConfiguration **)soap_malloc(soap, sizeof(tt__EAPMethodConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EAPMethodConfiguration *)soap_instantiate_tt__EAPMethodConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EAPMethodConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(tt__EAPMethodConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EAPMethodConfiguration(soap, tag ? tag : "tt:EAPMethodConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EAPMethodConfiguration ** SOAP_FMAC4 soap_get_PointerTott__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EAPMethodConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateInformationExtension(struct soap *soap, const char *tag, int id, tt__CertificateInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CertificateInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__CertificateInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__CertificateInformationExtension(struct soap *soap, const char *tag, tt__CertificateInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateInformationExtension **)soap_malloc(soap, sizeof(tt__CertificateInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateInformationExtension *)soap_instantiate_tt__CertificateInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CertificateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(tt__CertificateInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateInformationExtension(soap, tag ? tag : "tt:CertificateInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTimeRange(struct soap *soap, tt__DateTimeRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTimeRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTimeRange(struct soap *soap, const char *tag, int id, tt__DateTimeRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTimeRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DateTimeRange ? type : NULL);
}

SOAP_FMAC3 tt__DateTimeRange ** SOAP_FMAC4 soap_in_PointerTott__DateTimeRange(struct soap *soap, const char *tag, tt__DateTimeRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DateTimeRange **)soap_malloc(soap, sizeof(tt__DateTimeRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DateTimeRange *)soap_instantiate_tt__DateTimeRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DateTimeRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTimeRange, sizeof(tt__DateTimeRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTimeRange(struct soap *soap, tt__DateTimeRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DateTimeRange(soap, tag ? tag : "tt:DateTimeRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DateTimeRange ** SOAP_FMAC4 soap_get_PointerTott__DateTimeRange(struct soap *soap, tt__DateTimeRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateUsage(struct soap *soap, tt__CertificateUsage *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateUsage))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateUsage(struct soap *soap, const char *tag, int id, tt__CertificateUsage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateUsage, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CertificateUsage ? type : NULL);
}

SOAP_FMAC3 tt__CertificateUsage ** SOAP_FMAC4 soap_in_PointerTott__CertificateUsage(struct soap *soap, const char *tag, tt__CertificateUsage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateUsage **)soap_malloc(soap, sizeof(tt__CertificateUsage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateUsage *)soap_instantiate_tt__CertificateUsage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CertificateUsage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateUsage, sizeof(tt__CertificateUsage), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateUsage(struct soap *soap, tt__CertificateUsage *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateUsage(soap, tag ? tag : "tt:CertificateUsage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateUsage ** SOAP_FMAC4 soap_get_PointerTott__CertificateUsage(struct soap *soap, tt__CertificateUsage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__UserExtension(struct soap *soap, tt__UserExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__UserExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__UserExtension(struct soap *soap, const char *tag, int id, tt__UserExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__UserExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__UserExtension ? type : NULL);
}

SOAP_FMAC3 tt__UserExtension ** SOAP_FMAC4 soap_in_PointerTott__UserExtension(struct soap *soap, const char *tag, tt__UserExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__UserExtension **)soap_malloc(soap, sizeof(tt__UserExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__UserExtension *)soap_instantiate_tt__UserExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__UserExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__UserExtension, sizeof(tt__UserExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__UserExtension(struct soap *soap, tt__UserExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__UserExtension(soap, tag ? tag : "tt:UserExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__UserExtension ** SOAP_FMAC4 soap_get_PointerTott__UserExtension(struct soap *soap, tt__UserExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Date(struct soap *soap, tt__Date *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Date))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Date(struct soap *soap, const char *tag, int id, tt__Date *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Date, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Date ? type : NULL);
}

SOAP_FMAC3 tt__Date ** SOAP_FMAC4 soap_in_PointerTott__Date(struct soap *soap, const char *tag, tt__Date **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Date **)soap_malloc(soap, sizeof(tt__Date *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Date *)soap_instantiate_tt__Date(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Date **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Date, sizeof(tt__Date), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Date(struct soap *soap, tt__Date *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Date(soap, tag ? tag : "tt:Date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Date ** SOAP_FMAC4 soap_get_PointerTott__Date(struct soap *soap, tt__Date **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Time(struct soap *soap, tt__Time *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Time))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Time(struct soap *soap, const char *tag, int id, tt__Time *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Time, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Time ? type : NULL);
}

SOAP_FMAC3 tt__Time ** SOAP_FMAC4 soap_in_PointerTott__Time(struct soap *soap, const char *tag, tt__Time **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Time **)soap_malloc(soap, sizeof(tt__Time *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Time *)soap_instantiate_tt__Time(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Time **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Time, sizeof(tt__Time), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Time(struct soap *soap, tt__Time *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Time(soap, tag ? tag : "tt:Time", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Time ** SOAP_FMAC4 soap_get_PointerTott__Time(struct soap *soap, tt__Time **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTimeExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, tt__SystemDateTimeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTimeExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemDateTimeExtension ? type : NULL);
}

SOAP_FMAC3 tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, tt__SystemDateTimeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemDateTimeExtension **)soap_malloc(soap, sizeof(tt__SystemDateTimeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemDateTimeExtension *)soap_instantiate_tt__SystemDateTimeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemDateTimeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(tt__SystemDateTimeExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, tag ? tag : "tt:SystemDateTimeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLogUri(struct soap *soap, tt__SystemLogUri *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLogUri))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLogUri(struct soap *soap, const char *tag, int id, tt__SystemLogUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLogUri, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemLogUri ? type : NULL);
}

SOAP_FMAC3 tt__SystemLogUri ** SOAP_FMAC4 soap_in_PointerTott__SystemLogUri(struct soap *soap, const char *tag, tt__SystemLogUri **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemLogUri **)soap_malloc(soap, sizeof(tt__SystemLogUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemLogUri *)soap_instantiate_tt__SystemLogUri(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemLogUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUri, sizeof(tt__SystemLogUri), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLogUri(struct soap *soap, tt__SystemLogUri *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLogUri(soap, tag ? tag : "tt:SystemLogUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemLogUri ** SOAP_FMAC4 soap_get_PointerTott__SystemLogUri(struct soap *soap, tt__SystemLogUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLogUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceExtension(struct soap *soap, const char *tag, int id, tt__AnalyticsDeviceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsDeviceExtension ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsDeviceExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceExtension(struct soap *soap, const char *tag, tt__AnalyticsDeviceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsDeviceExtension **)soap_malloc(soap, sizeof(tt__AnalyticsDeviceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsDeviceExtension *)soap_instantiate_tt__AnalyticsDeviceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsDeviceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(tt__AnalyticsDeviceExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceExtension(soap, tag ? tag : "tt:AnalyticsDeviceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsDeviceExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, tt__SystemCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemCapabilitiesExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__SystemCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemCapabilitiesExtension2 *)soap_instantiate_tt__SystemCapabilitiesExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(tt__SystemCapabilitiesExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, tag ? tag : "tt:SystemCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__SystemCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__SystemCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemCapabilitiesExtension *)soap_instantiate_tt__SystemCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(tt__SystemCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, tag ? tag : "tt:SystemCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, tt__SecurityCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SecurityCapabilitiesExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SecurityCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__SecurityCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SecurityCapabilitiesExtension2 *)soap_instantiate_tt__SecurityCapabilitiesExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(tt__SecurityCapabilitiesExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, tag ? tag : "tt:SecurityCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__SecurityCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SecurityCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SecurityCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__SecurityCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SecurityCapabilitiesExtension *)soap_instantiate_tt__SecurityCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(tt__SecurityCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, tag ? tag : "tt:SecurityCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, tt__NetworkCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkCapabilitiesExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__NetworkCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkCapabilitiesExtension2 *)soap_instantiate_tt__NetworkCapabilitiesExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(tt__NetworkCapabilitiesExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, tag ? tag : "tt:NetworkCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__NetworkCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__NetworkCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkCapabilitiesExtension *)soap_instantiate_tt__NetworkCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(tt__NetworkCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, tag ? tag : "tt:NetworkCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RealTimeStreamingCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__RealTimeStreamingCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RealTimeStreamingCapabilitiesExtension *)soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RealTimeStreamingCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(tt__RealTimeStreamingCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag ? tag : "tt:RealTimeStreamingCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, int id, tt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ProfileCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, tt__ProfileCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ProfileCapabilities **)soap_malloc(soap, sizeof(tt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ProfileCapabilities *)soap_instantiate_tt__ProfileCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(tt__ProfileCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileCapabilities(soap, tag ? tag : "tt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__MediaCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MediaCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, tt__MediaCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MediaCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__MediaCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MediaCapabilitiesExtension *)soap_instantiate_tt__MediaCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MediaCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(tt__MediaCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, tag ? tag : "tt:MediaCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, tt__RealTimeStreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RealTimeStreamingCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RealTimeStreamingCapabilities **)soap_malloc(soap, sizeof(tt__RealTimeStreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RealTimeStreamingCapabilities *)soap_instantiate_tt__RealTimeStreamingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RealTimeStreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(tt__RealTimeStreamingCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, tag ? tag : "tt:RealTimeStreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, tt__IOCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IOCapabilitiesExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension2(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IOCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__IOCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IOCapabilitiesExtension2 *)soap_instantiate_tt__IOCapabilitiesExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IOCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(tt__IOCapabilitiesExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, tag ? tag : "tt:IOCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__IOCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IOCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IOCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__IOCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IOCapabilitiesExtension *)soap_instantiate_tt__IOCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IOCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(tt__IOCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, tag ? tag : "tt:IOCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__DeviceCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DeviceCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, tt__DeviceCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__DeviceCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceCapabilitiesExtension *)soap_instantiate_tt__DeviceCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DeviceCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(tt__DeviceCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, tag ? tag : "tt:DeviceCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, int id, tt__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SecurityCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, tt__SecurityCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SecurityCapabilities **)soap_malloc(soap, sizeof(tt__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SecurityCapabilities *)soap_instantiate_tt__SecurityCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(tt__SecurityCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SecurityCapabilities(soap, tag ? tag : "tt:SecurityCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilities(struct soap *soap, tt__IOCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilities(struct soap *soap, const char *tag, int id, tt__IOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IOCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__IOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilities(struct soap *soap, const char *tag, tt__IOCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IOCapabilities **)soap_malloc(soap, sizeof(tt__IOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IOCapabilities *)soap_instantiate_tt__IOCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilities, sizeof(tt__IOCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilities(struct soap *soap, tt__IOCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IOCapabilities(soap, tag ? tag : "tt:IOCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilities(struct soap *soap, tt__IOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, int id, tt__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, tt__SystemCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemCapabilities **)soap_malloc(soap, sizeof(tt__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemCapabilities *)soap_instantiate_tt__SystemCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilities, sizeof(tt__SystemCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemCapabilities(soap, tag ? tag : "tt:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilities(struct soap *soap, tt__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, int id, tt__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, tt__NetworkCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkCapabilities **)soap_malloc(soap, sizeof(tt__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkCapabilities *)soap_instantiate_tt__NetworkCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(tt__NetworkCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkCapabilities(soap, tag ? tag : "tt:NetworkCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, tt__CapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CapabilitiesExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__CapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension2(struct soap *soap, const char *tag, tt__CapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__CapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CapabilitiesExtension2 *)soap_instantiate_tt__CapabilitiesExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(tt__CapabilitiesExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, tag ? tag : "tt:CapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, int id, tt__AnalyticsDeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsDeviceCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsDeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, tt__AnalyticsDeviceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsDeviceCapabilities **)soap_malloc(soap, sizeof(tt__AnalyticsDeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsDeviceCapabilities *)soap_instantiate_tt__AnalyticsDeviceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsDeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(tt__AnalyticsDeviceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, tag ? tag : "tt:AnalyticsDeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsDeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverCapabilities(struct soap *soap, const char *tag, int id, tt__ReceiverCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ReceiverCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__ReceiverCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ReceiverCapabilities(struct soap *soap, const char *tag, tt__ReceiverCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ReceiverCapabilities **)soap_malloc(soap, sizeof(tt__ReceiverCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ReceiverCapabilities *)soap_instantiate_tt__ReceiverCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ReceiverCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(tt__ReceiverCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReceiverCapabilities(soap, tag ? tag : "tt:ReceiverCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ReceiverCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReplayCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReplayCapabilities(struct soap *soap, const char *tag, int id, tt__ReplayCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReplayCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ReplayCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__ReplayCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ReplayCapabilities(struct soap *soap, const char *tag, tt__ReplayCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ReplayCapabilities **)soap_malloc(soap, sizeof(tt__ReplayCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ReplayCapabilities *)soap_instantiate_tt__ReplayCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ReplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(tt__ReplayCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReplayCapabilities(soap, tag ? tag : "tt:ReplayCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ReplayCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchCapabilities(struct soap *soap, tt__SearchCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchCapabilities(struct soap *soap, const char *tag, int id, tt__SearchCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SearchCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__SearchCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SearchCapabilities(struct soap *soap, const char *tag, tt__SearchCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SearchCapabilities **)soap_malloc(soap, sizeof(tt__SearchCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SearchCapabilities *)soap_instantiate_tt__SearchCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SearchCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchCapabilities, sizeof(tt__SearchCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchCapabilities(struct soap *soap, tt__SearchCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SearchCapabilities(soap, tag ? tag : "tt:SearchCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SearchCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SearchCapabilities(struct soap *soap, tt__SearchCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingCapabilities(struct soap *soap, const char *tag, int id, tt__RecordingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__RecordingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RecordingCapabilities(struct soap *soap, const char *tag, tt__RecordingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingCapabilities **)soap_malloc(soap, sizeof(tt__RecordingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingCapabilities *)soap_instantiate_tt__RecordingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(tt__RecordingCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingCapabilities(soap, tag ? tag : "tt:RecordingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DisplayCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DisplayCapabilities(struct soap *soap, const char *tag, int id, tt__DisplayCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DisplayCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DisplayCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__DisplayCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DisplayCapabilities(struct soap *soap, const char *tag, tt__DisplayCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DisplayCapabilities **)soap_malloc(soap, sizeof(tt__DisplayCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DisplayCapabilities *)soap_instantiate_tt__DisplayCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DisplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(tt__DisplayCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DisplayCapabilities(soap, tag ? tag : "tt:DisplayCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DisplayCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceIOCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, tt__DeviceIOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceIOCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DeviceIOCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__DeviceIOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceIOCapabilities(struct soap *soap, const char *tag, tt__DeviceIOCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceIOCapabilities **)soap_malloc(soap, sizeof(tt__DeviceIOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceIOCapabilities *)soap_instantiate_tt__DeviceIOCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DeviceIOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(tt__DeviceIOCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, tag ? tag : "tt:DeviceIOCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceIOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__CapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__CapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, tt__CapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CapabilitiesExtension **)soap_malloc(soap, sizeof(tt__CapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CapabilitiesExtension *)soap_instantiate_tt__CapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(tt__CapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CapabilitiesExtension(soap, tag ? tag : "tt:CapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, int id, tt__PTZCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__PTZCapabilities ** SOAP_FMAC4 soap_in_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, tt__PTZCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZCapabilities **)soap_malloc(soap, sizeof(tt__PTZCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZCapabilities *)soap_instantiate_tt__PTZCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZCapabilities, sizeof(tt__PTZCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZCapabilities(soap, tag ? tag : "tt:PTZCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZCapabilities ** SOAP_FMAC4 soap_get_PointerTott__PTZCapabilities(struct soap *soap, tt__PTZCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, int id, tt__MediaCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MediaCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__MediaCapabilities ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, tt__MediaCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MediaCapabilities **)soap_malloc(soap, sizeof(tt__MediaCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MediaCapabilities *)soap_instantiate_tt__MediaCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MediaCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilities, sizeof(tt__MediaCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaCapabilities(soap, tag ? tag : "tt:MediaCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MediaCapabilities ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilities(struct soap *soap, tt__MediaCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, int id, tt__ImagingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__ImagingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, tt__ImagingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingCapabilities **)soap_malloc(soap, sizeof(tt__ImagingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingCapabilities *)soap_instantiate_tt__ImagingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingCapabilities(soap, tag ? tag : "tt:ImagingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventCapabilities(struct soap *soap, const char *tag, int id, tt__EventCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EventCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__EventCapabilities ** SOAP_FMAC4 soap_in_PointerTott__EventCapabilities(struct soap *soap, const char *tag, tt__EventCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventCapabilities **)soap_malloc(soap, sizeof(tt__EventCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventCapabilities *)soap_instantiate_tt__EventCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EventCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventCapabilities(soap, tag ? tag : "tt:EventCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventCapabilities ** SOAP_FMAC4 soap_get_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, int id, tt__DeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DeviceCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__DeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, tt__DeviceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceCapabilities **)soap_malloc(soap, sizeof(tt__DeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceCapabilities *)soap_instantiate_tt__DeviceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceCapabilities(soap, tag ? tag : "tt:DeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, tt__AnalyticsCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, tt__AnalyticsCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsCapabilities **)soap_malloc(soap, sizeof(tt__AnalyticsCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsCapabilities *)soap_instantiate_tt__AnalyticsCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, tag ? tag : "tt:AnalyticsCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, int id, tt__Dot11AvailableNetworksExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11AvailableNetworksExtension ? type : NULL);
}

SOAP_FMAC3 tt__Dot11AvailableNetworksExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, tt__Dot11AvailableNetworksExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11AvailableNetworksExtension **)soap_malloc(soap, sizeof(tt__Dot11AvailableNetworksExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11AvailableNetworksExtension *)soap_instantiate_tt__Dot11AvailableNetworksExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11AvailableNetworksExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(tt__Dot11AvailableNetworksExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, tag ? tag : "tt:Dot11AvailableNetworksExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11AvailableNetworksExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SignalStrength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SignalStrength(struct soap *soap, const char *tag, int id, enum tt__Dot11SignalStrength *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SignalStrength, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11SignalStrength(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Dot11SignalStrength ** SOAP_FMAC4 soap_in_PointerTott__Dot11SignalStrength(struct soap *soap, const char *tag, enum tt__Dot11SignalStrength **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Dot11SignalStrength **)soap_malloc(soap, sizeof(enum tt__Dot11SignalStrength *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11SignalStrength(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11SignalStrength **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11SignalStrength(soap, tag ? tag : "tt:Dot11SignalStrength", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11SignalStrength ** SOAP_FMAC4 soap_get_PointerTott__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SignalStrength(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKSetExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, tt__Dot11PSKSetExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKSetExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11PSKSetExtension ? type : NULL);
}

SOAP_FMAC3 tt__Dot11PSKSetExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKSetExtension(struct soap *soap, const char *tag, tt__Dot11PSKSetExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11PSKSetExtension **)soap_malloc(soap, sizeof(tt__Dot11PSKSetExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11PSKSetExtension *)soap_instantiate_tt__Dot11PSKSetExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11PSKSetExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(tt__Dot11PSKSetExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, tag ? tag : "tt:Dot11PSKSetExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11PSKSetExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKPassphrase(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKPassphrase))
		soap_serialize_tt__Dot11PSKPassphrase(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKPassphrase(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKPassphrase, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSKPassphrase(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKPassphrase(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11PSKPassphrase(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKPassphrase, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKPassphrase(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11PSKPassphrase(soap, tag ? tag : "tt:Dot11PSKPassphrase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKPassphrase(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKPassphrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSK(struct soap *soap, xsd__hexBinary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_tt__Dot11PSK(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSK(struct soap *soap, const char *tag, int id, xsd__hexBinary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_tt__Dot11PSK, NULL);
	if (!*a || id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSK(soap, tag, id, *a, type);
}

SOAP_FMAC3 xsd__hexBinary ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSK(struct soap *soap, const char *tag, xsd__hexBinary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__hexBinary **)soap_malloc(soap, sizeof(xsd__hexBinary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11PSK(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSK, sizeof(xsd__hexBinary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSK(struct soap *soap, xsd__hexBinary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11PSK(soap, tag ? tag : "tt:Dot11PSK", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__hexBinary ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSK(struct soap *soap, xsd__hexBinary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, tt__Dot11SecurityConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11SecurityConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__Dot11SecurityConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, tt__Dot11SecurityConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11SecurityConfigurationExtension **)soap_malloc(soap, sizeof(tt__Dot11SecurityConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11SecurityConfigurationExtension *)soap_instantiate_tt__Dot11SecurityConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11SecurityConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(tt__Dot11SecurityConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, tag ? tag : "tt:Dot11SecurityConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11SecurityConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReferenceToken(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken))
		soap_serialize_tt__ReferenceToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReferenceToken(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReferenceToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReferenceToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__ReferenceToken(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReferenceToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReferenceToken(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__ReferenceToken(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKSet(struct soap *soap, const char *tag, int id, tt__Dot11PSKSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11PSKSet ? type : NULL);
}

SOAP_FMAC3 tt__Dot11PSKSet ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKSet(struct soap *soap, const char *tag, tt__Dot11PSKSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11PSKSet **)soap_malloc(soap, sizeof(tt__Dot11PSKSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11PSKSet *)soap_instantiate_tt__Dot11PSKSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11PSKSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(tt__Dot11PSKSet), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11PSKSet(soap, tag ? tag : "tt:Dot11PSKSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11PSKSet ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Cipher);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Cipher(struct soap *soap, const char *tag, int id, enum tt__Dot11Cipher *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Cipher, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Cipher(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Dot11Cipher ** SOAP_FMAC4 soap_in_PointerTott__Dot11Cipher(struct soap *soap, const char *tag, enum tt__Dot11Cipher **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Dot11Cipher **)soap_malloc(soap, sizeof(enum tt__Dot11Cipher *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Cipher(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11Cipher **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Cipher(soap, tag ? tag : "tt:Dot11Cipher", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11Cipher ** SOAP_FMAC4 soap_get_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Cipher(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SecurityConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, tt__Dot11SecurityConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SecurityConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11SecurityConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__Dot11SecurityConfiguration ** SOAP_FMAC4 soap_in_PointerTott__Dot11SecurityConfiguration(struct soap *soap, const char *tag, tt__Dot11SecurityConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11SecurityConfiguration **)soap_malloc(soap, sizeof(tt__Dot11SecurityConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11SecurityConfiguration *)soap_instantiate_tt__Dot11SecurityConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11SecurityConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(tt__Dot11SecurityConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, tag ? tag : "tt:Dot11SecurityConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11SecurityConfiguration ** SOAP_FMAC4 soap_get_PointerTott__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilterExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, tt__IPAddressFilterExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilterExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPAddressFilterExtension ? type : NULL);
}

SOAP_FMAC3 tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, tt__IPAddressFilterExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPAddressFilterExtension **)soap_malloc(soap, sizeof(tt__IPAddressFilterExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPAddressFilterExtension *)soap_instantiate_tt__IPAddressFilterExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPAddressFilterExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(tt__IPAddressFilterExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, tag ? tag : "tt:IPAddressFilterExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, int id, tt__NetworkZeroConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkZeroConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__NetworkZeroConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkZeroConfigurationExtension2 *)soap_instantiate_tt__NetworkZeroConfigurationExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkZeroConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(tt__NetworkZeroConfigurationExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension2(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, tt__NetworkZeroConfigurationExtension *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkZeroConfigurationExtension ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkZeroConfigurationExtension **)soap_malloc(soap, sizeof(tt__NetworkZeroConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkZeroConfigurationExtension *)soap_instantiate_tt__NetworkZeroConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkZeroConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(tt__NetworkZeroConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__IPv6DHCPConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, enum tt__IPv6DHCPConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6DHCPConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6DHCPConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__IPv6DHCPConfiguration **)soap_malloc(soap, sizeof(enum tt__IPv6DHCPConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6DHCPConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__IPv6DHCPConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, tag ? tag : "tt:IPv6DHCPConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceSetConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceSetConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__NetworkInterfaceSetConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceSetConfigurationExtension2 *)soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceSetConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(tt__NetworkInterfaceSetConfigurationExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceSetConfigurationExtension **)soap_malloc(soap, sizeof(tt__NetworkInterfaceSetConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceSetConfigurationExtension *)soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceSetConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(tt__NetworkInterfaceSetConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv6NetworkInterfaceSetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__IPv6NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6NetworkInterfaceSetConfiguration *)soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv6NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv6NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv4NetworkInterfaceSetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__IPv4NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4NetworkInterfaceSetConfiguration *)soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv4NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv4NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, tt__DynamicDNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DynamicDNSInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, tt__DynamicDNSInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DynamicDNSInformationExtension **)soap_malloc(soap, sizeof(tt__DynamicDNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DynamicDNSInformationExtension *)soap_instantiate_tt__DynamicDNSInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DynamicDNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(tt__DynamicDNSInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, tag ? tag : "tt:DynamicDNSInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, int id, tt__NTPInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NTPInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__NTPInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, tt__NTPInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NTPInformationExtension **)soap_malloc(soap, sizeof(tt__NTPInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NTPInformationExtension *)soap_instantiate_tt__NTPInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NTPInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(tt__NTPInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NTPInformationExtension(soap, tag ? tag : "tt:NTPInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NTPInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, int id, tt__DNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DNSInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__DNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, tt__DNSInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DNSInformationExtension **)soap_malloc(soap, sizeof(tt__DNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DNSInformationExtension *)soap_instantiate_tt__DNSInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(tt__DNSInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DNSInformationExtension(soap, tag ? tag : "tt:DNSInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, int id, tt__HostnameInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__HostnameInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__HostnameInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, tt__HostnameInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__HostnameInformationExtension **)soap_malloc(soap, sizeof(tt__HostnameInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__HostnameInformationExtension *)soap_instantiate_tt__HostnameInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__HostnameInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(tt__HostnameInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__HostnameInformationExtension(soap, tag ? tag : "tt:HostnameInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__HostnameInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHostExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, int id, tt__NetworkHostExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHostExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkHostExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkHostExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, tt__NetworkHostExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkHostExtension **)soap_malloc(soap, sizeof(tt__NetworkHostExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkHostExtension *)soap_instantiate_tt__NetworkHostExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkHostExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(tt__NetworkHostExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkHostExtension(soap, tag ? tag : "tt:NetworkHostExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkHostExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Address(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Address))
		soap_serialize_tt__IPv6Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Address(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IPv6Address(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Address, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Address(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6Address(soap, tag ? tag : "tt:IPv6Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IPv6Address(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Address(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Address))
		soap_serialize_tt__IPv4Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Address(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IPv4Address(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Address, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Address(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4Address(soap, tag ? tag : "tt:IPv4Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IPv4Address(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocolExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, tt__NetworkProtocolExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocolExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkProtocolExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, tt__NetworkProtocolExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkProtocolExtension **)soap_malloc(soap, sizeof(tt__NetworkProtocolExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkProtocolExtension *)soap_instantiate_tt__NetworkProtocolExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkProtocolExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(tt__NetworkProtocolExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, tag ? tag : "tt:NetworkProtocolExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6ConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, tt__IPv6ConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6ConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv6ConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, tt__IPv6ConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6ConfigurationExtension **)soap_malloc(soap, sizeof(tt__IPv6ConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6ConfigurationExtension *)soap_instantiate_tt__IPv6ConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv6ConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(tt__IPv6ConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, tag ? tag : "tt:IPv6ConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv6Address))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, tt__PrefixedIPv6Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv6Address, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PrefixedIPv6Address ? type : NULL);
}

SOAP_FMAC3 tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, tt__PrefixedIPv6Address **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PrefixedIPv6Address **)soap_malloc(soap, sizeof(tt__PrefixedIPv6Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PrefixedIPv6Address *)soap_instantiate_tt__PrefixedIPv6Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PrefixedIPv6Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag ? tag : "tt:PrefixedIPv6Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv4Address))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, tt__PrefixedIPv4Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv4Address, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PrefixedIPv4Address ? type : NULL);
}

SOAP_FMAC3 tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, tt__PrefixedIPv4Address **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PrefixedIPv4Address **)soap_malloc(soap, sizeof(tt__PrefixedIPv4Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PrefixedIPv4Address *)soap_instantiate_tt__PrefixedIPv4Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PrefixedIPv4Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag ? tag : "tt:PrefixedIPv4Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, int id, tt__IPv4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv4Configuration ? type : NULL);
}

SOAP_FMAC3 tt__IPv4Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, tt__IPv4Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4Configuration **)soap_malloc(soap, sizeof(tt__IPv4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4Configuration *)soap_instantiate_tt__IPv4Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Configuration, sizeof(tt__IPv4Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4Configuration(soap, tag ? tag : "tt:IPv4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv4Configuration(struct soap *soap, tt__IPv4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, int id, tt__IPv6Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv6Configuration ? type : NULL);
}

SOAP_FMAC3 tt__IPv6Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, tt__IPv6Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6Configuration **)soap_malloc(soap, sizeof(tt__IPv6Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6Configuration *)soap_instantiate_tt__IPv6Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv6Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Configuration, sizeof(tt__IPv6Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6Configuration(soap, tag ? tag : "tt:IPv6Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv6Configuration(struct soap *soap, tt__IPv6Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceConnectionSetting *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceConnectionSetting ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, tt__NetworkInterfaceConnectionSetting **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceConnectionSetting **)soap_malloc(soap, sizeof(tt__NetworkInterfaceConnectionSetting *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceConnectionSetting *)soap_instantiate_tt__NetworkInterfaceConnectionSetting(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceConnectionSetting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(tt__NetworkInterfaceConnectionSetting), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, tag ? tag : "tt:NetworkInterfaceConnectionSetting", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension2(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceExtension2 **)soap_malloc(soap, sizeof(tt__NetworkInterfaceExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceExtension2 *)soap_instantiate_tt__NetworkInterfaceExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(tt__NetworkInterfaceExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, tag ? tag : "tt:NetworkInterfaceExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Configuration(struct soap *soap, tt__Dot11Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Configuration(struct soap *soap, const char *tag, int id, tt__Dot11Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11Configuration ? type : NULL);
}

SOAP_FMAC3 tt__Dot11Configuration ** SOAP_FMAC4 soap_in_PointerTott__Dot11Configuration(struct soap *soap, const char *tag, tt__Dot11Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11Configuration **)soap_malloc(soap, sizeof(tt__Dot11Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11Configuration *)soap_instantiate_tt__Dot11Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Configuration, sizeof(tt__Dot11Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Configuration(struct soap *soap, tt__Dot11Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Configuration(soap, tag ? tag : "tt:Dot11Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11Configuration ** SOAP_FMAC4 soap_get_PointerTott__Dot11Configuration(struct soap *soap, tt__Dot11Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot3Configuration(struct soap *soap, tt__Dot3Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot3Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot3Configuration(struct soap *soap, const char *tag, int id, tt__Dot3Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot3Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot3Configuration ? type : NULL);
}

SOAP_FMAC3 tt__Dot3Configuration ** SOAP_FMAC4 soap_in_PointerTott__Dot3Configuration(struct soap *soap, const char *tag, tt__Dot3Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot3Configuration **)soap_malloc(soap, sizeof(tt__Dot3Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot3Configuration *)soap_instantiate_tt__Dot3Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot3Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot3Configuration, sizeof(tt__Dot3Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot3Configuration(struct soap *soap, tt__Dot3Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot3Configuration(soap, tag ? tag : "tt:Dot3Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot3Configuration ** SOAP_FMAC4 soap_get_PointerTott__Dot3Configuration(struct soap *soap, tt__Dot3Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocationEntity(struct soap *soap, tt__LocationEntity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocationEntity))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocationEntity(struct soap *soap, const char *tag, int id, tt__LocationEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocationEntity, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LocationEntity ? type : NULL);
}

SOAP_FMAC3 tt__LocationEntity ** SOAP_FMAC4 soap_in_PointerTott__LocationEntity(struct soap *soap, const char *tag, tt__LocationEntity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LocationEntity **)soap_malloc(soap, sizeof(tt__LocationEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LocationEntity *)soap_instantiate_tt__LocationEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LocationEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocationEntity, sizeof(tt__LocationEntity), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocationEntity(struct soap *soap, tt__LocationEntity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocationEntity(soap, tag ? tag : "tt:LocationEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LocationEntity ** SOAP_FMAC4 soap_get_PointerTott__LocationEntity(struct soap *soap, tt__LocationEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__StorageConfigurationData(struct soap *soap, tds__StorageConfigurationData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__StorageConfigurationData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__StorageConfigurationData(struct soap *soap, const char *tag, int id, tds__StorageConfigurationData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__StorageConfigurationData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__StorageConfigurationData ? type : NULL);
}

SOAP_FMAC3 tds__StorageConfigurationData ** SOAP_FMAC4 soap_in_PointerTotds__StorageConfigurationData(struct soap *soap, const char *tag, tds__StorageConfigurationData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__StorageConfigurationData **)soap_malloc(soap, sizeof(tds__StorageConfigurationData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__StorageConfigurationData *)soap_instantiate_tds__StorageConfigurationData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__StorageConfigurationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(tds__StorageConfigurationData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__StorageConfigurationData(struct soap *soap, tds__StorageConfigurationData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__StorageConfigurationData(soap, tag ? tag : "tds:StorageConfigurationData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__StorageConfigurationData ** SOAP_FMAC4 soap_get_PointerTotds__StorageConfigurationData(struct soap *soap, tds__StorageConfigurationData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__StorageConfigurationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__StorageConfiguration(struct soap *soap, tds__StorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__StorageConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__StorageConfiguration(struct soap *soap, const char *tag, int id, tds__StorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__StorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__StorageConfiguration ? type : NULL);
}

SOAP_FMAC3 tds__StorageConfiguration ** SOAP_FMAC4 soap_in_PointerTotds__StorageConfiguration(struct soap *soap, const char *tag, tds__StorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__StorageConfiguration **)soap_malloc(soap, sizeof(tds__StorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__StorageConfiguration *)soap_instantiate_tds__StorageConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__StorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfiguration, sizeof(tds__StorageConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__StorageConfiguration(struct soap *soap, tds__StorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__StorageConfiguration(soap, tag ? tag : "tds:StorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__StorageConfiguration ** SOAP_FMAC4 soap_get_PointerTotds__StorageConfiguration(struct soap *soap, tds__StorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__StorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, _tds__GetSystemUrisResponse_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, _tds__GetSystemUrisResponse_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemUrisResponse_Extension ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, _tds__GetSystemUrisResponse_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemUrisResponse_Extension **)soap_malloc(soap, sizeof(_tds__GetSystemUrisResponse_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemUrisResponse_Extension *)soap_instantiate__tds__GetSystemUrisResponse_Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemUrisResponse_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(_tds__GetSystemUrisResponse_Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, _tds__GetSystemUrisResponse_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag ? tag : "tds:GetSystemUrisResponse-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, _tds__GetSystemUrisResponse_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLogUriList(struct soap *soap, tt__SystemLogUriList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLogUriList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, int id, tt__SystemLogUriList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLogUriList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemLogUriList ? type : NULL);
}

SOAP_FMAC3 tt__SystemLogUriList ** SOAP_FMAC4 soap_in_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, tt__SystemLogUriList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemLogUriList **)soap_malloc(soap, sizeof(tt__SystemLogUriList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemLogUriList *)soap_instantiate_tt__SystemLogUriList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemLogUriList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUriList, sizeof(tt__SystemLogUriList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLogUriList(struct soap *soap, tt__SystemLogUriList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLogUriList(soap, tag ? tag : "tt:SystemLogUriList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemLogUriList ** SOAP_FMAC4 soap_get_PointerTott__SystemLogUriList(struct soap *soap, tt__SystemLogUriList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AvailableNetworks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, tt__Dot11AvailableNetworks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AvailableNetworks, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11AvailableNetworks ? type : NULL);
}

SOAP_FMAC3 tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_in_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, tt__Dot11AvailableNetworks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11AvailableNetworks **)soap_malloc(soap, sizeof(tt__Dot11AvailableNetworks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11AvailableNetworks *)soap_instantiate_tt__Dot11AvailableNetworks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11AvailableNetworks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11AvailableNetworks(soap, tag ? tag : "tt:Dot11AvailableNetworks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_get_PointerTott__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Status(struct soap *soap, tt__Dot11Status *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Status))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Status(struct soap *soap, const char *tag, int id, tt__Dot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Status, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11Status ? type : NULL);
}

SOAP_FMAC3 tt__Dot11Status ** SOAP_FMAC4 soap_in_PointerTott__Dot11Status(struct soap *soap, const char *tag, tt__Dot11Status **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11Status **)soap_malloc(soap, sizeof(tt__Dot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11Status *)soap_instantiate_tt__Dot11Status(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Status, sizeof(tt__Dot11Status), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Status(struct soap *soap, tt__Dot11Status *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Status(soap, tag ? tag : "tt:Dot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11Status ** SOAP_FMAC4 soap_get_PointerTott__Dot11Status(struct soap *soap, tt__Dot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, int id, tt__Dot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11Capabilities ? type : NULL);
}

SOAP_FMAC3 tt__Dot11Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, tt__Dot11Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11Capabilities **)soap_malloc(soap, sizeof(tt__Dot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11Capabilities *)soap_instantiate_tt__Dot11Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(tt__Dot11Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Capabilities(soap, tag ? tag : "tt:Dot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AuxiliaryData(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AuxiliaryData))
		soap_serialize_tt__AuxiliaryData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AuxiliaryData(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AuxiliaryData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AuxiliaryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__AuxiliaryData(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AuxiliaryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AuxiliaryData(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AuxiliaryData(soap, tag ? tag : "tt:AuxiliaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__AuxiliaryData(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutputSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, int id, tt__RelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutputSettings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RelayOutputSettings ? type : NULL);
}

SOAP_FMAC3 tt__RelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, tt__RelayOutputSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelayOutputSettings **)soap_malloc(soap, sizeof(tt__RelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelayOutputSettings *)soap_instantiate_tt__RelayOutputSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(tt__RelayOutputSettings), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelayOutputSettings(soap, tag ? tag : "tt:RelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTott__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutput(struct soap *soap, tt__RelayOutput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutput))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutput(struct soap *soap, const char *tag, int id, tt__RelayOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutput, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RelayOutput ? type : NULL);
}

SOAP_FMAC3 tt__RelayOutput ** SOAP_FMAC4 soap_in_PointerTott__RelayOutput(struct soap *soap, const char *tag, tt__RelayOutput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelayOutput **)soap_malloc(soap, sizeof(tt__RelayOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelayOutput *)soap_instantiate_tt__RelayOutput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RelayOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutput, sizeof(tt__RelayOutput), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutput(struct soap *soap, tt__RelayOutput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelayOutput(soap, tag ? tag : "tt:RelayOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelayOutput ** SOAP_FMAC4 soap_get_PointerTott__RelayOutput(struct soap *soap, tt__RelayOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, int id, tt__Dot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot1XConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__Dot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, tt__Dot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot1XConfiguration **)soap_malloc(soap, sizeof(tt__Dot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot1XConfiguration *)soap_instantiate_tt__Dot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot1XConfiguration(soap, tag ? tag : "tt:Dot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTott__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateInformation(struct soap *soap, tt__CertificateInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateInformation(struct soap *soap, const char *tag, int id, tt__CertificateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CertificateInformation ? type : NULL);
}

SOAP_FMAC3 tt__CertificateInformation ** SOAP_FMAC4 soap_in_PointerTott__CertificateInformation(struct soap *soap, const char *tag, tt__CertificateInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateInformation **)soap_malloc(soap, sizeof(tt__CertificateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateInformation *)soap_instantiate_tt__CertificateInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformation, sizeof(tt__CertificateInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateInformation(struct soap *soap, tt__CertificateInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateInformation(soap, tag ? tag : "tt:CertificateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateInformation ** SOAP_FMAC4 soap_get_PointerTott__CertificateInformation(struct soap *soap, tt__CertificateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateWithPrivateKey))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, tt__CertificateWithPrivateKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateWithPrivateKey, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CertificateWithPrivateKey ? type : NULL);
}

SOAP_FMAC3 tt__CertificateWithPrivateKey ** SOAP_FMAC4 soap_in_PointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, tt__CertificateWithPrivateKey **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateWithPrivateKey **)soap_malloc(soap, sizeof(tt__CertificateWithPrivateKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateWithPrivateKey *)soap_instantiate_tt__CertificateWithPrivateKey(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateWithPrivateKey(soap, tag ? tag : "tt:CertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateWithPrivateKey ** SOAP_FMAC4 soap_get_PointerTott__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateStatus(struct soap *soap, tt__CertificateStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateStatus(struct soap *soap, const char *tag, int id, tt__CertificateStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CertificateStatus ? type : NULL);
}

SOAP_FMAC3 tt__CertificateStatus ** SOAP_FMAC4 soap_in_PointerTott__CertificateStatus(struct soap *soap, const char *tag, tt__CertificateStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateStatus **)soap_malloc(soap, sizeof(tt__CertificateStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateStatus *)soap_instantiate_tt__CertificateStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CertificateStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateStatus, sizeof(tt__CertificateStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateStatus(struct soap *soap, tt__CertificateStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateStatus(soap, tag ? tag : "tt:CertificateStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateStatus ** SOAP_FMAC4 soap_get_PointerTott__CertificateStatus(struct soap *soap, tt__CertificateStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Certificate(struct soap *soap, tt__Certificate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Certificate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Certificate(struct soap *soap, const char *tag, int id, tt__Certificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Certificate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Certificate ? type : NULL);
}

SOAP_FMAC3 tt__Certificate ** SOAP_FMAC4 soap_in_PointerTott__Certificate(struct soap *soap, const char *tag, tt__Certificate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Certificate **)soap_malloc(soap, sizeof(tt__Certificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Certificate *)soap_instantiate_tt__Certificate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Certificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Certificate, sizeof(tt__Certificate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Certificate(struct soap *soap, tt__Certificate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Certificate(soap, tag ? tag : "tt:Certificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Certificate ** SOAP_FMAC4 soap_get_PointerTott__Certificate(struct soap *soap, tt__Certificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__token(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__token))
		soap_serialize_xsd__token(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__token(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__token, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__token(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__token(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__token, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__token(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__token(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BinaryData(struct soap *soap, tt__BinaryData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BinaryData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BinaryData(struct soap *soap, const char *tag, int id, tt__BinaryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BinaryData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__BinaryData ? type : NULL);
}

SOAP_FMAC3 tt__BinaryData ** SOAP_FMAC4 soap_in_PointerTott__BinaryData(struct soap *soap, const char *tag, tt__BinaryData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BinaryData **)soap_malloc(soap, sizeof(tt__BinaryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BinaryData *)soap_instantiate_tt__BinaryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__BinaryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BinaryData, sizeof(tt__BinaryData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BinaryData(struct soap *soap, tt__BinaryData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BinaryData(soap, tag ? tag : "tt:BinaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BinaryData ** SOAP_FMAC4 soap_get_PointerTott__BinaryData(struct soap *soap, tt__BinaryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilter(struct soap *soap, tt__IPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, int id, tt__IPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPAddressFilter ? type : NULL);
}

SOAP_FMAC3 tt__IPAddressFilter ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, tt__IPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPAddressFilter **)soap_malloc(soap, sizeof(tt__IPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPAddressFilter *)soap_instantiate_tt__IPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilter, sizeof(tt__IPAddressFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilter(struct soap *soap, tt__IPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddressFilter(soap, tag ? tag : "tt:IPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPAddressFilter ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilter(struct soap *soap, tt__IPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, tt__NetworkZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkZeroConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, tt__NetworkZeroConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkZeroConfiguration **)soap_malloc(soap, sizeof(tt__NetworkZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkZeroConfiguration *)soap_instantiate_tt__NetworkZeroConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkZeroConfiguration(soap, tag ? tag : "tt:NetworkZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkGateway(struct soap *soap, tt__NetworkGateway *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkGateway))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkGateway(struct soap *soap, const char *tag, int id, tt__NetworkGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkGateway, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkGateway ? type : NULL);
}

SOAP_FMAC3 tt__NetworkGateway ** SOAP_FMAC4 soap_in_PointerTott__NetworkGateway(struct soap *soap, const char *tag, tt__NetworkGateway **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkGateway **)soap_malloc(soap, sizeof(tt__NetworkGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkGateway *)soap_instantiate_tt__NetworkGateway(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkGateway, sizeof(tt__NetworkGateway), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkGateway(struct soap *soap, tt__NetworkGateway *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkGateway(soap, tag ? tag : "tt:NetworkGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkGateway ** SOAP_FMAC4 soap_get_PointerTott__NetworkGateway(struct soap *soap, tt__NetworkGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocol(struct soap *soap, tt__NetworkProtocol *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocol))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocol(struct soap *soap, const char *tag, int id, tt__NetworkProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocol, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkProtocol ? type : NULL);
}

SOAP_FMAC3 tt__NetworkProtocol ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocol(struct soap *soap, const char *tag, tt__NetworkProtocol **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkProtocol **)soap_malloc(soap, sizeof(tt__NetworkProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkProtocol *)soap_instantiate_tt__NetworkProtocol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocol, sizeof(tt__NetworkProtocol), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocol(struct soap *soap, tt__NetworkProtocol *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkProtocol(soap, tag ? tag : "tt:NetworkProtocol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkProtocol ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocol(struct soap *soap, tt__NetworkProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceSetConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceSetConfiguration *)soap_instantiate_tt__NetworkInterfaceSetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(tt__NetworkInterfaceSetConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterface(struct soap *soap, tt__NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterface))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterface(struct soap *soap, const char *tag, int id, tt__NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterface ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterface(struct soap *soap, const char *tag, tt__NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterface **)soap_malloc(soap, sizeof(tt__NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterface *)soap_instantiate_tt__NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterface, sizeof(tt__NetworkInterface), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterface(struct soap *soap, tt__NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterface(soap, tag ? tag : "tt:NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterface(struct soap *soap, tt__NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__duration))
		soap_serialize_xsd__duration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSName))
		soap_serialize_tt__DNSName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__DNSName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DNSName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DNSName(soap, tag ? tag : "tt:DNSName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__DNSName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, int id, tt__DynamicDNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DynamicDNSInformation ? type : NULL);
}

SOAP_FMAC3 tt__DynamicDNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, tt__DynamicDNSInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DynamicDNSInformation **)soap_malloc(soap, sizeof(tt__DynamicDNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DynamicDNSInformation *)soap_instantiate_tt__DynamicDNSInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DynamicDNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(tt__DynamicDNSInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DynamicDNSInformation(soap, tag ? tag : "tt:DynamicDNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DynamicDNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformation(struct soap *soap, tt__NTPInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformation(struct soap *soap, const char *tag, int id, tt__NTPInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NTPInformation ? type : NULL);
}

SOAP_FMAC3 tt__NTPInformation ** SOAP_FMAC4 soap_in_PointerTott__NTPInformation(struct soap *soap, const char *tag, tt__NTPInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NTPInformation **)soap_malloc(soap, sizeof(tt__NTPInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NTPInformation *)soap_instantiate_tt__NTPInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NTPInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformation, sizeof(tt__NTPInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformation(struct soap *soap, tt__NTPInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NTPInformation(soap, tag ? tag : "tt:NTPInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NTPInformation ** SOAP_FMAC4 soap_get_PointerTott__NTPInformation(struct soap *soap, tt__NTPInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddress(struct soap *soap, tt__IPAddress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddress))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddress(struct soap *soap, const char *tag, int id, tt__IPAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddress, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPAddress ? type : NULL);
}

SOAP_FMAC3 tt__IPAddress ** SOAP_FMAC4 soap_in_PointerTott__IPAddress(struct soap *soap, const char *tag, tt__IPAddress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPAddress **)soap_malloc(soap, sizeof(tt__IPAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPAddress *)soap_instantiate_tt__IPAddress(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddress(struct soap *soap, tt__IPAddress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPAddress ** SOAP_FMAC4 soap_get_PointerTott__IPAddress(struct soap *soap, tt__IPAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformation(struct soap *soap, tt__DNSInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformation(struct soap *soap, const char *tag, int id, tt__DNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DNSInformation ? type : NULL);
}

SOAP_FMAC3 tt__DNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DNSInformation(struct soap *soap, const char *tag, tt__DNSInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DNSInformation **)soap_malloc(soap, sizeof(tt__DNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DNSInformation *)soap_instantiate_tt__DNSInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformation, sizeof(tt__DNSInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformation(struct soap *soap, tt__DNSInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DNSInformation(soap, tag ? tag : "tt:DNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DNSInformation(struct soap *soap, tt__DNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformation(struct soap *soap, tt__HostnameInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformation(struct soap *soap, const char *tag, int id, tt__HostnameInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__HostnameInformation ? type : NULL);
}

SOAP_FMAC3 tt__HostnameInformation ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformation(struct soap *soap, const char *tag, tt__HostnameInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__HostnameInformation **)soap_malloc(soap, sizeof(tt__HostnameInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__HostnameInformation *)soap_instantiate_tt__HostnameInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__HostnameInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformation, sizeof(tt__HostnameInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformation(struct soap *soap, tt__HostnameInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__HostnameInformation(soap, tag ? tag : "tt:HostnameInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__HostnameInformation ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformation(struct soap *soap, tt__HostnameInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Capabilities(struct soap *soap, tt__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Capabilities(struct soap *soap, const char *tag, int id, tt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Capabilities ? type : NULL);
}

SOAP_FMAC3 tt__Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Capabilities(struct soap *soap, const char *tag, tt__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Capabilities **)soap_malloc(soap, sizeof(tt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Capabilities *)soap_instantiate_tt__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Capabilities, sizeof(tt__Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Capabilities(struct soap *soap, tt__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Capabilities(struct soap *soap, tt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap *soap, tt__IntRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap *soap, const char *tag, int id, tt__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IntRange ? type : NULL);
}

SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap *soap, const char *tag, tt__IntRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRange **)soap_malloc(soap, sizeof(tt__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRange *)soap_instantiate_tt__IntRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap *soap, tt__IntRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRange(soap, tag ? tag : "tt:IntRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap *soap, tt__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__User(struct soap *soap, tt__User *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__User))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__User(struct soap *soap, const char *tag, int id, tt__User *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__User, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__User ? type : NULL);
}

SOAP_FMAC3 tt__User ** SOAP_FMAC4 soap_in_PointerTott__User(struct soap *soap, const char *tag, tt__User **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__User **)soap_malloc(soap, sizeof(tt__User *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__User *)soap_instantiate_tt__User(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__User, sizeof(tt__User), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__User(struct soap *soap, tt__User *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__User(soap, tag ? tag : "tt:User", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__User ** SOAP_FMAC4 soap_get_PointerTott__User(struct soap *soap, tt__User **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RemoteUser(struct soap *soap, tt__RemoteUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RemoteUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RemoteUser(struct soap *soap, const char *tag, int id, tt__RemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RemoteUser, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RemoteUser ? type : NULL);
}

SOAP_FMAC3 tt__RemoteUser ** SOAP_FMAC4 soap_in_PointerTott__RemoteUser(struct soap *soap, const char *tag, tt__RemoteUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RemoteUser **)soap_malloc(soap, sizeof(tt__RemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RemoteUser *)soap_instantiate_tt__RemoteUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RemoteUser, sizeof(tt__RemoteUser), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RemoteUser(struct soap *soap, tt__RemoteUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RemoteUser(soap, tag ? tag : "tt:RemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RemoteUser ** SOAP_FMAC4 soap_get_PointerTott__RemoteUser(struct soap *soap, tt__RemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHost(struct soap *soap, tt__NetworkHost *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHost))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHost(struct soap *soap, const char *tag, int id, tt__NetworkHost *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHost, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkHost ? type : NULL);
}

SOAP_FMAC3 tt__NetworkHost ** SOAP_FMAC4 soap_in_PointerTott__NetworkHost(struct soap *soap, const char *tag, tt__NetworkHost **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkHost **)soap_malloc(soap, sizeof(tt__NetworkHost *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkHost *)soap_instantiate_tt__NetworkHost(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkHost **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHost, sizeof(tt__NetworkHost), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHost(struct soap *soap, tt__NetworkHost *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkHost(soap, tag ? tag : "tt:NetworkHost", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkHost ** SOAP_FMAC4 soap_get_PointerTott__NetworkHost(struct soap *soap, tt__NetworkHost **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Scope(struct soap *soap, tt__Scope *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Scope))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Scope(struct soap *soap, const char *tag, int id, tt__Scope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Scope, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Scope ? type : NULL);
}

SOAP_FMAC3 tt__Scope ** SOAP_FMAC4 soap_in_PointerTott__Scope(struct soap *soap, const char *tag, tt__Scope **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Scope **)soap_malloc(soap, sizeof(tt__Scope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Scope *)soap_instantiate_tt__Scope(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Scope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Scope, sizeof(tt__Scope), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Scope(struct soap *soap, tt__Scope *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Scope(soap, tag ? tag : "tt:Scope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Scope ** SOAP_FMAC4 soap_get_PointerTott__Scope(struct soap *soap, tt__Scope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLog(struct soap *soap, tt__SystemLog *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLog(struct soap *soap, const char *tag, int id, tt__SystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLog, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemLog ? type : NULL);
}

SOAP_FMAC3 tt__SystemLog ** SOAP_FMAC4 soap_in_PointerTott__SystemLog(struct soap *soap, const char *tag, tt__SystemLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemLog **)soap_malloc(soap, sizeof(tt__SystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemLog *)soap_instantiate_tt__SystemLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLog, sizeof(tt__SystemLog), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLog(struct soap *soap, tt__SystemLog *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLog(soap, tag ? tag : "tt:SystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemLog ** SOAP_FMAC4 soap_get_PointerTott__SystemLog(struct soap *soap, tt__SystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportInformation(struct soap *soap, tt__SupportInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportInformation(struct soap *soap, const char *tag, int id, tt__SupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SupportInformation ? type : NULL);
}

SOAP_FMAC3 tt__SupportInformation ** SOAP_FMAC4 soap_in_PointerTott__SupportInformation(struct soap *soap, const char *tag, tt__SupportInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SupportInformation **)soap_malloc(soap, sizeof(tt__SupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SupportInformation *)soap_instantiate_tt__SupportInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportInformation, sizeof(tt__SupportInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportInformation(struct soap *soap, tt__SupportInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportInformation(soap, tag ? tag : "tt:SupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SupportInformation ** SOAP_FMAC4 soap_get_PointerTott__SupportInformation(struct soap *soap, tt__SupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BackupFile(struct soap *soap, tt__BackupFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BackupFile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BackupFile(struct soap *soap, const char *tag, int id, tt__BackupFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BackupFile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__BackupFile ? type : NULL);
}

SOAP_FMAC3 tt__BackupFile ** SOAP_FMAC4 soap_in_PointerTott__BackupFile(struct soap *soap, const char *tag, tt__BackupFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BackupFile **)soap_malloc(soap, sizeof(tt__BackupFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BackupFile *)soap_instantiate_tt__BackupFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__BackupFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BackupFile, sizeof(tt__BackupFile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BackupFile(struct soap *soap, tt__BackupFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BackupFile(soap, tag ? tag : "tt:BackupFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BackupFile ** SOAP_FMAC4 soap_get_PointerTott__BackupFile(struct soap *soap, tt__BackupFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AttachmentData(struct soap *soap, tt__AttachmentData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AttachmentData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AttachmentData(struct soap *soap, const char *tag, int id, tt__AttachmentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AttachmentData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AttachmentData ? type : NULL);
}

SOAP_FMAC3 tt__AttachmentData ** SOAP_FMAC4 soap_in_PointerTott__AttachmentData(struct soap *soap, const char *tag, tt__AttachmentData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AttachmentData **)soap_malloc(soap, sizeof(tt__AttachmentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AttachmentData *)soap_instantiate_tt__AttachmentData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AttachmentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AttachmentData, sizeof(tt__AttachmentData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AttachmentData(struct soap *soap, tt__AttachmentData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AttachmentData(soap, tag ? tag : "tt:AttachmentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AttachmentData ** SOAP_FMAC4 soap_get_PointerTott__AttachmentData(struct soap *soap, tt__AttachmentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTime(struct soap *soap, tt__SystemDateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTime(struct soap *soap, const char *tag, int id, tt__SystemDateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemDateTime ? type : NULL);
}

SOAP_FMAC3 tt__SystemDateTime ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTime(struct soap *soap, const char *tag, tt__SystemDateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemDateTime **)soap_malloc(soap, sizeof(tt__SystemDateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemDateTime *)soap_instantiate_tt__SystemDateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemDateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTime, sizeof(tt__SystemDateTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTime(struct soap *soap, tt__SystemDateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemDateTime(soap, tag ? tag : "tt:SystemDateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemDateTime ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTime(struct soap *soap, tt__SystemDateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTime(struct soap *soap, tt__DateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTime(struct soap *soap, const char *tag, int id, tt__DateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DateTime ? type : NULL);
}

SOAP_FMAC3 tt__DateTime ** SOAP_FMAC4 soap_in_PointerTott__DateTime(struct soap *soap, const char *tag, tt__DateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DateTime **)soap_malloc(soap, sizeof(tt__DateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DateTime *)soap_instantiate_tt__DateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTime, sizeof(tt__DateTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTime(struct soap *soap, tt__DateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DateTime(soap, tag ? tag : "tt:DateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DateTime ** SOAP_FMAC4 soap_get_PointerTott__DateTime(struct soap *soap, tt__DateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TimeZone(struct soap *soap, tt__TimeZone *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TimeZone))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TimeZone(struct soap *soap, const char *tag, int id, tt__TimeZone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TimeZone, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__TimeZone ? type : NULL);
}

SOAP_FMAC3 tt__TimeZone ** SOAP_FMAC4 soap_in_PointerTott__TimeZone(struct soap *soap, const char *tag, tt__TimeZone **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TimeZone **)soap_malloc(soap, sizeof(tt__TimeZone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TimeZone *)soap_instantiate_tt__TimeZone(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__TimeZone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TimeZone, sizeof(tt__TimeZone), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TimeZone(struct soap *soap, tt__TimeZone *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TimeZone(soap, tag ? tag : "tt:TimeZone", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TimeZone ** SOAP_FMAC4 soap_get_PointerTott__TimeZone(struct soap *soap, tt__TimeZone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__DeviceServiceCapabilities(struct soap *soap, tds__DeviceServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__DeviceServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, tds__DeviceServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__DeviceServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__DeviceServiceCapabilities ? type : NULL);
}

SOAP_FMAC3 tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, tds__DeviceServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__DeviceServiceCapabilities **)soap_malloc(soap, sizeof(tds__DeviceServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__DeviceServiceCapabilities *)soap_instantiate_tds__DeviceServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__DeviceServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(tds__DeviceServiceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__DeviceServiceCapabilities(struct soap *soap, tds__DeviceServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, tag ? tag : "tds:DeviceServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__DeviceServiceCapabilities(struct soap *soap, tds__DeviceServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__Service(struct soap *soap, tds__Service *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__Service))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__Service(struct soap *soap, const char *tag, int id, tds__Service *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__Service, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__Service ? type : NULL);
}

SOAP_FMAC3 tds__Service ** SOAP_FMAC4 soap_in_PointerTotds__Service(struct soap *soap, const char *tag, tds__Service **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__Service **)soap_malloc(soap, sizeof(tds__Service *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__Service *)soap_instantiate_tds__Service(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__Service **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__Service, sizeof(tds__Service), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__Service(struct soap *soap, tds__Service *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__Service(soap, tag ? tag : "tds:Service", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__Service ** SOAP_FMAC4 soap_get_PointerTotds__Service(struct soap *soap, tds__Service **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, _tds__StorageConfigurationData_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StorageConfigurationData_Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, int id, _tds__StorageConfigurationData_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StorageConfigurationData_Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__StorageConfigurationData_Extension ? type : NULL);
}

SOAP_FMAC3 _tds__StorageConfigurationData_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, _tds__StorageConfigurationData_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__StorageConfigurationData_Extension **)soap_malloc(soap, sizeof(_tds__StorageConfigurationData_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__StorageConfigurationData_Extension *)soap_instantiate__tds__StorageConfigurationData_Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__StorageConfigurationData_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(_tds__StorageConfigurationData_Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, _tds__StorageConfigurationData_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__StorageConfigurationData_Extension(soap, tag ? tag : "tds:StorageConfigurationData-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__StorageConfigurationData_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, _tds__StorageConfigurationData_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StorageConfigurationData_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__UserCredential(struct soap *soap, tds__UserCredential *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__UserCredential))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__UserCredential(struct soap *soap, const char *tag, int id, tds__UserCredential *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__UserCredential, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__UserCredential ? type : NULL);
}

SOAP_FMAC3 tds__UserCredential ** SOAP_FMAC4 soap_in_PointerTotds__UserCredential(struct soap *soap, const char *tag, tds__UserCredential **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__UserCredential **)soap_malloc(soap, sizeof(tds__UserCredential *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__UserCredential *)soap_instantiate_tds__UserCredential(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__UserCredential **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__UserCredential, sizeof(tds__UserCredential), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__UserCredential(struct soap *soap, tds__UserCredential *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__UserCredential(soap, tag ? tag : "tds:UserCredential", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__UserCredential ** SOAP_FMAC4 soap_get_PointerTotds__UserCredential(struct soap *soap, tds__UserCredential **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__UserCredential(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UserCredential_Extension(struct soap *soap, _tds__UserCredential_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UserCredential_Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UserCredential_Extension(struct soap *soap, const char *tag, int id, _tds__UserCredential_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UserCredential_Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__UserCredential_Extension ? type : NULL);
}

SOAP_FMAC3 _tds__UserCredential_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__UserCredential_Extension(struct soap *soap, const char *tag, _tds__UserCredential_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__UserCredential_Extension **)soap_malloc(soap, sizeof(_tds__UserCredential_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__UserCredential_Extension *)soap_instantiate__tds__UserCredential_Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__UserCredential_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UserCredential_Extension, sizeof(_tds__UserCredential_Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UserCredential_Extension(struct soap *soap, _tds__UserCredential_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__UserCredential_Extension(soap, tag ? tag : "tds:UserCredential-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__UserCredential_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__UserCredential_Extension(struct soap *soap, _tds__UserCredential_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UserCredential_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StringAttrList(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StringAttrList))
		soap_serialize_tt__StringAttrList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StringAttrList(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StringAttrList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StringAttrList(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__StringAttrList(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StringAttrList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StringAttrList(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StringAttrList(soap, tag ? tag : "tt:StringAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__StringAttrList(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StringList(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StringList))
		soap_serialize_tt__StringList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StringList(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StringList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StringList(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__StringList(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StringList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StringList, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StringList(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StringList(soap, tag ? tag : "tt:StringList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__StringList(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntList(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntList))
		soap_serialize_tt__IntList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntList(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntList(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IntList(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntList, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntList(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntList(soap, tag ? tag : "tt:IntList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IntList(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__MiscCapabilities(struct soap *soap, tds__MiscCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__MiscCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__MiscCapabilities(struct soap *soap, const char *tag, int id, tds__MiscCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__MiscCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__MiscCapabilities ? type : NULL);
}

SOAP_FMAC3 tds__MiscCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__MiscCapabilities(struct soap *soap, const char *tag, tds__MiscCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__MiscCapabilities **)soap_malloc(soap, sizeof(tds__MiscCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__MiscCapabilities *)soap_instantiate_tds__MiscCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__MiscCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__MiscCapabilities, sizeof(tds__MiscCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__MiscCapabilities(struct soap *soap, tds__MiscCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__MiscCapabilities(soap, tag ? tag : "tds:MiscCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__MiscCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__MiscCapabilities(struct soap *soap, tds__MiscCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__MiscCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__SystemCapabilities(struct soap *soap, tds__SystemCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__SystemCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__SystemCapabilities(struct soap *soap, const char *tag, int id, tds__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__SystemCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__SystemCapabilities ? type : NULL);
}

SOAP_FMAC3 tds__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__SystemCapabilities(struct soap *soap, const char *tag, tds__SystemCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__SystemCapabilities **)soap_malloc(soap, sizeof(tds__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__SystemCapabilities *)soap_instantiate_tds__SystemCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SystemCapabilities, sizeof(tds__SystemCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__SystemCapabilities(struct soap *soap, tds__SystemCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__SystemCapabilities(soap, tag ? tag : "tds:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__SystemCapabilities(struct soap *soap, tds__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__SecurityCapabilities(struct soap *soap, tds__SecurityCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__SecurityCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__SecurityCapabilities(struct soap *soap, const char *tag, int id, tds__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__SecurityCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__SecurityCapabilities ? type : NULL);
}

SOAP_FMAC3 tds__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__SecurityCapabilities(struct soap *soap, const char *tag, tds__SecurityCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__SecurityCapabilities **)soap_malloc(soap, sizeof(tds__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__SecurityCapabilities *)soap_instantiate_tds__SecurityCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(tds__SecurityCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__SecurityCapabilities(struct soap *soap, tds__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__SecurityCapabilities(soap, tag ? tag : "tds:SecurityCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__SecurityCapabilities(struct soap *soap, tds__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__NetworkCapabilities(struct soap *soap, tds__NetworkCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__NetworkCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__NetworkCapabilities(struct soap *soap, const char *tag, int id, tds__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__NetworkCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__NetworkCapabilities ? type : NULL);
}

SOAP_FMAC3 tds__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__NetworkCapabilities(struct soap *soap, const char *tag, tds__NetworkCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__NetworkCapabilities **)soap_malloc(soap, sizeof(tds__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__NetworkCapabilities *)soap_instantiate_tds__NetworkCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(tds__NetworkCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__NetworkCapabilities(struct soap *soap, tds__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__NetworkCapabilities(soap, tag ? tag : "tds:NetworkCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__NetworkCapabilities(struct soap *soap, tds__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OnvifVersion(struct soap *soap, tt__OnvifVersion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OnvifVersion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, tt__OnvifVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OnvifVersion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OnvifVersion ? type : NULL);
}

SOAP_FMAC3 tt__OnvifVersion ** SOAP_FMAC4 soap_in_PointerTott__OnvifVersion(struct soap *soap, const char *tag, tt__OnvifVersion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OnvifVersion **)soap_malloc(soap, sizeof(tt__OnvifVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OnvifVersion *)soap_instantiate_tt__OnvifVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OnvifVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OnvifVersion, sizeof(tt__OnvifVersion), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OnvifVersion(struct soap *soap, tt__OnvifVersion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OnvifVersion ** SOAP_FMAC4 soap_get_PointerTott__OnvifVersion(struct soap *soap, tt__OnvifVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__Service_Capabilities(struct soap *soap, _tds__Service_Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__Service_Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, int id, _tds__Service_Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__Service_Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__Service_Capabilities ? type : NULL);
}

SOAP_FMAC3 _tds__Service_Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, _tds__Service_Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__Service_Capabilities **)soap_malloc(soap, sizeof(_tds__Service_Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__Service_Capabilities *)soap_instantiate__tds__Service_Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__Service_Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__Service_Capabilities, sizeof(_tds__Service_Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__Service_Capabilities(struct soap *soap, _tds__Service_Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, tag ? tag : "tds:Service-Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__Service_Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__Service_Capabilities(struct soap *soap, _tds__Service_Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Header))
		soap_serialize_SOAP_ENV__Header(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Header *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Header, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Header(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Header **)soap_malloc(soap, sizeof(struct SOAP_ENV__Header *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Header(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemIRI(soap, tag ? tag : "wsa5:ProblemIRI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Action(soap, tag ? tag : "wsa5:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__To(soap, tag ? tag : "wsa5:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__MessageID(soap, tag ? tag : "wsa5:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag ? tag : "wsa5:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, std::vector<tt__SystemLogUri *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const std::vector<tt__SystemLogUri *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__SystemLogUri *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__SystemLogUri(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const char *tag, int id, const std::vector<tt__SystemLogUri *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__SystemLogUri *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__SystemLogUri(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__SystemLogUri *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const char *tag, std::vector<tt__SystemLogUri *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__SystemLogUri(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__SystemLogUri *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__SystemLogUri, SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri, sizeof(tt__SystemLogUri), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__SystemLogUri(soap, tag, NULL, "tt:SystemLogUri"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__SystemLogUri(soap, tag, &n, "tt:SystemLogUri"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__SystemLogUri *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__SystemLogUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__SystemLogUri *> *p;
	size_t k = sizeof(std::vector<tt__SystemLogUri *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__SystemLogUri *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__SystemLogUri *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__SystemLogUri *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, std::vector<tt__OnvifVersion *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const std::vector<tt__OnvifVersion *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__OnvifVersion *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__OnvifVersion(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, const std::vector<tt__OnvifVersion *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__OnvifVersion *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__OnvifVersion(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__OnvifVersion *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const char *tag, std::vector<tt__OnvifVersion *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__OnvifVersion(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__OnvifVersion *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion, sizeof(tt__OnvifVersion), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__OnvifVersion(soap, tag, NULL, "tt:OnvifVersion"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__OnvifVersion(soap, tag, &n, "tt:OnvifVersion"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__OnvifVersion *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__OnvifVersion *> *p;
	size_t k = sizeof(std::vector<tt__OnvifVersion *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__OnvifVersion *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__OnvifVersion *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__OnvifVersion *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__AuxiliaryData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AuxiliaryData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__AuxiliaryData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__AuxiliaryData(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AuxiliaryData, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__AuxiliaryData(soap, tag, NULL, "tt:AuxiliaryData"))
				break;
		}
		else
		{	if (!soap_in_tt__AuxiliaryData(soap, tag, &n, "tt:AuxiliaryData"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, std::vector<enum tt__Dot11Cipher> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const std::vector<enum tt__Dot11Cipher> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const char *tag, int id, const std::vector<enum tt__Dot11Cipher> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__Dot11Cipher> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Dot11Cipher(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__Dot11Cipher> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const char *tag, std::vector<enum tt__Dot11Cipher> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Dot11Cipher(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__Dot11Cipher n;
		soap_default_tt__Dot11Cipher(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot11Cipher, SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Dot11Cipher(soap, tag, NULL, "tt:Dot11Cipher"))
				break;
		}
		else
		{	if (!soap_in_tt__Dot11Cipher(soap, tag, &n, "tt:Dot11Cipher"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__Dot11Cipher>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Dot11Cipher(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__Dot11Cipher> *p;
	size_t k = sizeof(std::vector<enum tt__Dot11Cipher> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__Dot11Cipher> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__Dot11Cipher> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__Dot11Cipher>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, std::vector<enum tt__Dot11AuthAndMangementSuite> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const std::vector<enum tt__Dot11AuthAndMangementSuite> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, int id, const std::vector<enum tt__Dot11AuthAndMangementSuite> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__Dot11AuthAndMangementSuite> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Dot11AuthAndMangementSuite(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__Dot11AuthAndMangementSuite> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, std::vector<enum tt__Dot11AuthAndMangementSuite> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__Dot11AuthAndMangementSuite n;
		soap_default_tt__Dot11AuthAndMangementSuite(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot11AuthAndMangementSuite, SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, NULL, "tt:Dot11AuthAndMangementSuite"))
				break;
		}
		else
		{	if (!soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, &n, "tt:Dot11AuthAndMangementSuite"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__Dot11AuthAndMangementSuite>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__Dot11AuthAndMangementSuite> *p;
	size_t k = sizeof(std::vector<enum tt__Dot11AuthAndMangementSuite> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__Dot11AuthAndMangementSuite> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__Dot11AuthAndMangementSuite> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__Dot11AuthAndMangementSuite>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, std::vector<tt__NetworkZeroConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const std::vector<tt__NetworkZeroConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkZeroConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkZeroConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkZeroConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkZeroConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkZeroConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkZeroConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, std::vector<tt__NetworkZeroConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__NetworkZeroConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__NetworkZeroConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, NULL, "tt:NetworkZeroConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, &n, "tt:NetworkZeroConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkZeroConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkZeroConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__NetworkZeroConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkZeroConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkZeroConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkZeroConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<int> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int> * SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfint(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		int n;
		soap_default_int(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{	if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<int>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<int> *p;
	size_t k = sizeof(std::vector<int> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<int> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<int> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<int>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, std::vector<tt__PrefixedIPv6Address *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const std::vector<tt__PrefixedIPv6Address *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PrefixedIPv6Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PrefixedIPv6Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const std::vector<tt__PrefixedIPv6Address *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PrefixedIPv6Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PrefixedIPv6Address *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, std::vector<tt__PrefixedIPv6Address *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PrefixedIPv6Address *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PrefixedIPv6Address, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PrefixedIPv6Address(soap, tag, NULL, "tt:PrefixedIPv6Address"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PrefixedIPv6Address(soap, tag, &n, "tt:PrefixedIPv6Address"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv6Address *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PrefixedIPv6Address *> *p;
	size_t k = sizeof(std::vector<tt__PrefixedIPv6Address *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PrefixedIPv6Address *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PrefixedIPv6Address *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PrefixedIPv6Address *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, std::vector<tt__PrefixedIPv4Address *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const std::vector<tt__PrefixedIPv4Address *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PrefixedIPv4Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PrefixedIPv4Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const std::vector<tt__PrefixedIPv4Address *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PrefixedIPv4Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PrefixedIPv4Address *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, std::vector<tt__PrefixedIPv4Address *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PrefixedIPv4Address *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PrefixedIPv4Address, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PrefixedIPv4Address(soap, tag, NULL, "tt:PrefixedIPv4Address"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PrefixedIPv4Address(soap, tag, &n, "tt:PrefixedIPv4Address"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv4Address *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PrefixedIPv4Address *> *p;
	size_t k = sizeof(std::vector<tt__PrefixedIPv4Address *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PrefixedIPv4Address *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PrefixedIPv4Address *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PrefixedIPv4Address *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, std::vector<tt__Dot11Configuration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const std::vector<tt__Dot11Configuration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot11Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot11Configuration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11Configuration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot11Configuration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11Configuration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const char *tag, std::vector<tt__Dot11Configuration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot11Configuration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Dot11Configuration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot11Configuration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration, sizeof(tt__Dot11Configuration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot11Configuration(soap, tag, NULL, "tt:Dot11Configuration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot11Configuration(soap, tag, &n, "tt:Dot11Configuration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11Configuration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot11Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11Configuration *> *p;
	size_t k = sizeof(std::vector<tt__Dot11Configuration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11Configuration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11Configuration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11Configuration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, std::vector<tt__Dot3Configuration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const std::vector<tt__Dot3Configuration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot3Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot3Configuration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot3Configuration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot3Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot3Configuration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot3Configuration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const char *tag, std::vector<tt__Dot3Configuration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot3Configuration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Dot3Configuration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot3Configuration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration, sizeof(tt__Dot3Configuration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot3Configuration(soap, tag, NULL, "tt:Dot3Configuration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot3Configuration(soap, tag, &n, "tt:Dot3Configuration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot3Configuration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot3Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot3Configuration *> *p;
	size_t k = sizeof(std::vector<tt__Dot3Configuration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot3Configuration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot3Configuration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot3Configuration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, std::vector<tt__LocationEntity *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const std::vector<tt__LocationEntity *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LocationEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LocationEntity(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const char *tag, int id, const std::vector<tt__LocationEntity *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LocationEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LocationEntity(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LocationEntity *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const char *tag, std::vector<tt__LocationEntity *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LocationEntity(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__LocationEntity *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__LocationEntity, SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity, sizeof(tt__LocationEntity), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__LocationEntity(soap, tag, NULL, "tt:LocationEntity"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LocationEntity(soap, tag, &n, "tt:LocationEntity"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LocationEntity *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__LocationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LocationEntity *> *p;
	size_t k = sizeof(std::vector<tt__LocationEntity *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LocationEntity *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LocationEntity *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LocationEntity *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, std::vector<tds__StorageConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const std::vector<tds__StorageConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tds__StorageConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotds__StorageConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tds__StorageConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tds__StorageConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotds__StorageConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tds__StorageConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const char *tag, std::vector<tds__StorageConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tds__StorageConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tds__StorageConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration, sizeof(tds__StorageConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotds__StorageConfiguration(soap, tag, NULL, "tds:StorageConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTotds__StorageConfiguration(soap, tag, &n, "tds:StorageConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tds__StorageConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotds__StorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tds__StorageConfiguration *> *p;
	size_t k = sizeof(std::vector<tds__StorageConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tds__StorageConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tds__StorageConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tds__StorageConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, std::vector<tt__Dot11AvailableNetworks *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const std::vector<tt__Dot11AvailableNetworks *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot11AvailableNetworks *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot11AvailableNetworks(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11AvailableNetworks *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11AvailableNetworks *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot11AvailableNetworks(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11AvailableNetworks *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, std::vector<tt__Dot11AvailableNetworks *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Dot11AvailableNetworks *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot11AvailableNetworks, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, NULL, "tt:Dot11AvailableNetworks"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, &n, "tt:Dot11AvailableNetworks"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11AvailableNetworks *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11AvailableNetworks *> *p;
	size_t k = sizeof(std::vector<tt__Dot11AvailableNetworks *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11AvailableNetworks *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11AvailableNetworks *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11AvailableNetworks *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, std::vector<tt__RelayOutput *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const std::vector<tt__RelayOutput *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RelayOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RelayOutput(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const char *tag, int id, const std::vector<tt__RelayOutput *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RelayOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RelayOutput(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RelayOutput *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const char *tag, std::vector<tt__RelayOutput *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RelayOutput(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__RelayOutput *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput, sizeof(tt__RelayOutput), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RelayOutput(soap, tag, NULL, "tt:RelayOutput"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RelayOutput(soap, tag, &n, "tt:RelayOutput"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RelayOutput *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RelayOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RelayOutput *> *p;
	size_t k = sizeof(std::vector<tt__RelayOutput *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RelayOutput *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RelayOutput *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RelayOutput *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__ReferenceToken(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ReferenceToken(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ReferenceToken(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__ReferenceToken(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ReferenceToken, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken"))
				break;
		}
		else
		{	if (!soap_in_tt__ReferenceToken(soap, tag, &n, "tt:ReferenceToken"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ReferenceToken(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, std::vector<tt__Dot1XConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const std::vector<tt__Dot1XConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot1XConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot1XConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot1XConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot1XConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot1XConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot1XConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, std::vector<tt__Dot1XConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Dot1XConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot1XConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot1XConfiguration(soap, tag, NULL, "tt:Dot1XConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot1XConfiguration(soap, tag, &n, "tt:Dot1XConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot1XConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot1XConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__Dot1XConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot1XConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot1XConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot1XConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, std::vector<tt__CertificateWithPrivateKey *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const std::vector<tt__CertificateWithPrivateKey *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__CertificateWithPrivateKey *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__CertificateWithPrivateKey(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const std::vector<tt__CertificateWithPrivateKey *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__CertificateWithPrivateKey *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__CertificateWithPrivateKey(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__CertificateWithPrivateKey *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, std::vector<tt__CertificateWithPrivateKey *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__CertificateWithPrivateKey *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__CertificateWithPrivateKey, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, NULL, "tt:CertificateWithPrivateKey"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, &n, "tt:CertificateWithPrivateKey"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__CertificateWithPrivateKey *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__CertificateWithPrivateKey *> *p;
	size_t k = sizeof(std::vector<tt__CertificateWithPrivateKey *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__CertificateWithPrivateKey *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__CertificateWithPrivateKey *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__CertificateWithPrivateKey *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, std::vector<tt__CertificateStatus *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const std::vector<tt__CertificateStatus *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__CertificateStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__CertificateStatus(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const char *tag, int id, const std::vector<tt__CertificateStatus *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__CertificateStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__CertificateStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__CertificateStatus *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const char *tag, std::vector<tt__CertificateStatus *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__CertificateStatus(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__CertificateStatus *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__CertificateStatus, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus, sizeof(tt__CertificateStatus), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__CertificateStatus(soap, tag, NULL, "tt:CertificateStatus"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__CertificateStatus(soap, tag, &n, "tt:CertificateStatus"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__CertificateStatus *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__CertificateStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__CertificateStatus *> *p;
	size_t k = sizeof(std::vector<tt__CertificateStatus *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__CertificateStatus *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__CertificateStatus *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__CertificateStatus *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, std::vector<tt__Certificate *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const std::vector<tt__Certificate *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Certificate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Certificate(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const char *tag, int id, const std::vector<tt__Certificate *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Certificate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Certificate(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Certificate *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const char *tag, std::vector<tt__Certificate *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Certificate(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Certificate *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Certificate, SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate, sizeof(tt__Certificate), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Certificate(soap, tag, NULL, "tt:Certificate"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Certificate(soap, tag, &n, "tt:Certificate"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Certificate *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Certificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Certificate *> *p;
	size_t k = sizeof(std::vector<tt__Certificate *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Certificate *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Certificate *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Certificate *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IPv6Address(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__IPv6Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IPv6Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IPv6Address(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__IPv6Address(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__IPv6Address, SOAP_TYPE_std__vectorTemplateOftt__IPv6Address, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IPv6Address(soap, tag, NULL, "tt:IPv6Address"))
				break;
		}
		else
		{	if (!soap_in_tt__IPv6Address(soap, tag, &n, "tt:IPv6Address"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IPv4Address(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__IPv4Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IPv4Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IPv4Address(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__IPv4Address(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__IPv4Address, SOAP_TYPE_std__vectorTemplateOftt__IPv4Address, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IPv4Address(soap, tag, NULL, "tt:IPv4Address"))
				break;
		}
		else
		{	if (!soap_in_tt__IPv4Address(soap, tag, &n, "tt:IPv4Address"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, std::vector<tt__NetworkProtocol *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const std::vector<tt__NetworkProtocol *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkProtocol *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkProtocol(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkProtocol *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkProtocol *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkProtocol(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkProtocol *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const char *tag, std::vector<tt__NetworkProtocol *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkProtocol(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__NetworkProtocol *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__NetworkProtocol, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol, sizeof(tt__NetworkProtocol), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkProtocol(soap, tag, NULL, "tt:NetworkProtocol"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkProtocol(soap, tag, &n, "tt:NetworkProtocol"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkProtocol *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkProtocol(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkProtocol *> *p;
	size_t k = sizeof(std::vector<tt__NetworkProtocol *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkProtocol *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkProtocol *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkProtocol *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, std::vector<tt__NetworkInterface *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const std::vector<tt__NetworkInterface *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkInterface *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkInterface(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkInterface *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkInterface *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkInterface(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkInterface *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const char *tag, std::vector<tt__NetworkInterface *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkInterface(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__NetworkInterface *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__NetworkInterface, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface, sizeof(tt__NetworkInterface), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkInterface(soap, tag, NULL, "tt:NetworkInterface"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkInterface(soap, tag, &n, "tt:NetworkInterface"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkInterface *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkInterface *> *p;
	size_t k = sizeof(std::vector<tt__NetworkInterface *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkInterface *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkInterface *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkInterface *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, std::vector<tt__IPAddress *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const std::vector<tt__IPAddress *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__IPAddress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__IPAddress(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const char *tag, int id, const std::vector<tt__IPAddress *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__IPAddress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__IPAddress(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IPAddress *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const char *tag, std::vector<tt__IPAddress *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__IPAddress(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__IPAddress *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__IPAddress, SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress, sizeof(tt__IPAddress), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__IPAddress(soap, tag, NULL, "tt:IPAddress"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__IPAddress(soap, tag, &n, "tt:IPAddress"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IPAddress *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__IPAddress *> *p;
	size_t k = sizeof(std::vector<tt__IPAddress *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__IPAddress *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__IPAddress *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__IPAddress *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__token(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__token(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__token(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__token(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__token(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__token(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__token(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_xsd__token(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__token, SOAP_TYPE_std__vectorTemplateOfxsd__token, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__token(soap, tag, NULL, "xsd:token"))
				break;
		}
		else
		{	if (!soap_in_xsd__token(soap, tag, &n, "xsd:token"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__token(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__token(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__token, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, std::vector<enum tt__CapabilityCategory> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const std::vector<enum tt__CapabilityCategory> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const char *tag, int id, const std::vector<enum tt__CapabilityCategory> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__CapabilityCategory> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__CapabilityCategory(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__CapabilityCategory> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const char *tag, std::vector<enum tt__CapabilityCategory> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__CapabilityCategory(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__CapabilityCategory n;
		soap_default_tt__CapabilityCategory(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__CapabilityCategory, SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__CapabilityCategory(soap, tag, NULL, "tt:CapabilityCategory"))
				break;
		}
		else
		{	if (!soap_in_tt__CapabilityCategory(soap, tag, &n, "tt:CapabilityCategory"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__CapabilityCategory>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__CapabilityCategory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__CapabilityCategory> *p;
	size_t k = sizeof(std::vector<enum tt__CapabilityCategory> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__CapabilityCategory> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__CapabilityCategory> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__CapabilityCategory>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__User(struct soap *soap, std::vector<tt__User *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__User(struct soap *soap, const std::vector<tt__User *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__User *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__User(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__User(struct soap *soap, const char *tag, int id, const std::vector<tt__User *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__User *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__User(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__User *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__User(struct soap *soap, const char *tag, std::vector<tt__User *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__User(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__User *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__User, SOAP_TYPE_std__vectorTemplateOfPointerTott__User, sizeof(tt__User), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__User(soap, tag, NULL, "tt:User"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__User(soap, tag, &n, "tt:User"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__User *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__User(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__User *> *p;
	size_t k = sizeof(std::vector<tt__User *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__User, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__User *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__User *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__User *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, std::vector<tt__NetworkHost *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const std::vector<tt__NetworkHost *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkHost *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkHost(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkHost *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkHost *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkHost(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkHost *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const char *tag, std::vector<tt__NetworkHost *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkHost(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__NetworkHost *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost, sizeof(tt__NetworkHost), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkHost(soap, tag, NULL, "tt:NetworkHost"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkHost(soap, tag, &n, "tt:NetworkHost"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkHost *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkHost *> *p;
	size_t k = sizeof(std::vector<tt__NetworkHost *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkHost *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkHost *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkHost *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyURI(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyURI(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyURI(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_xsd__anyURI(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__anyURI, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI"))
				break;
		}
		else
		{	if (!soap_in_xsd__anyURI(soap, tag, &n, "xsd:anyURI"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyURI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, std::vector<tt__Scope *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const std::vector<tt__Scope *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Scope *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Scope(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const char *tag, int id, const std::vector<tt__Scope *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Scope *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Scope(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Scope *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const char *tag, std::vector<tt__Scope *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Scope(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Scope *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Scope, SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope, sizeof(tt__Scope), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Scope(soap, tag, NULL, "tt:Scope"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Scope(soap, tag, &n, "tt:Scope"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Scope *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Scope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Scope *> *p;
	size_t k = sizeof(std::vector<tt__Scope *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Scope *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Scope *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Scope *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, std::vector<tt__BackupFile *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const std::vector<tt__BackupFile *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__BackupFile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__BackupFile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const char *tag, int id, const std::vector<tt__BackupFile *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__BackupFile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__BackupFile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__BackupFile *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const char *tag, std::vector<tt__BackupFile *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__BackupFile(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__BackupFile *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__BackupFile, SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile, sizeof(tt__BackupFile), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__BackupFile(soap, tag, NULL, "tt:BackupFile"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__BackupFile(soap, tag, &n, "tt:BackupFile"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__BackupFile *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__BackupFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__BackupFile *> *p;
	size_t k = sizeof(std::vector<tt__BackupFile *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__BackupFile *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__BackupFile *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__BackupFile *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, std::vector<tds__Service *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const std::vector<tds__Service *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tds__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotds__Service(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const char *tag, int id, const std::vector<tds__Service *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tds__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotds__Service(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tds__Service *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const char *tag, std::vector<tds__Service *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotds__Service(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tds__Service *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tds__Service, SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service, sizeof(tds__Service), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotds__Service(soap, tag, NULL, "tds:Service"))
				break;
		}
		else
		{	if (!soap_in_PointerTotds__Service(soap, tag, &n, "tds:Service"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tds__Service *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotds__Service(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tds__Service *> *p;
	size_t k = sizeof(std::vector<tds__Service *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tds__Service *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tds__Service *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tds__Service *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
